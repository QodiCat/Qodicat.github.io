<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>经典网络（十）循环神经网络RNN</title>
      <link href="/2023/12/22/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN/"/>
      <url>/2023/12/22/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN/</url>
      
        <content type="html"><![CDATA[<h1 id="1-提出背景"><a href="#1-提出背景" class="headerlink" title="1 提出背景"></a>1 提出背景</h1><p>为什么要引入RNN呢？</p><p>非常简单，之前我们的卷积神经网络CNN，全连接神经网络等都是单个神经元计算</p><p>但在序列模型中，前一个神经元往往对后面一个神经元有影响</p><p>比如</p><p>两句话</p><p>I like eating apples.</p><p>I want to have a apple watch </p><p>第一个苹果和第二个苹果的概念是不一样的，第一个苹果是红彤彤的苹果，第二个苹果是苹果公司的意思</p><p>如何知道</p><p>是因为apple的翻译参考了上下文，第一句话看到了eating这个单词，第二句话看到了watch这个单词</p><p>因而可见，对于语言这种时序信息，利用需要参考上下文进行</p><p>还有其他原因</p><ul><li>拿人类的某句话来说，也就是人类的自然语言，是不是符合某个逻辑或规则的字词拼凑排列起来的，这就是符合序列特性。</li><li>语音，我们发出的声音，每一帧每一帧的衔接起来，才凑成了我们听到的话，这也具有序列特性、</li><li>股票，随着时间的推移，会产生具有顺序的一系列数字，这些数字也是具有序列特性。</li></ul><h1 id="2-RNN"><a href="#2-RNN" class="headerlink" title="2 RNN"></a>2 RNN</h1><p>具有时序功能，从某种意义来说，RNN也就具有了记忆功能，好比我们人类自己，为什么会受到过去影响，因为我们具有记忆能力。</p><p>同时只有记忆能力是不够的，处理后的信息得储存起来，形成“新的记忆”</p><p>对于RNN，可以分为单向RNN，和双向RNN，其中单向的是只利用前面的信息，而双向的RNN既可以利用前面的信息，也可以利用后面的信息。</p><h2 id="2-1-RNN结构"><a href="#2-1-RNN结构" class="headerlink" title="2.1 RNN结构"></a>2.1 RNN结构</h2><p>RNN的基本单元包含以下关键组件：</p><ul><li><strong>输入 (</strong>$x_t$ <strong>)：</strong> 表示在时间步 (t) 的输入序列。</li><li><strong>隐藏状态 (</strong>$h_t$ <strong>)：</strong> 在时间步 (t) 的隐藏状态，是网络在处理序列过程中保留的信息相当于ht里面藏着上下文信息</li><li>**每一步的输出(Oi)**：每一个时间步有一个输出Oi，Oi综合了当前时间步和之前的很多信息，那么对于某些特定任务，如分类什么的，就可以直接用Oi去做判断。很多时候直接把隐藏状态拿去做了输出</li></ul><p>如下图，图片来自《动手学深度学习》</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116110536186.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116110536186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240116110536186"></p><p>那么每一个隐状态是通过怎样的方式得到的呢？</p><p>RNN的隐藏状态 (ht ) 的计算通过以下数学公式完成：</p><p>$h_t&#x3D;tanh(W_{ih}x_t+b_{ih}+W_{hh}h_{t−1}+b_{hh}) $</p><p>这个公式展示了RNN如何根据当前输入 (xt ) 和前一个时间步的隐藏状态 (ht−1 ) 来计算当前时间步的隐藏状态 (ht )。其中 (tanh) 是双曲正切激活函数，用于引入非线性。</p><p>实际中我们可以看到</p><ul><li><strong>权重矩阵 (</strong>$W_{ih} , W_{hh} $)： 分别是输入到隐藏状态和隐藏状态到隐藏状态的权重矩阵。</li><li><strong>偏差 ($b_{ih} , b_{hh} $)：</strong> 对应的偏差。</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116085106735.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116085106735.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240116085106735"></p><p>第一个问题 是每一个句子的长度不一致，你怎么用统一的矩阵呢？</p><p>​只实现了一个单层神经元，可以通过获得句子长度知道时间步数t，进一步做相关的调整</p><h2 id="2-2-RNN代码实现"><a href="#2-2-RNN代码实现" class="headerlink" title="2.2 RNN代码实现"></a>2.2 RNN代码实现</h2><p>代码实现首先实现上图的一个神经元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rnn</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    <span class="comment"># inputs的形状：(时间步数量，批量大小，词表大小)</span></span><br><span class="line">    W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="comment"># X的形状：(批量大小，词表大小)</span></span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)</span><br><span class="line">        Y = torch.mm(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RNNModelScratch</span>: <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, device,</span></span><br><span class="line"><span class="params">                 get_params, init_state, forward_fn</span>):</span><br><span class="line">        self.vocab_size, self.num_hiddens = vocab_size, num_hiddens</span><br><span class="line">        self.params = get_params(vocab_size, num_hiddens, device)</span><br><span class="line">        self.init_state, self.forward_fn = init_state, forward_fn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, X, state</span>):</span><br><span class="line">        X = F.one_hot(X.T, self.vocab_size).<span class="built_in">type</span>(torch.float32)</span><br><span class="line">        <span class="keyword">return</span> self.forward_fn(X, state, self.params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self, batch_size, device</span>):</span><br><span class="line">        <span class="keyword">return</span> self.init_state(batch_size, self.num_hiddens, device)</span><br></pre></td></tr></table></figure><p>然后利用循环，根据语句长度做预测判断，损失函数计算优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_ch8</span>(<span class="params">prefix, num_preds, net, vocab, device</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在prefix后面生成新字符&quot;&quot;&quot;</span></span><br><span class="line">    state = net.begin_state(batch_size=<span class="number">1</span>, device=device)</span><br><span class="line">    outputs = [vocab[prefix[<span class="number">0</span>]]]</span><br><span class="line">    get_input = <span class="keyword">lambda</span>: torch.tensor([outputs[-<span class="number">1</span>]], device=device).reshape((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> prefix[<span class="number">1</span>:]:  <span class="comment"># 预热期</span></span><br><span class="line">        _, state = net(get_input(), state)</span><br><span class="line">        outputs.append(vocab[y])</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_preds):  <span class="comment"># 预测num_preds步</span></span><br><span class="line">        y, state = net(get_input(), state)</span><br><span class="line">        outputs.append(<span class="built_in">int</span>(y.argmax(dim=<span class="number">1</span>).reshape(<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="keyword">for</span> i <span class="keyword">in</span> outputs])</span><br></pre></td></tr></table></figure><h2 id="2-3-代码简洁实现"><a href="#2-3-代码简洁实现" class="headerlink" title="2.3 代码简洁实现"></a>2.3 代码简洁实现</h2><p>往往通过一个nn.RNN来实现</p><p> nn.RNN(input_size, hidden_size, num_layers&#x3D;1, nonlinearity&#x3D;tanh, bias&#x3D;True, batch_first&#x3D;False, dropout&#x3D;0, bidirectional&#x3D;False)</p><p>参数说明</p><p>input_size输入特征的维度， 一般rnn中输入的是词向量，那么 input_size 就等于一个词向量的维度<br>hidden_size隐藏层神经元个数，或者也叫输出的维度（因为rnn输出为各个时间步上的隐藏状态）<br>num_layers网络的层数，一般可以默认为1<br>nonlinearity激活函数<br>bias是否使用偏置<br>batch_first输入数据的形式，默认是 False，就是这样形式，(seq(num_step), batch, input_dim)，也就是将序列长度放在第一位，batch 放在第二位<br>dropout是否应用dropout, 默认不使用，如若使用将其设置成一个0-1的数字即可<br>birdirectional是否使用双向的 rnn，默认是 False<br>注意某些参数的默认值在标题中已注明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rnn_layer = nn.RNN(input_size=vocab_size, hidden_size=num_hiddens, )</span><br></pre></td></tr></table></figure><p> 定义模型， 其中vocab_size &#x3D; 1027, hidden_size &#x3D; 256</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2023/12/22/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9%20%E6%96%87%E7%AB%A0/"/>
      <url>/2023/12/22/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9%20%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-提出背景"><a href="#1-提出背景" class="headerlink" title="1 提出背景"></a>1 提出背景</h1><p>为什么要引入RNN呢？</p><p>非常简单，之前我们的卷积神经网络CNN，全连接神经网络等都是单个神经元计算</p><p>但在序列模型中，前一个神经元往往对后面一个神经元有影响</p><p>比如</p><p>两句话</p><p>I like eating apples.</p><p>I want to have a apple watch </p><p>第一个苹果和第二个苹果的概念是不一样的，第一个苹果是红彤彤的苹果，第二个苹果是苹果公司的意思</p><p>如何知道</p><p>是因为apple的翻译参考了上下文，第一句话看到了eating这个单词，第二句话看到了watch这个单词</p><p>因而可见，对于语言这种时序信息，利用需要参考上下文进行</p><p>还有其他原因</p><ul><li>拿人类的某句话来说，也就是人类的自然语言，是不是符合某个逻辑或规则的字词拼凑排列起来的，这就是符合序列特性。</li><li>语音，我们发出的声音，每一帧每一帧的衔接起来，才凑成了我们听到的话，这也具有序列特性、</li><li>股票，随着时间的推移，会产生具有顺序的一系列数字，这些数字也是具有序列特性。</li></ul><h1 id="2-RNN"><a href="#2-RNN" class="headerlink" title="2 RNN"></a>2 RNN</h1><p>具有时序功能，从某种意义来说，RNN也就具有了记忆功能，好比我们人类自己，为什么会受到过去影响，因为我们具有记忆能力。</p><p>同时只有记忆能力是不够的，处理后的信息得储存起来，形成“新的记忆”</p><p>对于RNN，可以分为单向RNN，和双向RNN，其中单向的是只利用前面的信息，而双向的RNN既可以利用前面的信息，也可以利用后面的信息。</p><h2 id="2-1-RNN结构"><a href="#2-1-RNN结构" class="headerlink" title="2.1 RNN结构"></a>2.1 RNN结构</h2><p>RNN的基本单元包含以下关键组件：</p><ul><li><strong>输入 (</strong>$x_t$ <strong>)：</strong> 表示在时间步 (t) 的输入序列。</li><li><strong>隐藏状态 (</strong>$h_t$ <strong>)：</strong> 在时间步 (t) 的隐藏状态，是网络在处理序列过程中保留的信息相当于ht里面藏着上下文信息</li><li>**每一步的输出(Oi)**：每一个时间步有一个输出Oi，Oi综合了当前时间步和之前的很多信息，那么对于某些特定任务，如分类什么的，就可以直接用Oi去做判断。很多时候直接把隐藏状态拿去做了输出</li></ul><p>如下图，图片来自《动手学深度学习》</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116110536186.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116110536186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240116110536186"></p><p>那么每一个隐状态是通过怎样的方式得到的呢？</p><p>RNN的隐藏状态 (ht ) 的计算通过以下数学公式完成：</p><p>$h_t&#x3D;tanh(W_{ih}x_t+b_{ih}+W_{hh}h_{t−1}+b_{hh}) $</p><p>这个公式展示了RNN如何根据当前输入 (xt ) 和前一个时间步的隐藏状态 (ht−1 ) 来计算当前时间步的隐藏状态 (ht )。其中 (tanh) 是双曲正切激活函数，用于引入非线性。</p><p>实际中我们可以看到</p><ul><li><strong>权重矩阵 (</strong>$W_{ih} , W_{hh} $)： 分别是输入到隐藏状态和隐藏状态到隐藏状态的权重矩阵。</li><li><strong>偏差 ($b_{ih} , b_{hh} $)：</strong> 对应的偏差。</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116085106735.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240116085106735.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240116085106735"></p><p>第一个问题 是每一个句子的长度不一致，你怎么用统一的矩阵呢？</p><p>​只实现了一个单层神经元，可以通过获得句子长度知道时间步数t，进一步做相关的调整</p><h2 id="2-2-RNN代码实现"><a href="#2-2-RNN代码实现" class="headerlink" title="2.2 RNN代码实现"></a>2.2 RNN代码实现</h2><p>代码实现首先实现上图的一个神经元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rnn</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    <span class="comment"># inputs的形状：(时间步数量，批量大小，词表大小)</span></span><br><span class="line">    W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="comment"># X的形状：(批量大小，词表大小)</span></span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)</span><br><span class="line">        Y = torch.mm(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RNNModelScratch</span>: <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, device,</span></span><br><span class="line"><span class="params">                 get_params, init_state, forward_fn</span>):</span><br><span class="line">        self.vocab_size, self.num_hiddens = vocab_size, num_hiddens</span><br><span class="line">        self.params = get_params(vocab_size, num_hiddens, device)</span><br><span class="line">        self.init_state, self.forward_fn = init_state, forward_fn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, X, state</span>):</span><br><span class="line">        X = F.one_hot(X.T, self.vocab_size).<span class="built_in">type</span>(torch.float32)</span><br><span class="line">        <span class="keyword">return</span> self.forward_fn(X, state, self.params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self, batch_size, device</span>):</span><br><span class="line">        <span class="keyword">return</span> self.init_state(batch_size, self.num_hiddens, device)</span><br></pre></td></tr></table></figure><p>然后利用循环，根据语句长度做预测判断，损失函数计算优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_ch8</span>(<span class="params">prefix, num_preds, net, vocab, device</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在prefix后面生成新字符&quot;&quot;&quot;</span></span><br><span class="line">    state = net.begin_state(batch_size=<span class="number">1</span>, device=device)</span><br><span class="line">    outputs = [vocab[prefix[<span class="number">0</span>]]]</span><br><span class="line">    get_input = <span class="keyword">lambda</span>: torch.tensor([outputs[-<span class="number">1</span>]], device=device).reshape((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> prefix[<span class="number">1</span>:]:  <span class="comment"># 预热期</span></span><br><span class="line">        _, state = net(get_input(), state)</span><br><span class="line">        outputs.append(vocab[y])</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_preds):  <span class="comment"># 预测num_preds步</span></span><br><span class="line">        y, state = net(get_input(), state)</span><br><span class="line">        outputs.append(<span class="built_in">int</span>(y.argmax(dim=<span class="number">1</span>).reshape(<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="keyword">for</span> i <span class="keyword">in</span> outputs])</span><br></pre></td></tr></table></figure><h2 id="2-3-代码简洁实现"><a href="#2-3-代码简洁实现" class="headerlink" title="2.3 代码简洁实现"></a>2.3 代码简洁实现</h2><p>往往通过一个nn.RNN来实现</p><p> nn.RNN(input_size, hidden_size, num_layers&#x3D;1, nonlinearity&#x3D;tanh, bias&#x3D;True, batch_first&#x3D;False, dropout&#x3D;0, bidirectional&#x3D;False)</p><p>参数说明</p><p>input_size输入特征的维度， 一般rnn中输入的是词向量，那么 input_size 就等于一个词向量的维度<br>hidden_size隐藏层神经元个数，或者也叫输出的维度（因为rnn输出为各个时间步上的隐藏状态）<br>num_layers网络的层数，一般可以默认为1<br>nonlinearity激活函数<br>bias是否使用偏置<br>batch_first输入数据的形式，默认是 False，就是这样形式，(seq(num_step), batch, input_dim)，也就是将序列长度放在第一位，batch 放在第二位<br>dropout是否应用dropout, 默认不使用，如若使用将其设置成一个0-1的数字即可<br>birdirectional是否使用双向的 rnn，默认是 False<br>注意某些参数的默认值在标题中已注明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rnn_layer = nn.RNN(input_size=vocab_size, hidden_size=num_hiddens, )</span><br></pre></td></tr></table></figure><p> 定义模型， 其中vocab_size &#x3D; 1027, hidden_size &#x3D; 256</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（七）ResNet全解析</title>
      <link href="/2023/12/21/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.3%20ResNet/"/>
      <url>/2023/12/21/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.3%20ResNet/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设计初衷"><a href="#1-设计初衷" class="headerlink" title="1 设计初衷"></a>1 设计初衷</h1><p>我们之前讲了VGG等网络，在之前网络的研究中，研究者感觉</p><p>网络越深，分类准确率越高，但是随着网络的加深，科学家们发现分类准确率反而会下降，无论是在训练集上还是测试集上。</p><p>ResNet的作者团队发现了这种现象的真正原因是：</p><p>训练过程中网络的正、反向的信息流动不顺畅，网络没有被充分训练，他们称之为“退化”</p><h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2.网络结构"></a>2.网络结构</h1><h2 id="2-1-残差块"><a href="#2-1-残差块" class="headerlink" title="2.1 残差块"></a>2.1 残差块</h2><p>解决方式：</p><p>​构建了残差模块，通过堆叠残差模块，可以构建任意深度的神经网络，而不会出现退化的现象</p><p>​提出了批归一化对抗梯度消失，该方法降低了网络训练过程中对于权重初始化的依赖</p><p>$H(x)&#x3D;F(x)+x$</p><p>我们网络要学习的是F(x)</p><p>$F(x)&#x3D;H(x)-x$</p><p>F（x）实际上就是输出与输入的差异，所以叫做残差模块</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925220139795.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925220139795.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230925220139795"></p><h2 id="2-2-中间的卷积网络特征提取块"><a href="#2-2-中间的卷积网络特征提取块" class="headerlink" title="2.2 中间的卷积网络特征提取块"></a>2.2 中间的卷积网络特征提取块</h2><p>中间的块有两种可能</p><h3 id="1-两层3×3卷积层"><a href="#1-两层3×3卷积层" class="headerlink" title="1 两层3×3卷积层"></a>1 两层3×3卷积层</h3><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925220517010.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925220517010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230925220517010"></p><h3 id="2-先1×1卷积层，再3×3卷积层，再3×3卷积层"><a href="#2-先1×1卷积层，再3×3卷积层，再3×3卷积层" class="headerlink" title="2 先1×1卷积层，再3×3卷积层，再3×3卷积层"></a>2 先1×1卷积层，再3×3卷积层，再3×3卷积层</h3><p>第一个用了1×1把卷积通道降下去（减少运算量），第二个用了1×1把卷积通道再升上去（便于和输入x连接）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925220532278.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925220532278.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230925220532278"></p><h2 id="2-3-结构总览表格"><a href="#2-3-结构总览表格" class="headerlink" title="2.3 结构总览表格"></a>2.3 结构总览表格</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925173820561.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925173820561.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230925173820561"></p><p>表中展示了18层，34层，50层，101层，152层的ResNet的结构</p><p>[ ]方括号中即是我们上面讲的两个特征提取块，×几代表堆叠几个</p><p>最后经过一个全局平均池化，一个全连接层</p><h1 id="3-为什么残差模块有效？"><a href="#3-为什么残差模块有效？" class="headerlink" title="3 为什么残差模块有效？"></a>3 为什么残差模块有效？</h1><h2 id="3-1-前向传播"><a href="#3-1-前向传播" class="headerlink" title="3.1 前向传播"></a>3.1 前向传播</h2><p>1 <strong>前向传播过程中重要信息不消失</strong></p><p>通过残差网络的设计，我们可以理解为原来的有机会信息可以维持不变，对分类有帮助的信息得到加强</p><p>能够避免卷积层堆叠存在的信息丢失</p><h2 id="3-2-反向传播"><a href="#3-2-反向传播" class="headerlink" title="3.2 反向传播"></a>3.2 反向传播</h2><p>2 <strong>反向传播中梯度可以控制不消失</strong></p><p>在典型的残差模块中，输入数据被分为两部分，一部分通过一个或多个神经层进行变换，而另一部分直接传递给输出。这个直接传递的部分是输入数据的恒等映射，即没有变换。这意味着至少一部分的信息在经过神经网络之后保持不变。</p><p>当进行反向传播以更新神经网络参数时，梯度是根据损失函数计算的。在传统的深度神经网络中，由于多层的网络梯度相乘，梯度可以逐渐变小并导致梯度消失。但在残差模块中，由于存在恒等映射，至少一部分梯度可以直接通过跳过变换的路径传播，而不会受到变换的影响。</p><p>$H(x)&#x3D;F(x)+x$</p><p>比如这个式子对x求偏导$∂F&#x2F;∂x+1$ </p><p>这时候保证了梯度至少会加1 不让梯度连乘逐渐变小</p><h2 id="3-3-恒等映射"><a href="#3-3-恒等映射" class="headerlink" title="3.3 恒等映射"></a>3.3 恒等映射</h2><p>3，可以理解为当网络变深之后，非线性变得很强，<strong>网络很难学会简单的恒等映射，残差模块可以解决这个问题</strong></p><h2 id="3-4-集成模型"><a href="#3-4-集成模型" class="headerlink" title="3.4 集成模型"></a>3.4 集成模型</h2><p>4 残差网络可以看做一种<strong>集成模型</strong></p><p>可以看做很多简单或复杂的子网络的组合求和！！！</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925145105929.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230925145105929.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230925145105929"></p><p>但是这样可能会造成冗余，因为其中还可能会有很多不需要的信息，这便是后来的DenseNet，会让速度提升</p><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h1><p>实现的是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual_block</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,input_channels,output_channels,first=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.first=first</span><br><span class="line">        <span class="keyword">if</span> first==<span class="literal">True</span>:</span><br><span class="line">            self.conv1=nn.Conv2d(input_channels,output_channels,stride=<span class="number">2</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>)</span><br><span class="line">            self.conv3=nn.Conv2d(input_channels,output_channels,kernel_size=<span class="number">1</span>,stride=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv1=nn.Conv2d(output_channels,output_channels,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.bn1=nn.BatchNorm2d(output_channels)</span><br><span class="line">        self.conv2=nn.Conv2d(output_channels,output_channels,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.bn2=nn.BatchNorm2d(output_channels)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        Y=F.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        Y=self.bn2(self.conv2(Y))</span><br><span class="line">        <span class="keyword">if</span> self.first==<span class="literal">True</span>:</span><br><span class="line">            x=self.conv3(x)</span><br><span class="line">        Y=x+Y</span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">input_channels,output_channels,num_residual_block,special=<span class="literal">False</span></span>):</span><br><span class="line">    blk=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residual_block):</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> special==<span class="literal">True</span>:</span><br><span class="line">            blk.append(Residual_block(input_channels,input_channels))</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> special==<span class="literal">False</span>:</span><br><span class="line">            blk.append(Residual_block(input_channels,output_channels,first=<span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual_block(output_channels,output_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1=nn.Sequential(</span><br><span class="line">    nn.Conv2d(kernel_size=<span class="number">7</span>,in_channels=<span class="number">3</span>,out_channels=<span class="number">64</span>,stride=<span class="number">2</span>,padding=<span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">)</span><br><span class="line">R1=Residual_block(<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line">x=torch.ones(<span class="number">1</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> b1:</span><br><span class="line">    x=layer(x)</span><br><span class="line"></span><br><span class="line">b18_2=nn.Sequential(*resnet_block(<span class="number">64</span>,<span class="number">64</span>,<span class="number">2</span>,special=<span class="literal">True</span>))</span><br><span class="line">b18_3=nn.Sequential(*resnet_block(<span class="number">64</span>,<span class="number">128</span>,<span class="number">2</span>))</span><br><span class="line">b18_4=nn.Sequential(*resnet_block(<span class="number">128</span>,<span class="number">256</span>,<span class="number">2</span>))</span><br><span class="line">b18_5=nn.Sequential(*resnet_block(<span class="number">256</span>,<span class="number">512</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">b34_2=nn.Sequential(*resnet_block(<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>,special=<span class="literal">True</span>))</span><br><span class="line">b34_3=nn.Sequential(*resnet_block(<span class="number">64</span>,<span class="number">128</span>,<span class="number">4</span>))</span><br><span class="line">b34_4=nn.Sequential(*resnet_block(<span class="number">128</span>,<span class="number">256</span>,<span class="number">6</span>))</span><br><span class="line">b34_5=nn.Sequential(*resnet_block(<span class="number">256</span>,<span class="number">512</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Resnet-18</span></span><br><span class="line">Resnet_18=nn.Sequential(b1,b18_2,b18_3,b18_4,b18_5,nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),nn.Flatten(),nn.Linear(<span class="number">512</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment">#Resnet-34</span></span><br><span class="line">Resnet_18=nn.Sequential(b1,b34_2,b34_3,b34_4,b34_5,nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),nn.Flatten(),nn.Linear(<span class="number">512</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>通道数什么时候升高？</p><p>尺寸什么时候变？</p><p>在每个块初做一下降低尺寸和</p><p><a href="https://zhuanlan.zhihu.com/p/101332297">https://zhuanlan.zhihu.com/p/101332297</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典CV任务（二）目标检测</title>
      <link href="/2023/12/20/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.1%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
      <url>/2023/12/20/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.1%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-目标检测"><a href="#1-目标检测" class="headerlink" title="1 目标检测"></a>1 目标检测</h1><p>目标检测的重要任务是</p><ol><li><strong>目标定位</strong>：目标检测的首要任务是确定图像中对象的位置，通常使用边界框（Bounding Box）来描述目标的位置。边界框由一对坐标表示，通常是左上角和右下角的坐标。</li><li><strong>目标识别</strong>：目标检测不仅要定位目标，还要识别目标的类别或类别标签。这通常涉及将检测到的对象与已知的类别进行比较，从而确定它是什么物体。</li></ol><p>所以目标检测可以通俗理解为分类+定位</p><p>我不仅要告诉你什么类别，还要告诉你在哪儿</p><p>在这个任务中，我们用边界框，来定位我们的物体</p><p>边界框的位置表示有两种</p><p>第一种是边框的坐上，右下的点的坐标点x1,y1  x2,y2</p><p>第二种是边框的中间点坐标，和宽高</p><p>两种方式都可以唯一确定图片上的边框，并且可以相互转换</p><h2 id="1-1-单目标检测"><a href="#1-1-单目标检测" class="headerlink" title="1.1 单目标检测"></a>1.1 单目标检测</h2><p>即图片中只有一个要检测的物体，这个难度相对来说小一些</p><p>直观可以想到一种方式</p><p>首先拿一个卷积网络提取特征</p><p>再利用提取到的特征（假如提取到的特征是2048）一方面可以接一个全连接层做分类（比如2048到10类），另一方面可以接全连接层做坐标点的回归（比如2048到4个坐标点）</p><p>这样需要两个损失函数，一个损失函数降低分类错误率，另一个损失函数降低回归错误率，我们称这样的网络叫做<strong>多任务多损失网络</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230927151643757.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230927151643757.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230927151643757"></p><p>对于这样的任务</p><p>一般可以<strong>多阶段训练</strong></p><p>1 先训练分类分支</p><p>2 再在分类分支训练好的基础上训练坐标点回归</p><p>3 最后一步将两个合并到一起训练</p><h2 id="1-2-多目标检测"><a href="#1-2-多目标检测" class="headerlink" title="1.2 多目标检测"></a>1.2 多目标检测</h2><p>图片中可能有多个要检测的物体，这个难度就更大了</p><p>物体的个数是未知的，我们不能像单目标检测那样只回归一个坐标点，回归的坐标点个数是未知的！！天啊该怎么呢</p><p>所以研究者们做了如下一些尝试</p><h3 id="3-2-1-阶段一-单像素点采样目标检测"><a href="#3-2-1-阶段一-单像素点采样目标检测" class="headerlink" title="3.2.1 阶段一 单像素点采样目标检测"></a>3.2.1 阶段一 单像素点采样目标检测</h3><p>既然直接回归不行，那么我们可以先产生很多的边界框（术语叫锚框），让网络对这些边界框 锚框一个一个做分类，并预测它距离真实边框的偏移量！</p><p>最开始大伙儿尝试直接对于<strong>每个像素点给出不同尺寸的锚框</strong></p><p>当生成足够多的锚框的时候，大力出奇迹，总会有框几乎把我们的目标框住的</p><p>这时候对于每个区域进行分类判断，一张图片可能会产生几十万上百万张图片，然后让网络进行分类</p><p>直观感受 是有点鲁莽！！！密集恐惧症颤抖</p><p>实际也证明这种方式的运算量巨大，但他是可行的方式</p><p><strong>训练阶段</strong></p><p>我们把每一个锚框看作一个训练样本</p><p>这个训练样本需要两个标记，一是类别（一般就分配给与它最近边框的类别即可），二是与它最近的真实边框的偏移量</p><p>模型对于每一个框需要预测它的类别，与最近的真实边框的偏移量</p><p><strong>预测阶段</strong></p><p>首先为图像生成多个锚框</p><p>利用模型为这些锚框一 一预测类别和偏移量</p><p>有一个可能的问题，我们生成了多个相似的具有明显重叠的锚框</p><p>采用<strong>非极大值抑制</strong>来合并属于同一目标的相似的边界框</p><p>（1）首先，根据每个候选边界框的得分（通常是模型预测的物体存在概率或置信度分数）对所有候选边界框进行降序排序，得分较高的边界框排在前面。</p><p>（2）选择得分最高的边界框，并将其添加到最终的筛选结果中。这个边界框通常被认为是最有可能包含真实目标的边界框。</p><p>（3）于剩余的候选边界框，计算它们与已选择的高分边界框的重叠区域（通常使用IoU，Intersection over Union来衡量）。IoU是两个边界框重叠区域与它们的联合区域的比例。</p><p>（4）<strong>剔除重叠边界框</strong>：如果某个候选边界框与已选择的高分边界框具有高于预定阈值的IoU值（也就意味着和我们得分最高的边界重叠过高），则将该候选边界框从列表中移除</p><p>（5）<strong>重复步骤</strong>：重复步骤2到步骤4，直到没有更多的候选边界框需要处理。</p><p>（6）输出结果：NMS会输出一组经过非极大值抑制筛选的边界框</p><p>可以做这样一个<strong>比喻来通俗理解这件事情</strong></p><p>想象你是一名宝藏猎人，你有一块地图上标有可能埋有宝藏的若干区域。你的任务是找到最有可能埋有宝藏的区域，同时避免走重复的路线，因为这不会增加你找到宝藏的机会。</p><ol><li><strong>得分排序</strong>：每个区域都有一个分数，表示它有多大的可能性埋有宝藏。你首先查看地图上所有区域的分数，将得分最高的区域放在列表的最前面，就像把最有希望的区域标记在地图上。</li><li><strong>选择高分区域</strong>：你首先前往得分最高的区域，因为那里找到宝藏的可能性最大。</li><li><strong>计算重叠区域</strong>：当你到达一个区域后，你会注意到一些其他区域可能与你当前所在的区域有很大的重叠。这就像你走到了一个区域，但可能有其他猎人也在附近搜索。</li><li><strong>剔除重叠区域</strong>：为了避免重复工作，你会检查其他猎人所在的区域，如果它们与你当前的区域有很大的重叠（重复搜索的可能性高），你会决定不再前往这些区域，而是继续前往下一个可能性很高的区域。</li><li><strong>重复步骤</strong>：你会不断重复前往得分最高的区域、计算重叠区域和剔除重叠区域的步骤，直到你认为没有更值得前往的高分区域为止。</li><li><strong>输出结果</strong>：最终，你的努力会得到一组标记为最有可能埋有宝藏的区域，而且你不会重复浪费时间去搜索高度重叠的区域。</li></ol><h3 id="3-2-2-阶段二-多像素点采样目标检测"><a href="#3-2-2-阶段二-多像素点采样目标检测" class="headerlink" title="3.2.2 阶段二 多像素点采样目标检测"></a>3.2.2 阶段二 多像素点采样目标检测</h3><p>单像素点采样直接对于所有像素点为中心给出不同尺寸的锚框，运算量巨大</p><p>那么我们可不可以降低一下这个运输量呢？</p><p>当然可以啦</p><p>我们以一小部分像素为中心生成不同锚框</p><p>比如2×2像素，比如4×4像素</p><p>这样就可以降低我们的锚框量啦</p><h3 id="3-2-3-阶段三-RNN"><a href="#3-2-3-阶段三-RNN" class="headerlink" title="3.2.3 阶段三 RNN"></a>3.2.3 阶段三 RNN</h3><p>但是即便如此，锚框量依然巨大</p><p>那么我们可不可以进一步减少锚框量呢，可以的</p><p>我们可以采用某些算法，给出建议区域，即找出所有潜在可能包含目标的区域</p><p>这便是R-CNN系列</p><p><strong>R-CNN</strong></p><p>1  利用区域建议方法selective search产生的感兴趣区域，大约2000个候选区域（或称为候选框），这些区域被认为可能包含目标物体。</p><p>2  对于每个候选区域，R-CNN将其缩放裁剪出来，并通过一个预训练的卷积神经网络（通常是AlexNet）提取特征。这些候选区域在CNN中前向传播，生成固定长度的特征向量。</p><p>3 特征向量被送入一个独立的支持向量机（SVM）分类器，每个SVM分类器用于识别特定类别的目标物体。这意味着为每个可能的目标类别都训练一个二元分类器，以判断特定候选区域是否包含属于该类别的物体。</p><p>4 此外，R-CNN还包括一个边界框回归器，用于微调候选区域的边界框，以更准确地定位目标物体。</p><p>5 最后，为了去除重叠和冗余的检测结果，使用非极大值抑制（NMS）来选择最终的检测边界框。</p><p>R-CNN可以有着更高的精度，处理的锚框也少了，但是它产生感兴趣区域也很耗时</p><p>总结来看他的缺点</p><ul><li>训练和推理速度慢，因为每个候选区域都要进行独立的前向传播和分类。</li><li>需要大量的存储空间，因为要保存每个候选区域的特征向量和分类器参数。</li><li>不够端到端，训练过程相对复杂。</li></ul><p><strong>Fast R-CNN</strong></p><p>Fast R-CNN看名字就可以知道哈哈哈哈是R-CNN的改进，让他变得更快，同时变得端到端</p><p>1  首先利用卷积网络进行特征提取</p><p>2   提取到的特征图再做感兴趣区域建议！而特征图的区域是可以和原图一一映射的</p><p>3   再对取出来的区域做裁剪缩放（Rol Align 双线性插值），然后利用全连接层输出每个感兴趣区域的特征进行分类或回归</p><p>4 使用非极大值抑制（NMS）来选择最终的检测边界框。</p><p><strong>Faster R-CNN</strong></p><p>与R-CNN不同，Fast R-CNN不再使用选择性搜索等传统方法生成大量候选区域。相反，它引入了一种叫做”候选区域提取网络（Region Proposal Network，RPN）”的网络模块，用于生成高质量的候选区域。提高了效率</p><p>1  首先利用卷积网络进行特征提取</p><p>2   提取到的特征图利用候选区域提取网络获得感兴趣区域！而特征图的区域是可以和原图一一映射的</p><p>候选区域提取网络需要进行二分类 是目标还是背景</p><p>3   再对取出来的区域做裁剪缩放（Rol Align 双线性插值），然后利用全连接层输出每个感兴趣区域的特征进行分类或回归</p><p>4 使用非极大值抑制（NMS）来选择最终的检测边界框。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230927201110244.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230927201110244.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230927201110244"></p><h3 id="3-2-4-阶段四-一阶段的目标检测-Yolo-SSD"><a href="#3-2-4-阶段四-一阶段的目标检测-Yolo-SSD" class="headerlink" title="3.2.4 阶段四 一阶段的目标检测 Yolo&#x2F;SSD"></a>3.2.4 阶段四 一阶段的目标检测 Yolo&#x2F;SSD</h3><p><strong>Yolo</strong></p><p>YOLO采用单一的卷积神经网络来同时处理目标检测和分类任务。与传统的两阶段目标检测方法不同（如R-CNN系列），YOLO将目标检测任务转化为回归问题，一次性输出所有检测框的位置和类别信息。</p><p>​不用区域建议网络了，直接把图片分成7×7，每个网格单元负责检测图像中的物体，产生一个或多个候选框。</p><p>每个网格单元预测多个候选框（通常是B个，如2或3个）。每个候选框由5个参数定义：中心坐标（x, y）、宽度（w）、高度（h）以及物体存在概率（objectness score）。这些参数用于定义每个候选框的位置和是否包含物体。</p><p>每个网格单元还预测C个类别的概率分数，用于表示物体属于每个类别的可能性。这些类别概率分数与每个候选框关联。</p><p><strong>SSD</strong></p><p>SSD和之前工作主要区别是  </p><p>SSD引入了一组称为Anchor框的预定义边界框。每个Anchor框与特定位置和尺度的特征图单元相对应。这些Anchor框用于尝试捕获不同尺寸和比例的物体。</p><p>结论</p><p>​Faster R-CNN速度偏慢，但精度高</p><p>​SSD速度快，精度高</p><p>​主干网络越宽，深度越深对性能帮助越大</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（六）GoogleNet全解析</title>
      <link href="/2023/12/20/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.2%20GoogleNet%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/12/20/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.2%20GoogleNet%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>之前讲了</p><p>AlexNet的解析<a href="https://blog.csdn.net/Q52099999/article/details/133201259?spm=1001.2014.3001.5501">经典网络(一) AlexNet逐层解析 | 代码、可视化、参数查看！_Qodi的博客-CSDN博客</a></p><p>Vgg的解析</p><p><a href="https://blog.csdn.net/Q52099999/article/details/133209514?spm=1001.2014.3001.5501">经典网络解析（二）Vgg | 块的设计思想，代码，小卷积核_Qodi的博客-CSDN博客</a></p><p>今天讲GoogleNet在2014年图像大赛中大放异彩</p><p>不同大小的卷积核有着各自的优势和缺点，所以有时使用不同大小的卷积核组合是更有利的。 本节将介绍一个稍微简化的GoogLeNet版本：</p><h1 id="1-串联结构VGG存在的问题"><a href="#1-串联结构VGG存在的问题" class="headerlink" title="1. 串联结构VGG存在的问题"></a>1. 串联结构VGG存在的问题</h1><p>（1）后面的卷积层只能处理前层输出的特征图</p><p>​如果前层因为某些原因丢失了重要信息，后层无法找回</p><p>（2）参数太多，如果训练数据集有限，很容易产生过拟合；网络越大、参数越多，计算复杂度越大，难以应用</p><p>（3）网络越深，容易出现梯度弥散问题（梯度越往后穿越容易消失），难以优化模型。</p><h1 id="2-GoogleNet结构解析"><a href="#2-GoogleNet结构解析" class="headerlink" title="2. GoogleNet结构解析"></a>2. GoogleNet结构解析</h1><h2 id="2-1-Inception块"><a href="#2-1-Inception块" class="headerlink" title="2.1 Inception块"></a>2.1 Inception块</h2><p>提出Inception结构，可以保留输入信号中更多的信息</p><p>Inception块由四条并行路径组成。 </p><p>（1）用1×1的卷积，只考虑压缩信息</p><p>（2）先用1×1的卷积（1×1卷积，以减少通道数，从而降低模型的复杂性，增加的1X1卷积后面也会跟着有非线性激励，这样同时也能够提升网络的表达能力），再用3×3的卷积，提取小感受野的信息，</p><p>（3）先用1×1的卷积（1×1卷积，以减少通道数，从而降低模型的复杂性，增加的1X1卷积后面也会跟着有非线性激励，这样同时也能够提升网络的表达能力。），再用5×5的卷积，提取大感受野的信息</p><p>（4）用3×3的最大化池化（进行非最大化抑制，相当于将原图的重要信息加强），再用1×1卷积（改变通道数）</p><p>这四条路径都使用合适的填充来使输入与输出的高和宽一致</p><p>最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。在Inception块中，通常调整的超参数是每层输出通道数。</p><p>最后把特征图的通道数连接在一起</p><p>比如（1）通道数64（2）通道数128（3）通道数32  ，（4）通道数32 那么则把通道数连接起来后就是256</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924162853256.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924162853256.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924162853256"></p><p>通过Incention块，实现层数更深，参数更少，计算效率也更高</p><p>真实中堆叠了九层Inception</p><h2 id="2-2-最后采用平均池化操作"><a href="#2-2-最后采用平均池化操作" class="headerlink" title="2.2 最后采用平均池化操作"></a>2.2 最后采用平均池化操作</h2><p>用平均池化代替了原来的向量展开全连接层</p><p>比如最后有1024个特征图，每个特征图求一个平均值，那么经过平均之后就只有1024个值</p><ol><li>降低尺寸：平均池化操作通过计算池化窗口中所有像素值的平均值来减小特征图的尺寸。这有助于降低计算负担，减少网络中的参数数量，提高模型的计算效率。</li><li>平移不变性：与最大池化类似，采用平均池化，丢掉了语义结构的空间位置信息，有助于提升卷积层提取到特征的平移不变性，即使目标在特征图中稍微移动了一点，平均池化仍然会产生相似的输出，从而有助于提高模型的鲁棒性。</li><li>减少过拟合：通过减小特征图的尺寸，平均池化可以降低模型的容量，有助于减少过拟合的风险，从而提高模型的泛化能力。</li></ol><h2 id="2-3-辅助分类器"><a href="#2-3-辅助分类器" class="headerlink" title="2.3 辅助分类器"></a>2.3 辅助分类器</h2><p><strong>（1）位置</strong>：GoogleNet在网络的中间层添加了多个辅助分类器，通常分布在不同的Inception模块之间。这些分类器将中间层的特征图作为输入，并生成分类预测。</p><p><strong>（2）多尺度特征：</strong>由于这些辅助分类器位于不同深度的层次中，它们能够捕获不同层次和尺度的特征信息。这有助于提高网络对不同大小目标的识别能力。</p><p><strong>（3）损失函数：</strong>每个辅助分类器都有自己的损失函数，通常使用交叉熵损失（cross-entropy loss）来衡量其分类预测与真实标签之间的差异。这些辅助损失函数与主要分类器的损失函数一起用于计算模型的总损失。</p><p><strong>（4）梯度传播：</strong>辅助分类器的存在有助于梯度从网络底部向上传播。在反向传播时，梯度可以从多个位置进入网络，避免了梯度在深层网络中逐渐减小，从而缓解了梯度消失问题。这提高了网络的训练稳定性，使得更深的网络能够更容易地收敛。</p><p><strong>（5）正则化效应：</strong>辅助分类器可以看作一种正则化机制，因为它们要求不同层次的特征都具有一定的分类能力。这有助于减少过拟合风险，并提高网络的泛化能力。</p><p>需要注意的是，辅助分类器在训练期间使用，而在推理（inference）时通常被丢弃。它们的主要目的是在训练期间帮助网络学习更好的特征表示和提高训练速度。这个想法启发了后续深度学习模型的设计，例如ResNet等，它们也采用了类似的思想来改善梯度传播和训练稳定性。</p><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h1><p>参照《动手学深度学习》，省略了一些为稳定训练而添加的特殊特性，书中说现在有了更好的训练方法，这些特性不是必要的。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924170129356.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924170129356.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924170129356"></p><h2 id="3-1-实现Inception块"><a href="#3-1-实现Inception块" class="headerlink" title="3.1 实现Inception块"></a>3.1 实现Inception块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Module):</span><br><span class="line">    <span class="comment"># c1--c4是每条路径的输出通道数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Inception, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 线路1，单1x1卷积层</span></span><br><span class="line">        self.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 线路2，1x1卷积层后接3x3卷积层</span></span><br><span class="line">        self.p2_1 = nn.Conv2d(in_channels, c2[<span class="number">0</span>], kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.p2_2 = nn.Conv2d(c2[<span class="number">0</span>], c2[<span class="number">1</span>], kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 线路3，1x1卷积层后接5x5卷积层</span></span><br><span class="line">        self.p3_1 = nn.Conv2d(in_channels, c3[<span class="number">0</span>], kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.p3_2 = nn.Conv2d(c3[<span class="number">0</span>], c3[<span class="number">1</span>], kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span></span><br><span class="line">        self.p4_1 = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        p1 = F.relu(self.p1_1(x))</span><br><span class="line">        p2 = F.relu(self.p2_2(F.relu(self.p2_1(x))))</span><br><span class="line">        p3 = F.relu(self.p3_2(F.relu(self.p3_1(x))))</span><br><span class="line">        p4 = F.relu(self.p4_2(self.p4_1(x)))</span><br><span class="line">        <span class="comment"># 在通道维度上连结输出</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="3-2-各个块依次实现"><a href="#3-2-各个块依次实现" class="headerlink" title="3.2 各个块依次实现"></a>3.2 各个块依次实现</h2><p><strong>b1</strong></p><p>第一个模块的第一个卷积层使用64个通道、7×7卷积层（尺寸减半）然后经过池化层</p><p>第二个卷积层依然使用64个通道、3×3卷积层，然后经过池化层</p><p>第三个卷积层通道数升为192、3×3卷积层，然后经过池化层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b1=nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>,<span class="number">64</span>,kernel_size=<span class="number">7</span>,stride=<span class="number">2</span>,padding=<span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,kernel_size=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>,<span class="number">192</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>b2</strong></p><p>b2模块串联两个完整的Inception块。</p><p> 第一个Inception块中，第二个和第三个路径首先将输入通道的数量分别减少到96&#x2F;192&#x3D;1&#x2F;2和16&#x2F;192&#x3D;1&#x2F;12，然后连接第二个卷积层。最终Inception的输出通道数为64+128+32+32&#x3D;256，</p><p> 第二个Inception块中，第二条和第三条路径首先将输入通道的数量分别减少到128&#x2F;256&#x3D;1&#x2F;2和32&#x2F;256&#x3D;1&#x2F;8。然后连接第二个卷积层。最终Inception的输出通道数为128+192+96+64&#x3D;480，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b2=nn.Sequential(</span><br><span class="line">    Inception(<span class="number">192</span>,<span class="number">64</span>,(<span class="number">96</span>,<span class="number">128</span>),(<span class="number">16</span>,<span class="number">32</span>),<span class="number">32</span>),</span><br><span class="line">    Inception(<span class="number">256</span>,<span class="number">128</span>,(<span class="number">128</span>,<span class="number">192</span>),(<span class="number">32</span>,<span class="number">96</span>),<span class="number">64</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>b3</strong></p><p>b3它串联了5个Inception块，其输出通道数分别是192+208+48+64&#x3D;512、160+224+64+64&#x3D;512、128+256+64+64&#x3D;512、112+288+64+64&#x3D;528和256+320+128+128&#x3D;832。</p><p>思路和前面一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b3=nn.Sequential(</span><br><span class="line">    Inception(<span class="number">480</span>,<span class="number">192</span>,(<span class="number">96</span>,<span class="number">208</span>),(<span class="number">16</span>,<span class="number">48</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>,<span class="number">160</span>,(<span class="number">112</span>,<span class="number">224</span>),(<span class="number">24</span>,<span class="number">64</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>,<span class="number">128</span>,(<span class="number">128</span>,<span class="number">256</span>),(<span class="number">24</span>,<span class="number">64</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>,<span class="number">112</span>,(<span class="number">144</span>,<span class="number">288</span>),(<span class="number">32</span>,<span class="number">64</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">528</span>,<span class="number">256</span>,(<span class="number">160</span>,<span class="number">320</span>),(<span class="number">32</span>,<span class="number">128</span>),<span class="number">128</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>b4</strong></p><p>包含输出通道数为256+320+128+128&#x3D;832和384+384+128+128&#x3D;1024的两个Inception块。 其中每条路径通道数的分配思路和前面一致，只是在具体数值上有所不同。</p><p> 需要注意的是，第五模块的后面紧跟输出层，使用全局平均汇聚层，将每个通道的高和宽变成1。 最后我们将输出变成二维数组，再接上一个输出个数为标签类别数的全连接层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b4=nn.Sequential(</span><br><span class="line">    Inception(<span class="number">832</span>,<span class="number">256</span>,(<span class="number">160</span>,<span class="number">320</span>),(<span class="number">32</span>,<span class="number">128</span>),<span class="number">128</span>),</span><br><span class="line">    Inception(<span class="number">832</span>,<span class="number">384</span>,(<span class="number">192</span>,<span class="number">384</span>),(<span class="number">48</span>,<span class="number">128</span>),<span class="number">128</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">    nn.Flatten()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>最后把他们拼起来</strong> 接一个全连接层做分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net=nn.Sequential(</span><br><span class="line"></span><br><span class="line">  b1,b2,b3,b4,</span><br><span class="line"></span><br><span class="line">  nn.Linear(<span class="number">1024</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>完整代码</p><p>我们模拟一个[1,3,227,227]图像的输入，看每一层的输出形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels,c1,c2,c3,c4, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        self.p1_1=nn.Conv2d(in_channels,c1,kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.p2_1=nn.Conv2d(in_channels,c2[<span class="number">0</span>],kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.p2_2=nn.Conv2d(c2[<span class="number">0</span>],c2[<span class="number">1</span>],kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.p3_1=nn.Conv2d(in_channels,c3[<span class="number">0</span>],kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.p3_2=nn.Conv2d(c3[<span class="number">0</span>],c3[<span class="number">1</span>],kernel_size=<span class="number">5</span>,padding=<span class="number">2</span>)</span><br><span class="line">        self.p4_1=nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.p4_2=nn.Conv2d(in_channels,c4,kernel_size=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        p1=F.relu(self.p1_1(x))</span><br><span class="line">        p2=F.relu(self.p2_2(F.relu(self.p2_1(x))))</span><br><span class="line">        p3=F.relu(self.p3_2(F.relu(self.p3_1(x))))</span><br><span class="line">        p4=F.relu(self.p4_2(self.p4_1(x)))</span><br><span class="line">        <span class="keyword">return</span> torch.cat((p1,p2,p3,p4),dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1=nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">3</span>,<span class="number">64</span>,kernel_size=<span class="number">7</span>,stride=<span class="number">2</span>,padding=<span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,kernel_size=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>,<span class="number">192</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">x=torch.randn(<span class="number">1</span>,<span class="number">3</span>,<span class="number">227</span>,<span class="number">227</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> b1:</span><br><span class="line">    x=layer(x)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&quot;output shape:&quot;</span>,x.shape)</span><br><span class="line">b2=nn.Sequential(</span><br><span class="line">    Inception(<span class="number">192</span>,<span class="number">64</span>,(<span class="number">96</span>,<span class="number">128</span>),(<span class="number">16</span>,<span class="number">32</span>),<span class="number">32</span>),</span><br><span class="line">    Inception(<span class="number">256</span>,<span class="number">128</span>,(<span class="number">128</span>,<span class="number">192</span>),(<span class="number">32</span>,<span class="number">96</span>),<span class="number">64</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> b2:</span><br><span class="line">    x=layer(x)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&quot;output shape:&quot;</span>,x.shape)</span><br><span class="line"></span><br><span class="line">b3=nn.Sequential(</span><br><span class="line">    Inception(<span class="number">480</span>,<span class="number">192</span>,(<span class="number">96</span>,<span class="number">208</span>),(<span class="number">16</span>,<span class="number">48</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>,<span class="number">160</span>,(<span class="number">112</span>,<span class="number">224</span>),(<span class="number">24</span>,<span class="number">64</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>,<span class="number">128</span>,(<span class="number">128</span>,<span class="number">256</span>),(<span class="number">24</span>,<span class="number">64</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>,<span class="number">112</span>,(<span class="number">144</span>,<span class="number">288</span>),(<span class="number">32</span>,<span class="number">64</span>),<span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">528</span>,<span class="number">256</span>,(<span class="number">160</span>,<span class="number">320</span>),(<span class="number">32</span>,<span class="number">128</span>),<span class="number">128</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> b3:</span><br><span class="line">    x=layer(x)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&quot;output shape:&quot;</span>,x.shape)</span><br><span class="line"></span><br><span class="line">b4=nn.Sequential(</span><br><span class="line">    Inception(<span class="number">832</span>,<span class="number">256</span>,(<span class="number">160</span>,<span class="number">320</span>),(<span class="number">32</span>,<span class="number">128</span>),<span class="number">128</span>),</span><br><span class="line">    Inception(<span class="number">832</span>,<span class="number">384</span>,(<span class="number">192</span>,<span class="number">384</span>),(<span class="number">48</span>,<span class="number">128</span>),<span class="number">128</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">1024</span>,<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> b4:</span><br><span class="line">    x=layer(x)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&quot;output shape:&quot;</span>,x.shape)</span><br><span class="line"></span><br><span class="line">net=nn.Sequential(</span><br><span class="line">    b1,b2,b3,b4</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Conv2d output shape: torch.Size([1, 64, 114, 114])</span><br><span class="line">ReLU output shape: torch.Size([1, 64, 114, 114])</span><br><span class="line">MaxPool2d output shape: torch.Size([1, 64, 57, 57])</span><br><span class="line">Conv2d output shape: torch.Size([1, 64, 57, 57])</span><br><span class="line">ReLU output shape: torch.Size([1, 64, 57, 57])</span><br><span class="line">Conv2d output shape: torch.Size([1, 192, 57, 57])</span><br><span class="line">ReLU output shape: torch.Size([1, 192, 57, 57])</span><br><span class="line">MaxPool2d output shape: torch.Size([1, 192, 29, 29])</span><br><span class="line">Inception output shape: torch.Size([1, 256, 29, 29])</span><br><span class="line">Inception output shape: torch.Size([1, 480, 29, 29])</span><br><span class="line">MaxPool2d output shape: torch.Size([1, 480, 15, 15])</span><br><span class="line">Inception output shape: torch.Size([1, 512, 15, 15])</span><br><span class="line">Inception output shape: torch.Size([1, 512, 15, 15])</span><br><span class="line">Inception output shape: torch.Size([1, 512, 15, 15])</span><br><span class="line">Inception output shape: torch.Size([1, 528, 15, 15])</span><br><span class="line">Inception output shape: torch.Size([1, 832, 15, 15])</span><br><span class="line">MaxPool2d output shape: torch.Size([1, 832, 8, 8])</span><br><span class="line">Inception output shape: torch.Size([1, 832, 8, 8])</span><br><span class="line">Inception output shape: torch.Size([1, 1024, 8, 8])</span><br><span class="line">AdaptiveAvgPool2d output shape: torch.Size([1, 1024, 1, 1])</span><br><span class="line">Flatten output shape: torch.Size([1, 1024])</span><br><span class="line">Linear output shape: torch.Size([1, 10])</span><br></pre></td></tr></table></figure><h1 id="4-贡献总结"><a href="#4-贡献总结" class="headerlink" title="4  贡献总结"></a>4  <strong>贡献总结</strong></h1><p>GoogleNet只有500万参数，比AlexNet少12倍</p><ol><li><strong>Inception模块引入</strong>：GoogleNet引入了Inception模块，这是一种高效的卷积神经网络模块，通过使用多尺寸的卷积核并行处理输入数据，大大提高了网络的感受野（receptive field），并且在不增加太多参数的情况下增加了网络的深度和宽度。这使得网络能够更好地捕捉不同尺度和层次的特征。</li><li><strong>网络深度和性能平衡</strong>：GoogleNet在当时的深度学习研究中展示了在适当的条件下，增加网络的深度并不一定会导致过拟合。相反，它展示了如何通过适当的网络设计，使更深的网络具有更好的性能。</li><li><strong>辅助分类器</strong>：GoogleNet引入了辅助分类器，这些分类器位于网络的中间层，有助于解决梯度消失问题，并提高网络的训练稳定性。这个想法启发了后续深度学习模型的设计，例如ResNet。</li><li><strong>计算效率</strong>：GoogleNet通过使用1x1卷积核和平均池化等技术，降低了网络的计算复杂度，使得更深更宽的网络仍然能够高效地训练和推理。这对于实际应用中的计算资源管理至关重要。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（九）生成网络GAN</title>
      <link href="/2023/12/19/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7.1%20%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9CGAN/"/>
      <url>/2023/12/19/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7.1%20%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9CGAN/</url>
      
        <content type="html"><![CDATA[<p>之前我们讲了VAE</p><p>但原有问题</p><p>​希望从训练样本分布中采样新数据，但这个分布不仅维度高，而且还很复杂，难以实现</p><p>​所以期望对一个简单的分布采样，比如正态分布，然后学习一种映射将其变换到训练样本分布，这种映射的方式可以通过神经网络来学习</p><p>参考之前总结的</p><p>可以通过一个比喻来理解生成对抗网络（GAN）的工作原理：</p><p>想象一场假币制造比赛，有两名参赛者：造币专家（生成器）和验币专家（判别器）。</p><ol><li>造币专家（生成器）：这位专家的任务是制造伪造的硬币，希望这些伪造硬币尽量像真正的硬币一样。生成器开始时可能只是随机制造硬币，但通过不断练习，它学会了如何制造更加逼真的伪造硬币。</li><li>验币专家（判别器）：验币专家的任务是检查硬币，确定它们是真正的还是伪造的。判别器开始时可能很容易识别伪造硬币，但随着时间的推移，它变得越来越擅长区分真伪。</li></ol><p>比赛的规则如下：</p><ul><li>造币专家（生成器）制造了一些伪造硬币，并将它们交给验币专家（判别器）。</li><li>验币专家（判别器）尝试检查硬币，然后告诉造币专家哪些硬币是伪造的，哪些是真的。</li><li>造币专家（生成器）收到反馈后，尝试改进伪造硬币的制造方法，以使它们更难被验币专家（判别器）识别。</li><li>验币专家（判别器）也在不断提高自己的检测技能，以侦测越来越逼真的伪造硬币。</li></ul><p>这个过程不断重复，生成器和判别器互相竞争，生成器努力制造更逼真的伪造硬币，判别器努力提高自己的验币技能。随着时间的推移，生成器越来越擅长制造逼真的伪造硬币，而判别器越来越擅长检测它们。最终，生成器制造的伪造硬币变得如此逼真，以至于判别器几乎无法区分真伪。</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（五）VGG全解析</title>
      <link href="/2023/12/19/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.1%20VGG/"/>
      <url>/2023/12/19/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.1%20VGG/</url>
      
        <content type="html"><![CDATA[<p>之前我们讲到AlexNet，以及改进ZFnet</p><p>但是这些网络结构都没有提供一个通用的模版来指导后续的设计，都是在一层一层设计</p><p>今天的VGG则开创性的利用“块”的设计方式，便于加深网络</p><p>可以发现神经网络的研究</p><p>从一开始的单个神经元  到    神经网络层    再到    神经网络块</p><p>逐渐变得更加抽象</p><ol><li><p><strong>单个神经元（Neuron）</strong>： 单个神经元是神经网络的基本组成单位。</p><p>这个阶段类似于一个单一的“工人”，它可以执行基本的信息处理任务，但受限于其简单性和有限的表达能力。</p></li><li><p><strong>神经网络层（Layer）</strong>： 将多个神经元组织成层次结构。每一层包含多个神经元，这些神经元共同协作来处理输入数据并生成输出。不同层之间的连接权重可以调整，从而使网络能够学习更复杂的特征和关系。</p><p>这个阶段类似于将多个工人组织成一个团队，每个成员具有特定的任务，团队协同工作以解决更复杂的问题。</p></li><li><p><strong>神经网络块（Block）</strong>： 进一步的发展将多个层组合成神经网络块或模块。每个块可以包含多个层，这些层在功能上有一定的相关性，通常用于处理特定类型的任务或数据。块之间的信息流动通常是顺序的，这有助于网络更好地理解复杂的数据结构。</p><p>这个阶段类似于将多个团队组织成一个更大的组织，每个团队专注于不同的方面，组织内部的信息流动更加复杂和高效。</p></li></ol><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h1><p>VGG（Visual Geometry Group）网络是深度学习领域的一个重要里程碑，具有重要的意义，主要体现在以下几个方面：</p><ol><li><strong>深度网络的重要性和可训练性验证</strong>： VGG网络通过多个卷积层和池化层的堆叠展示了深度神经网络的重要性。它证明了更深层次的网络结构可以更好地学习到图像的抽象特征。此前，一些人认为增加网络深度会导致梯度消失或梯度爆炸问题，因此深度网络很难训练。VGG的成功表明，在适当的设置下，深度神经网络是可训练的，而且能够提取丰富的特征。</li><li><strong>卷积神经网络架构的标准化</strong>： VGG网络引入了一种简单而统一的卷积神经网络架构，采用了相同大小的卷积核和池化窗口，以及相同数量的卷积层。这种标准化使得构建和训练卷积神经网络变得更加简单和可控。</li><li><strong>在图像分类竞赛中的优异表现</strong>： VGG网络在2014年的ImageNet图像分类挑战赛中取得了卓越的成绩。它的表现证明了深度卷积神经网络在计算机视觉任务中的巨大潜力。这个突破激发了更多研究人员对深度学习的兴趣，促进了深度学习技术的广泛应用。</li></ol><h1 id="2-VGG解析"><a href="#2-VGG解析" class="headerlink" title="2.VGG解析"></a>2.VGG解析</h1><h2 id="2-1-结构"><a href="#2-1-结构" class="headerlink" title="2.1 结构"></a>2.1 结构</h2><p>VGG-16 13个卷积层与3个全连接层</p><p>VGG-19 16个卷积层与3个全连接层  </p><p>一般用Vgg-16</p><p>Vgg比起AlexNet做出的<strong>重要的改变是</strong> </p><p>​使用尺寸更小的<strong>3×3卷积核串联来替代大卷积核11×11,7×7这样的大尺寸卷积核</strong>，引入块设计思想，在相同的感受野的情况下，多个串联非线性能力更强，描述能力更强</p><h3 id="2-1-1-输入处理"><a href="#2-1-1-输入处理" class="headerlink" title="2.1.1 输入处理"></a>2.1.1 输入处理</h3><p>做平均去均值</p><p>​AlexNet，ZFnet 统计所有的图像的像素均值，得到一个均值向量，每一个图像输入之前先减去这个均值向量，比如之前输入是227×227×3那么他的均值向量就是227×227×3</p><p>​而Vgg不以图像为均值，而是统计某一个像素点的所有的R,G,B的均值。均值向量就是3×1 每一个图像输入之前先减去这个均值向量</p><h3 id="2-1-2-块的设计"><a href="#2-1-2-块的设计" class="headerlink" title="2.1.2 块的设计"></a>2.1.2 块的设计</h3><p>如图左边是AlexNet，右边是Vgg16的结构</p><p>橘黄色的部分<strong>是Vgg块</strong>，可以看到他们大体结构相同，唯一的差别是卷积层数，和通道数，所以可以抽象一个函数实现</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923115842229.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923115842229.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom: 33%;" /><p><strong>问题 1：为什么前面通道数较少，后面通道数较多？</strong></p><p>我们所有的物体都可以看做是由一些基础的纹理基元表示的</p><p>他们是有限的，而组成的可能性很多</p><p>前层安排较少的通道数，因为前层是学习一些纹理表示基元，所以不需要那么多通道（Vgg是64），而后参是更具体的高层语义，有着更多的可能，所以安排更多的通道（Vgg是512）</p><p><strong>问题2：Vgg前四段里，为什么每经过一次池化操作，卷积核个数就增加一倍</strong></p><p>1 池化操作减少特征图尺寸，降低显存占用</p><p>2 增加卷积核个数有助于学习更多的结构特征，但会增加显存占用</p><p>3 先减少特征图尺寸，再增加特征图个数，一减一增，维持开销，提升网络性能</p><p><strong>问题3 为什么卷积核增加到512</strong>个不再增加了</p><p>因为会让网络参数急剧增大</p><h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vgg_block</span>(<span class="params">num_convs,in_channels,out_channels</span>):</span><br><span class="line">    layers=[]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">        layers.append(nn.Conv2d(kernel_size=<span class="number">3</span>,in_channels=in_channels,out_channels=out_channels,padding=<span class="number">1</span>))</span><br><span class="line">        layers.append(nn.ReLU())</span><br><span class="line">        in_channels=out_channels</span><br><span class="line">    layers.append(nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*layers)  <span class="comment">#这里*是解包，可以理解为把列表拆成一个一个的</span></span><br><span class="line"></span><br><span class="line">conv_arch=((<span class="number">2</span>,<span class="number">64</span>),(<span class="number">2</span>,<span class="number">128</span>),(<span class="number">3</span>,<span class="number">256</span>),(<span class="number">3</span>,<span class="number">512</span>),(<span class="number">3</span>,<span class="number">512</span>))  <span class="comment">#第一个是vgg块内有几个卷积层，第二个代表vgg块输出卷积层通道数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vgg</span>(<span class="params">conv_arch</span>):</span><br><span class="line">    cnn_blocks=[]</span><br><span class="line">    in_channels=<span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> num_convs,out_channels <span class="keyword">in</span> conv_arch:</span><br><span class="line">        cnn_blocks.append(vgg_block(num_convs,in_channels,out_channels))</span><br><span class="line">        in_channels=out_channels</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        *cnn_blocks,</span><br><span class="line">        nn.Flatten(),</span><br><span class="line">        nn.Linear(out_channels*<span class="number">7</span>*<span class="number">7</span>,<span class="number">4096</span>),nn.ReLU(),nn.Dropout(<span class="number">0.5</span>), </span><br><span class="line">        nn.Linear(<span class="number">4096</span>,<span class="number">4096</span>),nn.ReLU(),nn.Dropout(<span class="number">0.5</span>), </span><br><span class="line">        nn.Linear(<span class="number">4096</span>,<span class="number">1000</span>),nn.ReLU(),nn.Dropout(<span class="number">0.5</span>), </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">x=torch.randn(<span class="number">1</span>,<span class="number">3</span>,<span class="number">227</span>,<span class="number">227</span>) </span><br><span class="line">net=vgg(conv_arch)</span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> net:</span><br><span class="line">    x=block(x)</span><br><span class="line">    <span class="built_in">print</span>(block.__class__.__name__,<span class="string">&quot;输出形状：&quot;</span>,x.shape)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sequential 输出形状： torch.Size([1, 64, 113, 113])</span><br><span class="line">Sequential 输出形状： torch.Size([1, 128, 56, 56])</span><br><span class="line">Sequential 输出形状： torch.Size([1, 256, 28, 28])</span><br><span class="line">Sequential 输出形状： torch.Size([1, 512, 14, 14])</span><br><span class="line">Sequential 输出形状： torch.Size([1, 512, 7, 7])</span><br><span class="line">Flatten 输出形状： torch.Size([1, 25088])</span><br><span class="line">Linear 输出形状： torch.Size([1, 4096])</span><br><span class="line">ReLU 输出形状： torch.Size([1, 4096])</span><br><span class="line">Dropout 输出形状： torch.Size([1, 4096])</span><br><span class="line">Linear 输出形状： torch.Size([1, 4096])</span><br><span class="line">ReLU 输出形状： torch.Size([1, 4096])</span><br><span class="line">Dropout 输出形状： torch.Size([1, 4096])</span><br><span class="line">Linear 输出形状： torch.Size([1, 1000])</span><br><span class="line">ReLU 输出形状： torch.Size([1, 1000])</span><br><span class="line">Dropout 输出形状： torch.Size([1, 1000])</span><br></pre></td></tr></table></figure><h1 id="3-贡献总结"><a href="#3-贡献总结" class="headerlink" title="3.贡献总结"></a>3.贡献总结</h1><p>1 使用尺寸更小的3×3卷积核串联来替代大卷积核11×11,7×7这样的大尺寸卷积核，引入块设计思想，在相同的感受野的情况下，多个串联非线性能力更强，描述能力更强</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923151713651.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923151713651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230923151713651"></p><p>2 深度更深，非线性更强，网络的参数也更少（小尺寸的卷积核参数量要比大尺寸的参数量小）</p><p>3 去掉了AlexNet里的局部响应归一化层</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（八）生成网络VAE</title>
      <link href="/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7%20%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9CVAE/"/>
      <url>/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7%20%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9CVAE/</url>
      
        <content type="html"><![CDATA[<p>之前我们的很多网络都是有监督的</p><p>生成网络都是无监督的（本质就是密度估计），我们首先来讲有监督学习，无监督学习</p><h1 id="1-有监督与无监督"><a href="#1-有监督与无监督" class="headerlink" title="1 有监督与无监督"></a>1 有监督与无监督</h1><p><strong>有监督学习</strong></p><p>目标学习X到Y的映射，有正确答案标注  </p><p>示例  </p><p>分类回归</p><p>目标检测</p><p>语义分割</p><p><strong>无监督学习</strong>   </p><p>没有标记，找出隐含在数据里的模型或者结构  </p><p>示例 </p><p>聚类</p><p>降维  1 线性降维：PCA主成分分析   2 非线性降维：特征学习（自编码）</p><p>密度估计</p><p>当谈论有监督学习和无监督学习时，你可以将其比喻为烹饪和探险两种不同的方式：</p><p><strong>有监督学习</strong>就像是在烹饪中的烹饪食谱。你有一本详细的烹饪书（类似于带标签的训练数据），书中告诉你每一步应该怎么做，包括每个食材的量和准备方式（就像标签指导模型的输出）。你只需按照指示的步骤执行，最终会得到一道美味的菜肴。在这个过程中，你不需要创造新的食谱，只需遵循已有的指导。</p><p><strong>无监督学习</strong>则类似于一场探险，你被带到一个未知的地方，没有地图或导航，只有一堆不同的植物和动物（类似于未标记的数据）。你的任务是探索并发现任何可能的规律、相似性或特征，以确定它们之间的关系（就像从未标记的数据中发现模式）。在这个过程中，你可能会发现新的物种或新的地理特征，而无需事先知道要找什么。</p><h1 id="2-生成模型"><a href="#2-生成模型" class="headerlink" title="2 生成模型"></a>2 生成模型</h1><p>学习训练模型的分布，然后产生自己的模型！给定训练集，产生与训练集同分布的新样本！</p><p>生成模型应用</p><p>​图像合成 图像属性编辑  图片风格转移等</p><h2 id="2-1-重要思路"><a href="#2-1-重要思路" class="headerlink" title="2.1 重要思路"></a>2.1 重要思路</h2><p><strong>显示密度估计</strong></p><p>​显示定义并求解分布</p><p>​又可以分为</p><p>1 可以求解的</p><p>PixelRNN </p><p>2 不可以求解的</p><p>VAE</p><p><strong>隐示密度估计</strong>：学习一个模型，而无需定义它</p><p>GAN</p><h1 id="3-VAE"><a href="#3-VAE" class="headerlink" title="3 VAE"></a>3 VAE</h1><p>变分自编码器</p><p>我们先介绍自编码器和解码器</p><p><strong>编码器</strong></p><p>编码器的作用一般都是提取压缩特征，降低维度，保证数据里最核心最重要的信息被保留</p><p><strong>解码器</strong></p><p>但是只有编码器是不行的，我不知道编码器提取的特征怎么样，所以我们需要加上解码器，解码器就可以利用提取到的特征进行重构原始数据，这样的话重构出来的图像越像原图说明编码器越好</p><h2 id="编码器怎么单独用？"><a href="#编码器怎么单独用？" class="headerlink" title="编码器怎么单独用？"></a>编码器怎么单独用？</h2><p>做分类或其他有监督任务</p><p>对于输入数据，利用编码器提取特征，然后输出预测标签，根据真实标签进行计算损失函数，微调网络，这种情况可以适用于少量的数据标记情况</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230929120109503.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230929120109503.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230929120109503"></p><p>但是这样的效果往往不如在有监督网络微调的方式</p><h2 id="解码器怎么单独用？"><a href="#解码器怎么单独用？" class="headerlink" title="解码器怎么单独用？"></a>解码器怎么单独用？</h2><p>做图像生成</p><p>比如给一个随机的二维编码，我就可以生成一个真实图像样本</p><p>讲完了编码器解码器，我们想问为什么要用变分？变分是什么</p><h2 id="为什么要用变分"><a href="#为什么要用变分" class="headerlink" title="为什么要用变分"></a>为什么要用变分</h2><p>上面的我的自编码器的思想太死板了！他只能学到一些离散的编码，学到自己见过的内容，无法组合创新</p><p>VAE引入了概率分布的概念，它假设数据的潜在表示（潜在空间）是连续的，并使用概率分布来建模这个潜在空间。具体来说，VAE假设潜在表示服从一个潜在空间的高斯分布，其中编码器学习生成<strong>均值和方差</strong>，而解码器从这个分布中采样。这种建模方式允许VAE学习数据的连续、平滑的表示，而不仅仅是对数据的离散编码。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930083808335.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930083808335.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930083808335"></p><p>自编码器输入图像后，编码器会生成一个编码</p><p>而如图所示变分自编码器是输入图片，编码器输出一个分布（均值和方差）</p><p>生成图像的时候，从这个分布中采样送入解码器即可</p><p>两个损失函数</p><p>一个最小化重构误差</p><p>一个尽可能使得潜在表示的概率分布接近标准正态分布使得0均值1方差（损失函数一方面可以避免退化成自编码器，另一方面保证采样简单）</p><h2 id="变分自编码器推导"><a href="#变分自编码器推导" class="headerlink" title="变分自编码器推导"></a>变分自编码器推导</h2><h3 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h3><p>用很多个简单高斯逼近最后的比较复杂的分布</p><p>优化解码器参数使得似然函数L最大， 但是实际中由于有隐变量的存在而无法积分，所以我们只能通过近似的方式</p><p>具体推导可以查看如下这篇博客</p><p><a href="https://zhuanlan.zhihu.com/p/249296925">从零推导：变分自编码器（VAE） - 知乎 (zhihu.com)</a></p><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4 代码实现"></a>4 代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VAE</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim, hidden_dim, latent_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(VAE, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(input_dim, hidden_dim)</span><br><span class="line">        self.fc21 = nn.Linear(hidden_dim, latent_dim)</span><br><span class="line">        self.fc22 = nn.Linear(hidden_dim, latent_dim)</span><br><span class="line">        self.fc3 = nn.Linear(latent_dim, hidden_dim)</span><br><span class="line">        self.fc4 = nn.Linear(hidden_dim, input_dim)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, x</span>):</span><br><span class="line">        h1 = F.relu(self.fc1(x))</span><br><span class="line">        mu = self.fc21(h1)</span><br><span class="line">        log_var = self.fc22(h1)</span><br><span class="line">        <span class="keyword">return</span> mu, log_var</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reparameterize</span>(<span class="params">self, mu, log_var</span>):</span><br><span class="line">        std = torch.exp(<span class="number">0.5</span>*log_var)</span><br><span class="line">        eps = torch.randn_like(std)</span><br><span class="line">        z = mu + eps*std</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self, z</span>):</span><br><span class="line">        h3 = F.relu(self.fc3(z))</span><br><span class="line">        recon_x = torch.sigmoid(self.fc4(h3))</span><br><span class="line">        <span class="keyword">return</span> recon_x</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        mu, log_var = self.encode(x)</span><br><span class="line">        z = self.reparameterize(mu, log_var)</span><br><span class="line">        recon_x = self.decode(z)</span><br><span class="line">        <span class="keyword">return</span> recon_x, mu, log_var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数，通常使用重建损失和KL散度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss_function</span>(<span class="params">recon_x, x, mu, log_var</span>):</span><br><span class="line">    BCE = F.binary_cross_entropy(recon_x, x, reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">    KLD = -<span class="number">0.5</span> * torch.<span class="built_in">sum</span>(<span class="number">1</span> + log_var - mu.<span class="built_in">pow</span>(<span class="number">2</span>) - log_var.exp())</span><br><span class="line">    <span class="keyword">return</span> BCE + KLD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建VAE实例并进行训练</span></span><br><span class="line">input_dim = <span class="number">784</span>  <span class="comment"># 用于示例的MNIST数据集</span></span><br><span class="line">hidden_dim = <span class="number">400</span></span><br><span class="line">latent_dim = <span class="number">20</span></span><br><span class="line">vae = VAE(input_dim, hidden_dim, latent_dim)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(vae.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练VAE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_vae</span>(<span class="params">train_loader, vae, optimizer, num_epochs</span>):</span><br><span class="line">    vae.train()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            data = data.view(-<span class="number">1</span>, input_dim)</span><br><span class="line">            recon_batch, mu, log_var = vae(data)</span><br><span class="line">            loss = loss_function(recon_batch, data, mu, log_var)</span><br><span class="line">            </span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>], Batch [<span class="subst">&#123;batch_idx+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader)&#125;</span>], Loss: <span class="subst">&#123;loss.item()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用MNIST数据集示例</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor()])</span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=transform, download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=<span class="number">128</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">train_vae(train_loader, vae, optimizer, num_epochs)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典CV任务（一）语义分割实例分割</title>
      <link href="/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.0%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"/>
      <url>/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.0%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-语义分割"><a href="#1-语义分割" class="headerlink" title="1 语义分割"></a>1 语义分割</h1><p>语义分割（Semantic Segmentation）</p><p><strong>语义分割</strong>的目标是将图像中的每个像素分割成不同的类别，但不区分同一类别中的不同实例。它只关心图像中的不同物体类别，而不关心它们是否属于不同的实例。</p><p><strong>语义分割</strong>通常用于识别图像中的不同物体类别，如图像分割、图像分析、医学图像分析等。</p><h2 id="1-1-思路1-滑动窗口"><a href="#1-1-思路1-滑动窗口" class="headerlink" title="1.1 思路1 滑动窗口"></a>1.1 思路1 滑动窗口</h2><p>语义分割思路：滑动窗口</p><p>首先，选择一个固定大小的窗口（通常是正方形或矩形），然后将该窗口从图像的左上角开始滑动，按照一定的步长（通常是像素数）在图像上进行滑动。这将生成一系列重叠的图像窗口。</p><p>对于每个滑动窗口，从窗口中提取特征。然后对这个窗口做分类</p><p>这种方法可以工作，但效率太低。重叠区域特征反复被计算</p><p>因而更多采用思路2</p><h2 id="1-2-思路2-全卷积网络"><a href="#1-2-思路2-全卷积网络" class="headerlink" title="1.2 思路2 全卷积网络"></a>1.2 思路2 全卷积网络</h2><p>采用全卷积网络  也就是用全部都是多层的全卷积</p><p>这是怎么思考的呢？之前我们是给一整张图像做分类，而我们现在是给图像的每一个像素做分类</p><p>如果我最后一个卷积层输出的是(H×W×C)</p><p>H，W是图像的宽高，C是可能的分类的类别数</p><p>这样的话每一个像素点被映射为C维的向量，而我的标答也做成(H×W×C) 这样的话输出和标记之间就可以做损失函数运算了</p><p>但是有又有一个问题，就是我们中间 一直保持着原图的像素尺寸，中间计算量会很大，所以我们考虑通过先减小像素尺寸（下采样），再增大像素尺寸（上采样）</p><p>把特征图变小其实不难 如池化层，卷积层增大步长等</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230926094556328.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230926094556328.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230926094556328"></p><p>把特征图变大我们其实并没有学过</p><p>这里运用很多的是   <strong>转置卷积操作</strong></p><p>特别方式</p><p>可学习的上采样：转置卷积</p><p>首先我们需要知道卷积操作是可以写作矩阵相乘的，只有这样我们才能实现并行运算，极大的加快运算速度</p><p>具体我们看这样一个二维的例子</p><p><strong>输入图像 I</strong>（3x3的矩阵）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I = | 1  2  3 |</span><br><span class="line">    | 4  5  6 |</span><br><span class="line">    | 7  8  9 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>卷积核 K</strong>1（2x2的矩阵）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">K1 = | a0  b0 |</span><br><span class="line">    | c0  d0 |</span><br></pre></td></tr></table></figure><p>我们希望将输入图像 I 与卷积核 K 进行卷积操作。</p><p>如果按照我们之前的卷积从左上角开始滑动，那么每一次运算必须等上一次运算完</p><p>而实际上我们可以把图像I写成这样一个矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I_expanded = | 1  2  4  5 |</span><br><span class="line">            | 2  3  5  6 |</span><br><span class="line">            | 4  5  7  8 |</span><br><span class="line">            | 5  6  8  9 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是什么意思呢？就是把卷积核要运算的第一个方格（左上角的四个元素）里的元素展平放在第一行</p><p>要运算的第二个方格（右上角的四个元素）里的元素展平放在第二行</p><p>要运算的第三个方格（左下角的四个元素）里的元素展平放在第三行</p><p>要运算的第四个方格（右下角的四个元素）里的元素展平放在第四行</p><p><strong>展开卷积核 K1</strong>：将2x2的卷积核 K 按照大小展开成一个列向量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K1_expanded = [a0 </span><br><span class="line">  b0  </span><br><span class="line">  c0 </span><br><span class="line">              d0]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的话，将展开后的输入图像矩阵 I_expanded 与展开后的卷积核 K_expanded 进行矩阵相乘，得到卷积结果。</p><p>卷积前大小 （3×3）展开矩阵是(4×4)</p><p>卷积后大小(2×2)展开后是(4×1)</p><p>那么我们怎么把卷积后的这个大小恢复成原来的大小呢</p><p>得到的结果（4×1）乘 卷积核转置(1×4) &#x3D;（4×4）</p><p>这也是为什么称之为转置卷积</p><p>现在更多还使用一类叫做Unet</p><p>是在刚刚讲的基础上的改进</p><p>就是通过连接两个相同尺寸的把前面层的信息拼接到后面的层的信息，使得不同分辨率的语义（无论是高层还是底层）的信息都可以捕捉</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230926095005822.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230926095005822.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230926095005822"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><p>我们这次直接采用预训练模型来搭建这个网络</p><p>（1）对于下采样部分采用ReNet的预训练模型</p><p>Resnet会把输入图片的宽高缩为原来的1&#x2F;32，通道数变为512</p><p>假设输入图片宽高  320，480，所以中间输出的宽高变为10，15</p><p>（2）对于上采样部分采用转置卷积网络</p><p>首先通过1×1卷积层把通道数变为分类总数，例子中是20</p><p>然后再经过转置卷积改变特征图尺寸，要把它扩大32倍，那么步长就是s&#x3D;32</p><p>卷积核尺寸&#x3D;2s&#x3D;64</p><p>填充&#x3D;s&#x2F;2&#x3D;16</p><p>上面这一套卷积核参数设置就可以把它扩大32倍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#采用resnet做下采样</span></span><br><span class="line">pretrained_net=torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#resnet的最后两层全局平均池化层和线性层丢弃</span></span><br><span class="line">net=nn.Sequential(</span><br><span class="line">    *<span class="built_in">list</span>(pretrained_net.children())[:-<span class="number">2</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment">#模拟输入 图像宽高320，480，通道数3</span></span><br><span class="line">x=torch.rand(size=(<span class="number">1</span>,<span class="number">3</span>,<span class="number">320</span>,<span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#经过Renet的输出中间输出</span></span><br><span class="line"><span class="built_in">print</span>(net(x).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#采用转置卷积网络做上采样</span></span><br><span class="line">num_classes=<span class="number">20</span><span class="comment">#要分类的类别是20</span></span><br><span class="line"><span class="comment">#模拟输入 图像宽高320，480，通道数3</span></span><br><span class="line">x=torch.rand(size=(<span class="number">1</span>,<span class="number">3</span>,<span class="number">320</span>,<span class="number">480</span>))</span><br><span class="line"><span class="comment">#先改变通道数</span></span><br><span class="line">net.add_module(<span class="string">&quot;final_conv&quot;</span>,nn.Conv2d(<span class="number">512</span>,num_classes,kernel_size=<span class="number">1</span>))</span><br><span class="line"><span class="comment">#转置卷积层</span></span><br><span class="line">net.add_module(<span class="string">&quot;transpose_conv&quot;</span>,nn.ConvTranspose2d(num_classes,num_classes,kernel_size=<span class="number">64</span>,padding=<span class="number">16</span>,stride=<span class="number">32</span>))</span><br><span class="line"><span class="comment">#最终输出</span></span><br><span class="line"><span class="built_in">print</span>(net(x).shape)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([1, 512, 10, 15])</span><br><span class="line">torch.Size([1, 20, 320, 480])</span><br></pre></td></tr></table></figure><p>可验证，中间输出的宽高变为10，15</p><p>最后输出恢复原始图像宽高，通道数变为分类总数20</p><h1 id="3-实例分割"><a href="#3-实例分割" class="headerlink" title="3 实例分割"></a>3 实例分割</h1><p>实例分割（Instance Segmentation）</p><p><strong>实例分割</strong>的主要目标是将图像中的每个对象实例分割成不同的区域，并为每个区域分配一个唯一的标识符。这意味着它不仅可以识别不同类别的对象，还可以区分同一类别中的不同实例，如图像中的多个人或多辆车。</p><p><strong>实例分割</strong>通常在需要区分不同对象实例的场景中使用，如自动驾驶中的行人检测和跟踪、人物姿势估计等。</p><p>以下是一些重要的深度学习方法和架构，用于实例分割任务：</p><ol><li><strong>Mask R-CNN</strong>：Mask R-CNN是一种基于Faster R-CNN的扩展，它通过添加额外的分割分支来实现实例分割。除了目标的边界框，Mask R-CNN还生成了每个对象实例的像素级掩码，从而提供了准确的分割结果。这使得 Mask R-CNN 成为实例分割任务的流行选择。</li><li><strong>Panoptic Segmentation</strong>：Panoptic分割是一种将语义分割和实例分割结合起来的任务，旨在将图像中的每个像素分为具有语义标签的物体类别或属于特定对象实例。Panoptic分割方法通常使用深度学习模型来实现，如Panoptic FPN等。</li><li><strong>DETR（Data Efficient Transformer）</strong>：DETR 是一种新兴的实例分割方法，它基于Transformer架构，将实例分割任务转化为一个端到端的目标检测和分割问题。DETR 通过注意力机制来对目标的位置和像素级别的分割进行联合建模，取得了卓越的性能。</li><li><strong>PointRend</strong>：PointRend 是一种用于提高实例分割性能的方法，特别关注于处理分割边缘区域的细节。它通过逐像素的自适应池化操作来改进掩码的质量，从而提高分割精度。</li><li><strong>SOLO（Segmenting Objects by Locations）</strong>：SOLO 是一种基于实例的分割方法，它使用了网格级别的特征图和目标特定的位置信息，以实现物体实例的分割。SOLO 将实例分割任务与目标检测分割任务相结合。</li><li><strong>Embedding-based方法</strong>：一些实例分割方法采用嵌入向量来表示每个像素，然后使用聚类技术或后处理步骤来将像素分配到不同的实例。这些方法在性能和效率方面取得了良好的平衡。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络可解释性 | 可视化</title>
      <link href="/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/6%20%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/6%20%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>可视化可以帮助我们更好的理解卷积网络每一层学到了什么，或者说每一个卷积核究竟学到了什么，他是怎么理解图像的</p><p>这种的话当我们神经网络结果不太好时，我们可以分析不好的原因</p><p>图片来源于李飞飞老师的内容</p><p>梯度上升方法做可视化</p><h1 id="1-第一层"><a href="#1-第一层" class="headerlink" title="1. 第一层"></a>1. 第一层</h1><p>直接可视化</p><p>因为第一层的卷积核通道是3，可以和RGB对应，所以可以直接可视化</p><p>发现学到的是一些纹理表示，而我们知道复杂的物体都是可以由简单的纹理组成</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928141848842.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928141848842.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230928141848842"></p><h1 id="2-最后一层"><a href="#2-最后一层" class="headerlink" title="2. 最后一层"></a>2. 最后一层</h1><p>降维法</p><p>倒数第二层全连接层会输出4096维度的特征</p><p>我们通过降维法把他缩小到2维度（x,y）</p><p>可以把库中的所有图片进行降维操作，这样一张图片会得到一个x,y的坐标</p><p>然后把这张图片放到坐标系里</p><p>会发现相近的会在一起</p><h1 id="3-中间层"><a href="#3-中间层" class="headerlink" title="3 中间层"></a>3 中间层</h1><p>可视化卷积层就很难看到了</p><h2 id="3-2-内部响应分析法"><a href="#3-2-内部响应分析法" class="headerlink" title="3.2 内部响应分析法"></a>3.2 内部响应分析法</h2><p>输入一张图片，对于某一层的某一个卷积核,看卷积核的输出大小，越大越亮（响应值较大）</p><h2 id="3-3-原图外部分析方法"><a href="#3-3-原图外部分析方法" class="headerlink" title="3.3  原图外部分析方法"></a>3.3  原图外部分析方法</h2><p>输入一张图片，对于某一层的某一个卷积核，看卷积核对哪些区域的响应值比较大，然后再把对应区域在原图抠出来</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928142631281.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928142631281.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230928142631281"></p><p>可以看到每一行是一个感兴趣区域</p><p>比如第二行这个卷积只对人脸感兴趣，</p><p>到后面我们会发现神经网络学习到的是更高层的更有语义信息的内容</p><h2 id="3-4-遮挡分析法"><a href="#3-4-遮挡分析法" class="headerlink" title="3.4  遮挡分析法"></a>3.4  遮挡分析法</h2><p>输入一张图片，对于分类关键的内容进行遮挡，看看卷积网络的分类置信度有没有下降，下降说明网络学到了关键内容</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928143055059.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928143055059.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230928143055059"></p><p>遮住一些区域，看最后的概率输出</p><p>记录一些规则的</p><h2 id="3-5-梯度传递"><a href="#3-5-梯度传递" class="headerlink" title="3.5 梯度传递"></a>3.5 梯度传递</h2><p>反向梯度传递</p><p>以往都是利用输出对参数求导然后更新</p><p>但现在我们利用输出y对输入图片x的每一个像素进行求导</p><p>比如有300×400分辨率图片，通道数是3</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928143806710.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928143806710.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230928143806710"></p><p>我们对输入的每一个像素求导，每一个像素R,G,B各得到1个，总共3个，取3个里面的最大值，然后可视化导数</p><p>可以看到</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928143821895.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928143821895.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230928143821895"></p><p>从这里可以看出网络对哪些像素信息感兴趣，如果是对小狗周围感兴趣，说明网络学习是OK的，如果可视化后是其他区域，则不OK</p><h2 id="3-6-梯度上升"><a href="#3-6-梯度上升" class="headerlink" title="3.6 梯度上升"></a>3.6 梯度上升</h2><p>之前方法都得需要输入一张图片</p><p>直接对神经元反向传递，感觉输出</p><p>通常用于生成神经网络中某一层的激活或过滤器的可视化。这种技术的主要思想是通过最大化神经网络某一层的激活或过滤器的响应，来生成图像，从而可以观察该层在输入图像上响应最强的特征。以下是可视化的梯度上升算法的一般步骤：</p><p>（1）<strong>选择层和目标：</strong> 首先，选择要可视化的神经网络的层某一个神经元。比如最后一层1000维的第3维</p><p>原始图像为输入全零的图像 </p><p>（2）<strong>计算梯度：</strong> 接下来，计算这一个神经元相对于输入图像的梯度。把其他神经元的梯度置零，回传到原始图像加到像素全为零的图像上去</p><p>（3）反复进行（1）（2）步</p><p>就可以看到下图的情况</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928145058226.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230928145058226.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230928145058226" style="zoom:50%;" /><h1 id="4-其他应用"><a href="#4-其他应用" class="headerlink" title="4 其他应用"></a>4 其他应用</h1><h2 id="4-1-风格转移"><a href="#4-1-风格转移" class="headerlink" title="4.1 风格转移"></a>4.1 风格转移</h2><p>风格转移网络很好玩</p><p>我们可以输入一张风格图</p><p>输入一张原图，内容图</p><p>输入一张噪声图</p><p>（1）初始化网络参数并且固定网络参数</p><p>（2）输入噪声图片和风格图片，在每一层计算两者提取特征的损失，计算损失对于输入噪声图片的梯度，然后更新原噪声图片</p><p>（3）输入噪声图片和原图，在某一层计算两者提取特征的损失，计算损失对于输入噪声图片的梯度，然后更新原噪声图片</p><p>（4）不断迭代（3）（4）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230929102408360.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230929102408360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230929102408360"></p><p>但是后来人们发现这个需要迭代很多次，耗时较长</p><p>就把这个噪声图直接取消了，直接传入原图到一个网络中，使得这个网络的输出尽量的既符合风格图特征，又符合内容图特征</p><p>下次给一张图只需要过一个网络就可以了</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230929103426662.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230929103426662.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230929103426662"></p><h1 id="5-可视化工具"><a href="#5-可视化工具" class="headerlink" title="5 可视化工具"></a>5 可视化工具</h1><p><strong>keras-vis</strong></p><p>Keras-vis 是一个基于 Keras 深度学习库的可视化工具，里面实现了上面我们讲到的一些可视化方法原理的工具</p><h2 id="5-1-sailency"><a href="#5-1-sailency" class="headerlink" title="5.1 sailency"></a>5.1 sailency</h2><p><strong>显著性图salinecy：</strong> 原理就是上面讲到的3.5</p><p>利用 visualize_saliency函数实现</p><p>以下是使用 Keras-vis 中的 saliency 技术的一般步骤：</p><ol><li><strong>选择模型和目标类别：</strong> 首先，选择要解释的深度学习模型以及要研究的目标类别（或目标神经元）。</li><li><strong>计算梯度：</strong> 使用反向传播（backpropagation）算法计算输入图像相对于目标类别的梯度。这些梯度告诉了你哪些像素对于使模型对目标类别产生更高的概率或激活更重要。</li><li><strong>生成显著性图：</strong> 使用计算得到的梯度，可以生成显著性图。通常，你可以使用梯度的绝对值或其他变换来得到显著性图像。显著性图中的像素值表示了相对于目标类别的重要性，较高的值通常对应于模型所关注的区域。</li><li><strong>可视化显著性图：</strong> 最后，你可以将生成的显著性图可视化，以理解模型对输入图像的哪些部分关注较多。这通常涉及到将显著性图与原始输入图像叠加，以突出显示关键区域。</li></ol><p>以下是一个简单的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> keras.applications <span class="keyword">import</span> VGG16</span><br><span class="line"><span class="keyword">from</span> vis.visualization <span class="keyword">import</span> visualize_saliency</span><br><span class="line"><span class="keyword">from</span> vis.utils <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> activations</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练的VGG16模型</span></span><br><span class="line">model = VGG16(weights=<span class="string">&#x27;imagenet&#x27;</span>, include_top=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个输入图像</span></span><br><span class="line">input_image_path = <span class="string">&#x27;path_to_your_input_image.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载输入图像并进行预处理</span></span><br><span class="line">img = utils.load_img(input_image_path, target_size=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">img = utils.preprocess_input(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取模型的预测类别</span></span><br><span class="line">pred_class = np.argmax(model.predict(img))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Saliency技术生成显著性图</span></span><br><span class="line">saliency_map = visualize_saliency(model, layer_idx=-<span class="number">1</span>, filter_indices=pred_class, seed_input=img, backprop_modifier=<span class="string">&#x27;guided&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化显著性图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(utils.load_img(input_image_path, target_size=(<span class="number">224</span>, <span class="number">224</span>)))</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(saliency_map, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Saliency Map&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-2-最大化激活"><a href="#5-2-最大化激活" class="headerlink" title="5.2 最大化激活"></a>5.2 最大化激活</h2><p><strong>最大化激活activation：</strong> 原理就是上面讲到的3.6</p><p>利用 visualize_activation函数实现</p><p>方法</p><ol><li><strong>加载模型：</strong> 首先，你需要加载一个已经训练好的深度学习模型，可以是图像分类、目标检测或其他类型的模型。</li><li><strong>选择层：</strong> 通过 <code>layer_name</code> 参数选择你想要可视化的神经网络层。通常，这是卷积神经网络（CNN）中的某一卷积层或其他感兴趣的层。</li><li><strong>生成激活图像：</strong> 使用 <code>visualize_activation</code> 函数生成激活图像。你可以通过 <code>filter_indices</code> 参数来选择特定过滤器（卷积核）的激活，也可以通过 <code>input_range</code> 参数来指定输入图像的像素范围。</li><li><strong>显示结果：</strong> 最后，你可以使用 <code>utils.draw_text</code> 函数将生成的激活图像可视化，通常是与输入图像一起显示，以更好地理解模型在输入数据上的激活模式。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vis.visualization <span class="keyword">import</span> visualize_activation</span><br><span class="line"><span class="keyword">from</span> vis.utils <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载已经训练好的模型</span></span><br><span class="line">model = load_model(<span class="string">&#x27;your_model.h5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个层进行可视化</span></span><br><span class="line">layer_name = <span class="string">&#x27;conv2d_1&#x27;</span>  <span class="comment"># 选择你想可视化的层</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用可视化函数生成激活图像</span></span><br><span class="line">activations = visualize_activation(model, layer_name, filter_indices=<span class="number">0</span>, input_range=(<span class="number">0.</span>, <span class="number">1.</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示可视化结果</span></span><br><span class="line">utils.draw_text(activations, <span class="string">&#x27;Filter 0&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们常常说神经网络是黑盒</p><p>为什么说黑盒？不是说不知道神经网络学习到了什么，而是不知道他为什么会学到这些信息</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（四）AlexNet全解析</title>
      <link href="/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4%20AlexNet/"/>
      <url>/2023/12/18/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4%20AlexNet/</url>
      
        <content type="html"><![CDATA[<p>之前我们讲到全连接神经网络对一些已经表示成向量的比较简洁的形式是有效的</p><p><a href="https://blog.csdn.net/Q52099999/article/details/133099715?spm=1001.2014.3001.5501">深度学习修炼（二）全连接神经网络 | Softmax，交叉熵损失函数 优化AdaGrad，RMSProp等 对抗过拟合 全攻略_Qodi的博客-CSDN博客</a></p><p>对于复杂图像等的输入是有很大的局限的，而通过卷积网络就可以实现更好的效果</p><p>这篇文章中讲了关于卷积操作及其一些进阶的操作</p><p><a href="https://blog.csdn.net/Q52099999/article/details/133151017?spm=1001.2014.3001.5501">深度学习修炼（三）卷积操作 | 边界填充、跨步、多输入输出通道、汇聚池化_Qodi的博客-CSDN博客</a></p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>具体来说，在一个卷积网络中，往往有如下的多个层，他们的功能总结如下</p><p><strong>（1）卷积层 Conv</strong></p><p>进行特征提取</p><p><strong>（2）激活层</strong> </p><p>非线性操作，往往跟在卷积层后</p><p>堆叠卷积层和激活层，不断提取更深的语义特征</p><p><strong>（3）池化层 Pooling</strong></p><p>对每一个特征响应图独立进行，降低特征响应图每个特征响应图组中每个特征相应图的宽度和高度，减少后续卷积层的参数数量，降低计算资源耗费，进而控制过拟合</p><p>一般而言，每pool一层，尺寸下降一倍</p><p>同时缩小大小，可以增大卷积核的视野，看到更大的图</p><p><strong>（4）全连接层</strong> </p><p>对卷积网络的特征进行变化分类</p><h1 id="2-AlexNet的重要性"><a href="#2-AlexNet的重要性" class="headerlink" title="2 AlexNet的重要性"></a>2 AlexNet的重要性</h1><p>今天我们开始看经典的卷积神经网络，感受这些网络的设计思想，进一步感受不同层的作用</p><p>首先从AlexNet开始 </p><p>AlexNet是一种深度卷积神经网络，由Alex Krizhevsky、Ilya Sutskever和Geoffrey Hinton于2012年开发，被广泛认为是深度学习在计算机视觉领域取得突破性进展的重要里程碑之一。在ImageNet大规模数据集上表现取得历史最好成绩。</p><p>证明了这种深度网络的可行性！</p><h1 id="3-AlexNet解析"><a href="#3-AlexNet解析" class="headerlink" title="3 AlexNet解析"></a>3 AlexNet解析</h1><h2 id="3-1-结构"><a href="#3-1-结构" class="headerlink" title="3.1 结构"></a>3.1 结构</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923100358653.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923100358653.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230923100358653"></p><p>层数统计</p><p>计算层数时仅统计卷积层与全连接层</p><p>​因为池化层和归一化层都是对它们前面卷积层输出的特征图进行后处理，不单独算一层</p><p>所以这个网络可以是8层   ：  卷积5层+全连接3层</p><h3 id="3-1-1-CONV1"><a href="#3-1-1-CONV1" class="headerlink" title="3.1.1 CONV1"></a>3.1.1 CONV1</h3><p>卷积核11×11   （用96个卷积核）深度通道变为96  步幅4   填充0</p><p><strong>问题1</strong> 输入227×227×3 大小的图像，<strong>输出特征图个数及尺寸为多少？</strong></p><p>（227-11）&#x2F;4+1&#x3D;55</p><p>所以是 尺寸 55×55</p><p>个数  96</p><p><strong>问题2 卷积核的深度是多少？</strong></p><p>卷积核的深度是由输入通道数决定的，所以是3</p><p><strong>问题3 这层要学的参数有多少</strong></p><p>（11×11×3+1）× 96 &#x3D;35K</p><p>+1是偏置，每个卷积都有一个偏置参数</p><p>给一张图像，输出了96个特征图，也就意味着96种响应信息</p><p>之后特征图经过ReLu激活操作，大于0保留，小于0 为0</p><h3 id="3-1-2-Max-Pool1"><a href="#3-1-2-Max-Pool1" class="headerlink" title="3.1.2 Max Pool1"></a>3.1.2 Max Pool1</h3><p>池化层移动窗口大小3×3       步长为2</p><p><strong>问题1</strong> 从卷积层1输入该层后，<strong>输出特征图个数及尺寸为多少？</strong></p><p>尺寸  (55-3)&#x2F;2+1&#x3D;27</p><p>通道数不变   96</p><p><strong>问题2</strong> 该层可学习参数为多少？</p><p>学习参数为0，没有参数可以学习！因为他就是按固定的方法采样一下就好</p><h3 id="3-1-3-NORM1"><a href="#3-1-3-NORM1" class="headerlink" title="3.1.3 NORM1"></a>3.1.3 NORM1</h3><p>局部响应归一化层，较大的值增大，较小的值减小</p><p>后来证明这个在深层网络中帮助微小，在后面的网络中基本都去掉了 ，后面就不讲啦</p><h3 id="3-1-4-CONV2"><a href="#3-1-4-CONV2" class="headerlink" title="3.1.4 CONV2"></a>3.1.4 CONV2</h3><p>卷积核5×5   （用256个卷积核）深度通道变为256  步长1   填充2</p><p><strong>问题1</strong> 输入27×27×96 大小的特征图组，<strong>输出特征图个数及尺寸为多少？</strong></p><p>（27-5+2×2）&#x2F;1+1&#x3D;27</p><p>所以是 尺寸 27×27</p><p>个数  256</p><p>增加了卷积核的个数，实际增加了卷积核的描述能力</p><p><strong>问题2 卷积核的深度是多少？</strong></p><p>卷积核的深度是由前面输入通道数决定的，所以96</p><p><strong>问题3 这层要学的参数有多少</strong></p><p>（5×5×96+1）× 256 &#x3D;615K</p><p>给一张图像，输出了96个特征图，也就意味着96种响应信息</p><p>之后特征图经过ReLu激活操作，大于0保留，小于0 为0</p><h3 id="3-1-5-Max-Pool2"><a href="#3-1-5-Max-Pool2" class="headerlink" title="3.1.5 Max Pool2"></a>3.1.5 Max Pool2</h3><p>池化层移动窗口大小3×3       步长为2  和第一个池化层一样</p><p><strong>问题1</strong> 从卷积层2输入该层后，<strong>输出特征图个数及尺寸为多少？</strong></p><p>尺寸  (27-3)&#x2F;2+1&#x3D;13</p><p>个数（通道数）不变   256</p><h3 id="3-1-6-CONV3-CONV4"><a href="#3-1-6-CONV3-CONV4" class="headerlink" title="3.1.6 CONV3 CONV4"></a>3.1.6 CONV3 CONV4</h3><p>这两层都是  卷积核3×3   （用384个卷积核）深度通道变为384  步长1   填充1</p><p><strong>问题1</strong> 从前面输入该层后，<strong>输出特征图个数及尺寸为多少？</strong></p><p>两层的尺寸维持不变</p><p>(13-3+2×1)+1&#x3D;13</p><p>个数（通道数）维持不变</p><p>384</p><h3 id="3-1-7-CONV5"><a href="#3-1-7-CONV5" class="headerlink" title="3.1.7 CONV5"></a>3.1.7 CONV5</h3><p>这层又把卷积核个数降下来了  卷积核3×3   （用256个卷积核）深度通道变为256  步长1   填充1</p><p><strong>问题1</strong> 从前面输入该层后，<strong>输出特征图个数及尺寸为多少？</strong></p><p>两层的尺寸维持不变</p><p>(13-3+2×1)+1&#x3D;13</p><p>个数（通道数）降到256</p><p>256</p><h3 id="3-1-8-Max-Pool3"><a href="#3-1-8-Max-Pool3" class="headerlink" title="3.1.8 Max Pool3"></a>3.1.8 Max Pool3</h3><p>再经过池化层 </p><p>池化层移动窗口大小3×3       步长为2  和前两个一样</p><p><strong>问题1</strong> 从前面输入该层后，<strong>输出特征图个数及尺寸为多少？</strong></p><p>尺寸  </p><p>(13-3)&#x2F;2+1&#x3D;5</p><p>通道数  256</p><p>得到最终特征响应图组</p><p>6×6×256</p><h3 id="3-1-9-FC1-FC2-FC3"><a href="#3-1-9-FC1-FC2-FC3" class="headerlink" title="3.1.9 FC1  FC2  FC3"></a>3.1.9 FC1  FC2  FC3</h3><p>特征响应图是一个矩阵，但是我们全连接神经网络需要输入一个向量</p><p>那好说，我们把矩阵展平成一个长向量    代码中就通过flatten操作实现</p><p>向量维度 6×6×256&#x3D;9216</p><p>经过FC1 映射为  4096</p><p>经过FC2 映射为   4096</p><p>再经过FC3  映射为分类的类别数 如果分类类别是10类就是10，如果是1000，就是1000</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923100411311.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923100411311.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230923100411311"></p><h2 id="3-2-AlexNet使用到的技巧"><a href="#3-2-AlexNet使用到的技巧" class="headerlink" title="3.2 AlexNet使用到的技巧"></a>3.2 AlexNet使用到的技巧</h2><p>1 Dropout防止过拟合</p><p>2 使用加入动量的小批量梯度下降算法加速了训练过程的收敛</p><p>3 采用样本增强，增加训练样本，防止过拟合</p><p>4 验证集损失不下降的时候，手动降低10倍学习率</p><p>5 集成多个模型，进一步提高概率</p><p>​单独训练多个模型，每个模型给一个预测，最后把所有预测平均</p><h2 id="3-3-可视化"><a href="#3-3-可视化" class="headerlink" title="3.3 可视化"></a>3.3 可视化</h2><p>AlexNet卷积层在做什么？</p><p>学习一些特征</p><p>比如第一层可视化</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/dnywo57lh3.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/dnywo57lh3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>最后一层可视化</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/g8n4r44d5j.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/g8n4r44d5j.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>可以发现卷积层学到一些纹理表示，因为很多物体都是通过纹理学习到的</p><h2 id="3-4-代码实现模拟"><a href="#3-4-代码实现模拟" class="headerlink" title="3.4 代码实现模拟"></a>3.4 代码实现模拟</h2><h3 id="3-4-1-查看每一层输入输出"><a href="#3-4-1-查看每一层输入输出" class="headerlink" title="3.4.1 查看每一层输入输出"></a>3.4.1 查看每一层输入输出</h3><p>建立网络，模拟图片输入网络，输出每一层的图片的形状变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net=nn.Sequential(</span><br><span class="line">    nn.Conv2d(kernel_size=<span class="number">11</span>,in_channels=<span class="number">3</span>,out_channels=<span class="number">96</span>,stride=<span class="number">4</span>,padding=<span class="number">0</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(kernel_size=<span class="number">5</span>,in_channels=<span class="number">96</span>,out_channels=<span class="number">256</span>,stride=<span class="number">1</span>,padding=<span class="number">2</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(kernel_size=<span class="number">3</span>,in_channels=<span class="number">256</span>,out_channels=<span class="number">384</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(kernel_size=<span class="number">3</span>,in_channels=<span class="number">384</span>,out_channels=<span class="number">384</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(kernel_size=<span class="number">3</span>,in_channels=<span class="number">384</span>,out_channels=<span class="number">256</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">9216</span>,<span class="number">4096</span>),</span><br><span class="line">    nn.Linear(<span class="number">4096</span>,<span class="number">4096</span>),</span><br><span class="line">    nn.Linear(<span class="number">4096</span>,<span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">x=torch.randn(<span class="number">1</span>,<span class="number">3</span>,<span class="number">227</span>,<span class="number">227</span>)<span class="comment">#模拟一张图片 通道数3 宽 高227</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    x=layer(x)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&quot;输出形状: \t&quot;</span>,x.shape)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Conv2d 输出形状:         torch.Size([1, 96, 55, 55])</span><br><span class="line">ReLU 输出形状:   torch.Size([1, 96, 55, 55])</span><br><span class="line">MaxPool2d 输出形状:      torch.Size([1, 96, 27, 27])</span><br><span class="line">Conv2d 输出形状:         torch.Size([1, 256, 27, 27])</span><br><span class="line">ReLU 输出形状:   torch.Size([1, 256, 27, 27])</span><br><span class="line">MaxPool2d 输出形状:      torch.Size([1, 256, 13, 13])</span><br><span class="line">Conv2d 输出形状:         torch.Size([1, 384, 13, 13])</span><br><span class="line">ReLU 输出形状:   torch.Size([1, 384, 13, 13])</span><br><span class="line">Conv2d 输出形状:         torch.Size([1, 384, 13, 13])</span><br><span class="line">ReLU 输出形状:   torch.Size([1, 384, 13, 13])</span><br><span class="line">Conv2d 输出形状:         torch.Size([1, 256, 13, 13])</span><br><span class="line">ReLU 输出形状:   torch.Size([1, 256, 13, 13])</span><br><span class="line">MaxPool2d 输出形状:      torch.Size([1, 256, 6, 6])</span><br><span class="line">Flatten 输出形状:        torch.Size([1, 9216])</span><br><span class="line">Linear 输出形状:         torch.Size([1, 4096])</span><br><span class="line">Linear 输出形状:         torch.Size([1, 4096])</span><br><span class="line">Linear 输出形状:         torch.Size([1, 1000])</span><br></pre></td></tr></table></figure><h3 id="3-4-2-查看每一层参数的形状，参数量"><a href="#3-4-2-查看每一层参数的形状，参数量" class="headerlink" title="3.4.2 查看每一层参数的形状，参数量"></a>3.4.2 查看每一层参数的形状，参数量</h3><p>参数只有卷积层和全连接层有，所以在提取参数之前需要进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看参数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>(net.children()))):</span><br><span class="line">    <span class="built_in">print</span>(net[i])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net[i],nn.Conv2d) <span class="keyword">or</span> <span class="built_in">isinstance</span>(net[i],nn.Linear):</span><br><span class="line">        weight=net[i].weight.data.shape</span><br><span class="line">        bias=net[i].bias.data.shape</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t 该层权重参数形状&quot;</span>,weight)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t 该层偏置参数形状&quot;</span>,bias)</span><br><span class="line">        num=weight.numel()+bias.numel()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t 该层参数量  &quot;</span>,num)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Conv2d(3, 96, kernel_size=(11, 11), stride=(4, 4))</span><br><span class="line">         该层权重参数形状 torch.Size([96, 3, 11, 11])</span><br><span class="line">         该层偏置参数形状 torch.Size([96])</span><br><span class="line">         该层参数量   34944</span><br><span class="line">ReLU()</span><br><span class="line">MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">Conv2d(96, 256, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))</span><br><span class="line">         该层权重参数形状 torch.Size([256, 96, 5, 5])</span><br><span class="line">         该层偏置参数形状 torch.Size([256])</span><br><span class="line">         该层参数量   614656</span><br><span class="line">ReLU()</span><br><span class="line">MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">Conv2d(256, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">         该层权重参数形状 torch.Size([384, 256, 3, 3])</span><br><span class="line">         该层偏置参数形状 torch.Size([384])</span><br><span class="line">         该层参数量   885120</span><br><span class="line">ReLU()</span><br><span class="line">Conv2d(384, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">         该层权重参数形状 torch.Size([384, 384, 3, 3])</span><br><span class="line">         该层偏置参数形状 torch.Size([384])</span><br><span class="line">         该层参数量   1327488</span><br><span class="line">ReLU()</span><br><span class="line">Conv2d(384, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">         该层权重参数形状 torch.Size([256, 384, 3, 3])</span><br><span class="line">         该层偏置参数形状 torch.Size([256])</span><br><span class="line">         该层参数量   884992</span><br><span class="line">ReLU()</span><br><span class="line">MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">Flatten(start_dim=1, end_dim=-1)</span><br><span class="line">Linear(in_features=9216, out_features=4096, bias=True)</span><br><span class="line">         该层权重参数形状 torch.Size([4096, 9216])</span><br><span class="line">         该层偏置参数形状 torch.Size([4096])</span><br><span class="line">         该层参数量   37752832</span><br><span class="line">Linear(in_features=4096, out_features=4096, bias=True)</span><br><span class="line">         该层权重参数形状 torch.Size([4096, 4096])</span><br><span class="line">         该层偏置参数形状 torch.Size([4096])</span><br><span class="line">         该层参数量   16781312</span><br><span class="line">Linear(in_features=4096, out_features=1000, bias=True)</span><br><span class="line">         该层权重参数形状 torch.Size([1000, 4096])</span><br><span class="line">         该层偏置参数形状 torch.Size([1000])</span><br><span class="line">         该层参数量   4097000</span><br></pre></td></tr></table></figure><h3 id="3-4-3-快捷计算总的参数量"><a href="#3-4-3-快捷计算总的参数量" class="headerlink" title="3.4.3 快捷计算总的参数量"></a>3.4.3 快捷计算总的参数量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num=0</span><br><span class="line">for parameter in net.parameters():</span><br><span class="line">    num=num+parameter.numel()</span><br><span class="line">print(&quot;参数量&quot;,num)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数量 62378344</span><br></pre></td></tr></table></figure><h1 id="4-AlexNet的主体贡献"><a href="#4-AlexNet的主体贡献" class="headerlink" title="4  AlexNet的主体贡献"></a>4  AlexNet的主体贡献</h1><p>网络结构</p><p>1 提出了一种卷积层加全连接层的卷积神经网络结构</p><p>训练部分</p><p>2 首次使用ReLu函数作为神经网络激活函数</p><p>3 首次提出Dropout正则化来控制过拟合</p><p>4 使用加入动量的小批量梯度下降算法加速了训练过程的收敛</p><p>数据处理</p><p>5 使用数据增强极大地抑制了训练过程的拟合</p><p>设备部分</p><p>6 利用了GPU的并行计算能力，加速了网络的训练与判断</p><h1 id="5-AlexNet的改进ZFnet"><a href="#5-AlexNet的改进ZFnet" class="headerlink" title="5 AlexNet的改进ZFnet"></a>5 AlexNet的改进ZFnet</h1><p>1 将第<strong>一个卷积层</strong>的卷积核<strong>大小改为了7×7</strong></p><p>卷积核越大，感受的信息越粗粒度，卷积核越小，感受的信息越细粒度</p><p>刚开始直接用粗粒度的大卷积核会导致丢失很多的细节信息，对后面分类任务有影响</p><p>2 将第<strong>二，三</strong>个卷积层的<strong>卷积步长设置为了2</strong></p><p>希望这种特征图的分辨率慢慢的降</p><p>避免信息损失太快</p><p>3 增加了第<strong>三，四个卷积层的卷积核个数</strong></p><p>作者发现第三四层已经开始有高层概念了</p><p>用更多个卷积核，可以学习到更多的组合特征</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（三）卷积 去噪 边缘提取</title>
      <link href="/2023/12/17/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3%20%E5%8D%B7%E7%A7%AF%20%E5%8E%BB%E5%99%AA%20%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/"/>
      <url>/2023/12/17/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3%20%E5%8D%B7%E7%A7%AF%20%E5%8E%BB%E5%99%AA%20%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>之前我们讲了 线性分类器 </p><p><a href="https://blog.csdn.net/Q52099999/article/details/129132479">深度学习修炼（一）线性分类器 | 权值理解、支撑向量机损失、梯度下降算法通俗理解_Qodi的博客-CSDN博客</a></p><p>又讲了基于线性分类器的全连接神经网络</p><p><a href="https://blog.csdn.net/Q52099999/article/details/133099715">深度学习修炼（二）全连接神经网络 | Softmax，交叉熵损失函数 优化AdaGrad，RMSProp等 对抗过拟合 全攻略_Qodi的博客-CSDN博客</a></p><p>但是 单纯的线性非线性操作有着比较大的局限性</p><p>​一方面这种全连接网络参数量巨大，另一方面对于位置信息表现比较差。而今天的卷积神经网络非常重要，可以捕捉输入数据中的位置信息，这使得它在处理具有明显空间结构的数据时如图片表现优异。</p><h1 id="1-卷积基本操作"><a href="#1-卷积基本操作" class="headerlink" title="1. 卷积基本操作"></a>1. 卷积基本操作</h1><p>卷积操作可以将输入数据映射为输出数据，同时保留输入数据的空间结构信息。</p><p>假设我们有一个3x3的图像像素矩阵，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">4 5 6 </span><br><span class="line">7 8 9 </span><br></pre></td></tr></table></figure><p>我们希望对这个图像进行卷积操作。为了实现这个操作，我们需要定义一个<strong>卷积核（也称为过滤器）</strong>来滑动在图像上，从而产生一个新的输出图像。</p><p><strong>卷积核</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 0</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p>卷积操作的基本思想是在输入图像上滑动卷积核，对每个位置进行卷积运算，并将结果存储到输出图像中。具体来说，每一次卷积操作的计算方式如下：</p><ol><li>将卷积核的每个元素与输入图像中对应的元素相乘</li><li>将所得到的乘积相加，得到卷积核在当前位置的输出值</li><li>将卷积核向右或向下移动一个位置，重复上述步骤，直到卷积核覆盖完整个输入图像。</li></ol><p>拿上面那个例子来说</p><ol><li>对于输出图像中的第一个位置，卷积核与输入图像的左上角区域进行卷积运算，计算方式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*1 + 0*2 + 0*4 + 1*5 = 6 </span><br></pre></td></tr></table></figure><p>因此输出图像中的第一个位置的值为6。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921143508425.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921143508425.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921143508425"></p><ol><li>对于输出图像中的第二个位置，卷积核向右移动一个位置，与输入图像的右上角区域进行卷积运算，计算方式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*2 + 0*3 + 0*5 + 1*6= 8</span><br></pre></td></tr></table></figure><p>因此输出图像中的第二个位置的值为6。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921143854365.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921143854365.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921143854365"></p><ol><li>对于输出图像中的第三个位置，卷积核向右移动一个位置，与输入图像的左下角区域进行卷积运算，计算方式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*4 + 0*5 + 0*7 + 1*8 = 12 </span><br></pre></td></tr></table></figure><p>因此输出图像中的第三个位置的值为12</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921144218740.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921144218740.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921144218740"></p><ol><li>对于输出图像中的第四个位置，卷积核向右移动一个位置，与输入图像的右下角区域进行卷积运算，计算方式如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*5 + 0*6 + 0*8 + 1*9 = 14 </span><br></pre></td></tr></table></figure><p>因此输出图像中的第四个位置的值为14。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921144314803.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921144314803.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921144314803"></p><p>上面举的例子中</p><p>卷积核大小 宽度和高度分别2,2</p><p>卷积核从左到右，从上到下遍历 将输入的图像(3<em>3)转换为*<em>特征图</em></em>(2*2)</p><p>这里得到的这个矩阵叫做特征图，可以理解为卷积层对于图像自动提取的特征，各种任务都是建立在特征之上的</p><p>对于给定的任意宽高的卷积核($高k_h 宽k_w $)，对给定宽高的图像（$高n_h 宽n_w$）进行卷积操作，<strong>输出的形状是可以确定的</strong>  卷积核大小</p><p><strong>即</strong></p><p>$(n_h-k_h+1)×(n_w-k_w+1)$</p><p>比如上面的例子中输出形状为</p><p>$(3-1+1)×(3-1+1) &#x3D;2×2 $</p><h1 id="2-现代卷积进阶武器操作"><a href="#2-现代卷积进阶武器操作" class="headerlink" title="2 现代卷积进阶武器操作"></a>2 现代卷积进阶武器操作</h1><p>当下的卷积 会有很多辅助武器，让卷积的效果变得更好</p><h2 id="2-1-边界-填充"><a href="#2-1-边界-填充" class="headerlink" title="2.1 边界 填充"></a>2.1 边界 填充</h2><p>我们知道经过卷积之后，输出形状有可能会变小</p><p>但有些时候我们希望输出特征图的形状维持不变，这时候就可以进行边界填充，填充后就可以维持不变</p><p>最常用的边界填充方法是零填充</p><p>对于给定的任意宽高的卷积核($高k_h 宽k_w $)，对给定宽高的图像（$高n_h 宽n_w$）进行卷积操作，<strong>左右上下各填充p</strong>  则输出形状为</p><p>$输出高&#x3D;(n_h-k_h+2p)+1 $</p><p>$输出宽&#x3D; (n_w-n_h+2p)+1$</p><p>比如特征图7*7</p><p>卷积核3*3</p><p>零填充 1</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921201333613.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921201333613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921201333613"></p><p>则代入输出形状代入公式</p><p>$输出高&#x3D;(n_h-k_h+2p)+1 输出宽&#x3D; (n_w-n_h+2p)+1$</p><p>(7-3+1+2×1) ×(7-3+1+2×1) &#x3D;7×7</p><p>这也是为什么很多卷积核设计都是奇数，唯有奇数才能保证填充后前后形状不变</p><p>总结填充作用：保持输入输出的形状一致</p><h2 id="2-2-跨步-步幅"><a href="#2-2-跨步-步幅" class="headerlink" title="2.2 跨步 步幅"></a>2.2 跨步 步幅</h2><p>但有些时候，我们需要降低输出特征图维度，可以指定的间隔进行卷积操作降低特征图维度，可以降低计算量。</p><p>另一方面，设置步幅可以控制特征提取的粒度。在卷积神经网络中，卷积核在输入图像上滑动时，会对输入图像的每个局部区域进行特征提取。而设置步幅可以控制卷积核在输入图像上移动的步长大小，从而控制特征提取的粒度。当步幅较小时，卷积核在输入图像上移动的步长较小，可以提取更为精细的特征信息；当步幅较大时，卷积核在输入图像上移动的步长较大，可以提取更为宏观的特征信息。</p><p>之前我们默认都是1步操作</p><p>对于给定的任意宽高的卷积核($高k_h 宽k_w $)，对给定宽高的图像（$高n_h 宽n_w$）进行卷积操作，左右上下各填充p   <strong>跨步S</strong></p><p>$输出高&#x3D;(n_h-k_h+2p)&#x2F;S+1 $</p><p>$输出宽&#x3D; (n_w-n_h+2p)&#x2F;S+1$</p><h2 id="2-3-多输入输出通道"><a href="#2-3-多输入输出通道" class="headerlink" title="2.3 多输入输出通道"></a>2.3 多输入输出通道</h2><p><strong>多输入通道</strong></p><p>在第一节的讲解中，我们默认我们的输入输出都是平面的， 只考虑了宽高的变化</p><p>但实际上，真实中往往有多层，专业术语叫做多个通道</p><p>比如图片输入往往是3通道的R，G，B  这时候我们就需要构造一个和输入相同通道的卷积核（这个例子中是3）</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921194744430.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921194744430.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921194744430" style="zoom:67%;" /><p>我们需要把 这样一个多通道的卷积核对齐到图像的某个位置，计算对应元素加权求和再累加，一般还会加一个偏移量</p><p>虽然卷积核是多通道的，但在一个位置加权求和累加之和只能得到一个值，意味着只能得到一层的输出</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921195640798.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921195640798.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921195640798"></p><p>图片借鉴北京邮电大学鲁鹏老师的课程</p><p><strong>多输出通道</strong></p><p>如果我们想要输出变成多个，那么我们就可以使用多个卷积核</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921195815942.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230921195815942.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230921195815942"></p><p>使用<strong>多少个卷积核，就会得到多少组中间特征图</strong></p><p>图示例子是6个</p><h2 id="2-4-汇聚-池化"><a href="#2-4-汇聚-池化" class="headerlink" title="2.4 汇聚 池化"></a>2.4 汇聚 池化</h2><p>除了跨步可以降低特征图大小，池化也可以</p><p>对每一个特征图独立进行，降低特征相应图组中的每个特征相应图的宽度和高度</p><p>（1）减少后续卷积层的参数数量，控制过拟合</p><p>（2）降低计算资源耗费</p><p>池化也有卷积操作一样的填充，步幅，多输入输出通道的概念，输出形状通道数计算公式和卷积都一样</p><p>比如，特征图大小4*4</p><blockquote><p>1   2   3   4<br>5   6   7   8<br>9 10 11 12<br>13 14 15 16</p></blockquote><p>现在我们对这个输入特征图进行2×2的最大池化操作，步幅为2，即每个子区域的大小为2×2，卷积核从左上角开始移动，每次向右移动2个像素，最后得到输出特征图大小为2×2，如下所示：</p><p>两个基本操作</p><p><strong>最大池化</strong></p><p>取每个子区域中最大的特征值作为该区域的输出</p><p>本例中 输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">14 16</span><br></pre></td></tr></table></figure><p><strong>平均池化</strong></p><p>取每个子区域中所有元素的平均值作为该区域的输出</p><p>本例中输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.5 5.5</span><br><span class="line">11.5 13.5</span><br></pre></td></tr></table></figure><h1 id="3-卷积层设计"><a href="#3-卷积层设计" class="headerlink" title="3. 卷积层设计"></a>3. 卷积层设计</h1><p>每一层的卷积核的</p><p>卷积核个数</p><p>卷积核尺寸大小</p><p>卷积核移动的步幅</p><p>是否进行填充</p><p>什么时候汇聚池化</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（二）全连接神经网络</title>
      <link href="/2023/12/16/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2%20%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/12/16/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2%20%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>之前我们学习了线性分类器</p><p><a href="https://blog.csdn.net/Q52099999/article/details/129132479">深度学习修炼（一）线性分类器 | 权值理解、支撑向量机损失、梯度下降算法通俗理解_Qodi的博客-CSDN博客</a></p><p>全连接神经网络（又叫多层感知机）和我们的线性分类器区别</p><p>（1）线性分类器就只有一个线性变化</p><p>而全连接神经网络利用激活函数（非线性操作），级联多个变换</p><p>（2）线性分类器只能解决线性可分问题，而我们的全连接神经网络由于加入了非线性操作激活函数，可以解决线性不可分问题。</p><p>激活函数是神经网络中非常重要的组成部分，与此类似，人脑中的神经元也具有类似的激活功能。深度学习受启发于脑科学，他们有如下相似点相似点：</p><ol><li>非线性：激活函数和人脑神经元都是非线性的。这是因为如果神经元都是线性的，则整个神经网络只能表示线性函数，无法应对复杂的非线性问题。</li><li>阈值：激活函数和人脑神经元都具有阈值。当输入值超过一定阈值时，神经元才会被激活，并产生输出。这种阈值的设置可以使神经网络更加适应不同类型的数据分布。</li></ol><p>下面我们来详细看一下内容</p><h1 id="1-多层感知机（全连接神经网络）"><a href="#1-多层感知机（全连接神经网络）" class="headerlink" title="1 多层感知机（全连接神经网络）"></a>1 多层感知机（全连接神经网络）</h1><h2 id="1-1-表示"><a href="#1-1-表示" class="headerlink" title="1.1 表示"></a>1.1 表示</h2><p>多层感知器又叫做全连接神经网络</p><p>比如 两层全连接神经网络<strong>图像表示：</strong></p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230217204411081.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230217204411081.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230217204411081" style="zoom:50%;" /><p>两层全连接网络 <strong>数学表达式：</strong></p><p>$f&#x3D;W_2max(0,W_1x+b_1)+b_2$</p><h2 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h2><p>全连接神经网路的概念</p><p><strong>输入层</strong></p><p>​输入层是神经网络的第一层，它接收外部输入并将其转换为神经网络能够理解的形式。例如，对于图像识别的任务，输入层通常将图像像素作为输入。</p><p><strong>隐层</strong></p><p>​隐层是输入层和输出层之间的中间层，它的作用是将输入层传递来的信息进行加工处理，并将处理后的信息传递给输出层。隐层可以有一个或多个，每个隐层包含多个神经元。</p><p><strong>输出层</strong></p><p>​输出层是神经网络的最后一层，它接收隐层传递过来的信息，并将处理后的结果输出为最终的预测结果。例如，在图像识别任务中，输出层可以输出对应的物体类别。</p><p><strong>全连接</strong></p><p>某一层的每一个神经元要和前层的所有神经元相连，所以叫做全连接</p><p>$f&#x3D;W_2max(0,W_1x+b_1)+b_2$</p><p><strong>层数</strong></p><p>除了输入层以外 有几层就叫几层神经网络（包括所有隐层和输出层）</p><p>如上面图就是两层的神经网络</p><p>全连接神经网路由线性部分和非线性部分多层级联而成</p><h2 id="1-3-必要组成—激活函数"><a href="#1-3-必要组成—激活函数" class="headerlink" title="1.3 必要组成—激活函数"></a>1.3 必要组成—激活函数</h2><p>我们说激活函数的作用就是非线性操作，那么常见的激活函数有哪些呢？</p><p><strong>1 Sigmoid函数</strong></p><p>$\frac{1}{1+e^{-x}}$</p><p>特点</p><ul><li>它的输出值在0和1之间</li><li>不是中心对称的</li></ul><p><strong>2 tanh函数</strong></p><p>$\frac{e^x-e^{-x}}{e^x+e^{-x}}$</p><p>双曲正切函数</p><ul><li>让数值变到-1和+1之间</li><li>是中心对称的</li></ul><p>以上两种函数都容易导致梯度消失问题（稍后讲到）</p><p>当代网络深度较深，梯度消失问题容易发生，所以更多采用如下函数</p><p><strong>3 ReLU 函数</strong></p><p>$max(0,x)$</p><p>ReLU函数在输入大于0时返回输入值，否则返回0。它的优势是计算速度快，不会有梯度消失问题；缺点是在输入小于0时，梯度为0，导致神经元无法更新。</p><p><strong>4 leaky ReLU 函数</strong></p><p>$max(ax,x)$</p><p>Leaky ReLU函数在输入小于0时返回一个非零值，可以解决ReLU函数的问题。</p><p>这些激活函数都有各自的优缺点</p><h2 id="1-4-网络结构设计"><a href="#1-4-网络结构设计" class="headerlink" title="1.4 网络结构设计"></a>1.4 网络结构设计</h2><p>综上我们学到的知识，我们实际的网络设计实际就是要自行解决如下两个问题</p><p>1、用不用隐藏，用一个或者几个隐层  （深度设计）</p><p>2、每个隐层设置多少个神经元比较合适 （宽度设计）</p><p>​神经元个数越多，分界面就越复杂，分类能力越强，但容易出现过拟合</p><h1 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2 损失函数"></a>2 损失函数</h1><p>在线性分类器那一节里讲到模型会给不同类别分数，但是直接的分数不能代表分类概率，而且有时候会出现打负分的情况</p><p>分类概率总和必须为1</p><p>所以我们进行Softmax操作</p><h2 id="2-1-SOFTMAX操作"><a href="#2-1-SOFTMAX操作" class="headerlink" title="2.1 SOFTMAX操作"></a>2.1 SOFTMAX操作</h2><p>而Softmax函数可以将每个神经元的输出值映射到0和1之间，并且所有输出的和等于1，可以表示每个分类的概率。</p><p><strong>操作过程</strong></p><p>得到一组分数f1,f2……fn</p><p>1 取指数</p><p>​$t_i&#x3D;e^{f_i}$</p><p>2 归一化</p><p>​$p_i&#x3D;\frac{t_i}{\sum{t}}$</p><p>假设我们有一个三分类问题，我们需要将神经网络的输出值转换成对应的分类概率。输出层有三个神经元，分别对应三个类别，输出值为：</p><p>$[0.5, 1.2, -0.3]$</p><p>我们可以使用Softmax函数将每个神经元的输出值转换为对应的概率。首先，计算每个神经元的指数函数值：</p><p>$[e^{0.5}, e^{1.2}, e^{-0.3}]$</p><p>然后，将指数函数值除以所有函数值的和，得到每个神经元对应的概率：</p><p>$[0.244, 0.665, 0.091]$</p><p>这意味着第一个类别的概率为0.244，第二个类别的概率为0.665，第三个类别的概率为0.091。可以看出，Softmax函数对每个神经元的输出值进行了归一化，并将它们转换为对应的概率，从而方便我们进行多分类问题的预测和训练。</p><p>在线性分类器那一节的损失函数——支撑向量能力比较的有限，今天介绍的交叉熵损失函数应用更广</p><p>交叉熵损失函数的基本思想是，用模型的输出概率分布与实际标签的分布之间的差异来衡量模型的损失程度，从而调整模型的参数。</p><h2 id="2-2-交叉熵损失函数"><a href="#2-2-交叉熵损失函数" class="headerlink" title="2.2 交叉熵损失函数"></a>2.2 交叉熵损失函数</h2><p>在介绍交叉熵之前，需要先了解几个概念，其中p和q是两个不同的分布</p><p>假设存在两个概率分布 P,Q  <strong>注意下面的log是以e为底</strong></p><p><strong>熵</strong>：   $H(p)&#x3D;-\sum_xp(x)logp(x)$</p><p>熵是信息论中用于衡量随机变量不确定性的指标，它表示一个随机变量的平均信息量。熵越大，表示随机变量的不确定性越大，即信息量越大。例如$[0 , 0  ,1]$这个分布没啥信息量，代入公式计算为0 因为他的不确定度很小</p><p>而对于分布[0.3,0.3.0.4]这个分布不确定性比较大，熵值就很大了</p><p><strong>相对熵：</strong>$KL(p||q)&#x3D;-\sum_xp(x)log\frac{q(x)}{p(x)}$</p><p>相对熵，也叫KL散度用来度量两个分布的不相似性（这里不叫做距离，是因为距离的话P到q和q到p的距离应该是一样的）而这里的话有可能不一样</p><p>如果两个分布一样，则相对熵为0，如果两个分布差异越大，相对熵越大</p><p>比如分布P[0,0,1]为和分布Q为 [0.3,0.3,0.4] 的相对熵为0.39，说明他俩相差比较大</p><p>而分布P为[0,0,1]和分布Q为 [0,0.1,0.9]相对熵0.04.说明他俩相差较小</p><p>实际中用到更多的是交叉熵</p><p><strong>交叉熵：</strong> $H(p,q)&#x3D;-\sum_xp(x)logq(x)$</p><p>因为三者存在这样一个关系</p><p>   $H(p,q)&#x3D;H(p)+KL(p||q)$</p><p>而如果P分布是标答，分布是独热码的形式，那么它的H(p) 就等于0 ，这样的话</p><p> $H(p,q)&#x3D;KL(p||q)$</p><p>我们就可以用交叉熵来代表相对熵了，计算更简单</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230218145435622.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230218145435622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230218145435622" style="zoom:67%;" /><p>计算交叉熵如下</p><p>$1<em>log(0.21)+0</em>log(0.01)+0*log(0.78)&#x3D;log(0.21)$</p><p>最后记得取负数  也就是$-log(0.21)$</p><p>我们发现为零的项完全不用计算</p><p>所以实际上   $L_i&#x3D;-log(q_j)$   j为真实值类别</p><p>实际输出就是真实标签概率的负对数。</p><p>关于一些损失函数的比较，和交叉熵损失pytorch的代码具体实现，可以查看我之前的这篇博客</p><p><a href="https://blog.csdn.net/Q52099999/article/details/132915817?spm=1001.2014.3001.5502">从原理到代码实践 | pytorch损失函数_Qodi的博客-CSDN博客</a></p><h1 id="3-优化"><a href="#3-优化" class="headerlink" title="3  优化"></a>3  优化</h1><h2 id="3-1-求导计算过于复杂？"><a href="#3-1-求导计算过于复杂？" class="headerlink" title="3.1 求导计算过于复杂？"></a>3.1 求导计算过于复杂？</h2><p>我们实际计算中，会发现原本的损失函数会十分复杂，因而我们该怎么办求导？方法就是采取计算图</p><p>利用计算图避免直接计算庞大的导数，将庞大的求导数化解为一个一个小的部分</p><p>计算图本质就是利用链式法则</p><p>计算图我也专门写了一篇博客，有代码的相关实现</p><p><a href="https://blog.csdn.net/Q52099999/article/details/132911894">pytorch的自动微分、计算图 | 代码解析_Qodi的博客-CSDN博客</a></p><h2 id="3-2-链式法则导致的问题？"><a href="#3-2-链式法则导致的问题？" class="headerlink" title="3.2 链式法则导致的问题？"></a>3.2 链式法则导致的问题？</h2><p>上述我们发现用计算图通过链式法则的方法可以很好得解决计算复杂的问题，但是我们发们发现这其中会有很多连乘，这样的情况下就可能会出现如下两个问题</p><p><strong>梯度消失</strong></p><p>本质是由于链式法则的乘法特性导致的</p><p>对于Sigmoid函数，tanh函数，由于导数很小，所以会导致反传的时候梯度消失，所以现在对于这种情况就是运用比较少了</p><p>Relu函数 ，对于大于0 的时候，梯度永远不会消失，而且计算很简单，所以应用比较多。但是对于小于零的情况不太好，</p><p><strong>梯度爆炸</strong></p><p>也是由链式法则导致的，某一点的梯度特别大 </p><p>​解决方案    梯度裁剪</p><p>​梯度裁剪的基本思想是，设置一个梯度阈值clip_value，如果梯度的绝对值大于这个阈值，就将梯度进行缩放，使其绝对数等于阈值。</p><p>普通梯度下降算法可能会存在的问题</p><p>一个方向上变化迅速  而在另一个方向上变化缓慢！同时</p><ol><li>依赖于学习率: 梯度下降算法的效果受到学习率的影响，如果学习率过大，会导致算法不收敛或者震荡；如果学习率过小，会导致算法收敛速度过慢。</li><li>可能会陷入局部最优解: 梯度下降算法的搜索方向只依赖于当前位置的梯度信息，因此可能会陷入局部最优解，无法找到全局最优解。</li></ol><h2 id="3-3-梯度下降算法的改进"><a href="#3-3-梯度下降算法的改进" class="headerlink" title="3.3 梯度下降算法的改进"></a>3.3 梯度下降算法的改进</h2><h3 id="3-3-1-动量法"><a href="#3-3-1-动量法" class="headerlink" title="3.3.1 动量法"></a>3.3.1 动量法</h3><p>动量法可以加快梯度下降的速度，同时也可以避免梯度下降过程中出现的震荡现象。</p><p>  $w$代表<strong>参数</strong>  $\epsilon$<strong>学习率</strong>，反向回传计算梯度后得到<strong>梯度g</strong></p><p>则传统梯度下降的参数更新表达式为： </p><p>​<strong>传统梯度下降参数更新</strong>   $w&#x3D;w-\epsilon g $</p><p>现在这个g变为动量v(t )</p><p>即<strong>动量法参数更新</strong>$w&#x3D;w-v(t)  $</p><p>v(t)就是我们说的动量</p><p>（1）第一步要计算动量，需要用到前一时刻的动量</p><p>$v(t)&#x3D;u*v(t-1)+g$</p><p>u是一个超参数 动量系数 ，一般设为0.9 </p><p>​如果设置为0   则退化为标准小批量梯度下降算法</p><p>​如果设置为1 ，即使g到了平坦区域依然停不下来</p><p>​而如果u小于1的话，在g到了接近0 的情况下，v由于u的存在就会不断减小，让他到达一个较低平坦点</p><p>​就好像摩擦系数一样，让他一点一点停下来。</p><p>v(t-1)是前一时刻的动量</p><p>具体来说，动量法在更新参数的过程中，不仅考虑当前的梯度，还考虑之前的梯度，从而使得更新方向更加稳定。</p><p>（2）然后v(t)代入梯度下降参数更新式</p><p><strong>动量法还有什么效果？</strong></p><p>避免到达局部最小点，鞍点停下来</p><p><strong>举例：</strong></p><p>假设我们要使用动量法来优化以下函数：</p><p>$f(x,y) &#x3D; x^2 + 2y^2$</p><p>我们希望求出使得函数f(x,y)最小的点。首先，我们通过梯度计算出当前点的梯度，然后根据动量法的公式来更新参数。假设学习率为0.1，动量系数为0.9，我们可以按照以下步骤进行迭代：</p><ol><li>初始化参数x&#x3D;1，y&#x3D;1，初始动量$v_x(t-1)&#x3D;0，v_y(t-1)&#x3D;0$</li><li>计算当前点的梯度g(x)&#x3D;2x，g(y)&#x3D;4y</li><li>根据动量法的公式来更新动量$v_x(t)&#x3D;0.9v_x(t-1)+ 2x，v_y(t)&#x3D;0.9v_y(t-1)+ 4y$</li><li>根据动量v(x)和v(y)来更新参数$x&#x3D;x-0.1<em>v_x(t)，y&#x3D;y-0.1</em>v_y(t)$</li><li>重复第2-4步，直到收敛到最优点</li></ol><h3 id="3-3-2-自适应梯度方法"><a href="#3-3-2-自适应梯度方法" class="headerlink" title="3.3.2 自适应梯度方法"></a>3.3.2 自适应梯度方法</h3><h4 id="1-AdaGrad"><a href="#1-AdaGrad" class="headerlink" title="1 AdaGrad"></a><strong>1 AdaGrad</strong></h4><p>和动量法思路不一样，分别改变学习率</p><p>1 区分哪个方向是震荡方向，哪个方向是平坦方向就可以了，在震荡方向减少步长，平坦方向增大步长</p><p>2 如何区分平坦还是震荡？</p><p>通过梯度幅度的平方较大的地方，梯度幅度平方较小的方向是平坦方向</p><p>  $w$代表参数  $\epsilon$学习率，反向回传计算梯度后得到梯度g</p><p>则传统梯度下降的参数更新表达式为： </p><p>​<strong>传统梯度下降参数更新</strong>   $w&#x3D;w-\epsilon g $</p><p>​<strong>动量法参数更新</strong>$w&#x3D;w-v(t)  $</p><p>而自<strong>适应的AdaGrad参数更新</strong></p><p>$w&#x3D;w-\frac{\epsilon}{\sqrt{r}+\delta}g$</p><p>其中 $ r&#x3D;r+g*g$  利用新得到的r来更新权值</p><p>当r 较小时    $\epsilon$ 就会被放大   整体学习率变大</p><p>当r 较大时  $\epsilon$ 就会被缩小 整体学习率变小</p><p>具体来说，Adagrad算法会对每一个参数维护一个历史梯度平方和的累加量，并将其用于调整学习率。在更新每一个参数时，Adagrad算法会根据历史梯度平方和对当前的梯度进行归一化，然后再乘以学习率。这样可以使得每个参数的学习率自适应地调整，更好地适应不同的数据集和模型。</p><p>根号r旁边加了一个小常数，避免除零</p><p>缺陷  r会不断累积   会让r变得很大，这时候就会导致无法起到调节作用</p><p>基于这个缺陷的改进算法RMSProp</p><h4 id="2-RMSProp"><a href="#2-RMSProp" class="headerlink" title="2  RMSProp"></a>2  RMSProp</h4><p>上面讲到 <strong>自适应的AdaGrad参数更新</strong></p><p>$w&#x3D;w-\frac{\epsilon}{\sqrt{r}+\delta}g$</p><p>其中 $ r&#x3D;r+g*g$  </p><p>而对于<strong>自适应RMSProp参数更新</strong></p><p>$w&#x3D;w-\frac{\epsilon}{\sqrt{r}+\delta}g$</p><p>其中$ r&#x3D;\rho r+(1-\rho)g*g$</p><p>加上一个衰减项，解决了上面的缺陷</p><p>具体是，当r变得较大的时候，后面部分就不起作用了</p><p>使得$r&#x3D;\rho r$  由于$\rho&lt;0$ 所以r就会减小 不会无限制变大</p><h3 id="3-3-1-Adam"><a href="#3-3-1-Adam" class="headerlink" title="3.3.1  Adam"></a>3.3.1  Adam</h3><p>同时使用动量和自适应梯度的方法</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230920202606050.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230920202606050.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230920202606050"></p><p>这里加了一个修正偏差 可以 极大减缓算法初期的冷启动问题</p><p>最开始启动的时候 梯度很小，更新很慢，所以要修正偏差</p><h1 id="4-网络信息流通畅"><a href="#4-网络信息流通畅" class="headerlink" title="4.网络信息流通畅"></a>4.网络信息流通畅</h1><p>为了使得训练正常进行</p><p>要正向反向信息流传递通畅，为此有一些技巧</p><h2 id="4-1-权值初始化"><a href="#4-1-权值初始化" class="headerlink" title="4.1 权值初始化"></a>4.1 权值初始化</h2><p>初始化作用</p><ol><li>避免梯度消失和梯度爆炸：在神经网络中，参数的初始化会影响到反向传播计算中梯度的大小，过小或过大的参数都会导致梯度消失或梯度爆炸的问题。通过合理的参数初始化，可以使得梯度的大小更加合适，防止出现梯度消失或梯度爆炸的情况，从而提高模型的稳定性和收敛速度。</li><li>加快网络收敛速度：合理的参数初始化可以使得神经网络在训练初期更快地收敛，从而提高模型的训练速度和效率。例如，我们可以使用Xavier初始化、He初始化等方法来初始化参数，从而提高模型的收敛速度。</li><li>提高模型泛化能力：合理的参数初始化可以使得神经网络更好地适应新的样本，从而提高模型的泛化能力。例如，对于卷积神经网络和循环神经网络，我们可以使用不同的参数初始化方法来提高模型的泛化能力和性能。</li></ol><p>有效的<strong>初始化方法</strong></p><p>正向信息流顺利，反向梯度流也顺利</p><h3 id="Xavier初始化方法"><a href="#Xavier初始化方法" class="headerlink" title="Xavier初始化方法"></a>Xavier初始化方法</h3><p>Xavier初始化的主要思想是根据输入和输出神经元的数量来设置每个权重的初始值，使得这些权重的方差保持不变。</p><p>权值采样自N(0,1&#x2F;N)的高斯分布</p><p>适合双曲正切和Sigmoid函数</p><p>但是不适合ReLu激活函数</p><p>ReLu函数适合下面的方法</p><h3 id="He-初始化方法"><a href="#He-初始化方法" class="headerlink" title="He 初始化方法"></a>He 初始化方法</h3><p>权值采样自N(0,2&#x2F;N)的高斯分布</p><p>当ReLU函数和Leakly ReLU函数方法</p><h2 id="4-2-批归一化-Batch"><a href="#4-2-批归一化-Batch" class="headerlink" title="4.2  批归一化 Batch"></a>4.2  批归一化 Batch</h2><p>调整权值分布使得输出与输入具有相同的分布</p><p>减去小批量均值除以小批量方差再输出</p><p>计算小批量均值</p><p>计算小批量方差</p><p>批归一化操作 在非线性激活之前，全连接层后</p><p>避免梯度消失</p><h1 id="5-对抗过拟合方法"><a href="#5-对抗过拟合方法" class="headerlink" title="5 .对抗过拟合方法"></a>5 .对抗过拟合方法</h1><h2 id="5-1-随机失活-Dropout"><a href="#5-1-随机失活-Dropout" class="headerlink" title="5.1  随机失活 Dropout"></a>5.1  随机失活 Dropout</h2><p>随机使得某一层的神经元失活</p><p>为什么可以达到效果</p><ul><li>解释一： 参数量减少</li><li>解释二： 鼓励权重分散</li><li>解释三： 可以看做模型集成</li></ul><h2 id="5-2-数据增强"><a href="#5-2-数据增强" class="headerlink" title="5.2 数据增强"></a>5.2 数据增强</h2><p>过合理地对原始数据进行变换，增加训练集的样本数量，从而减少模型的过拟合风险。例如，对图像数据进行旋转、翻转、缩放等操作，对文本数据进行随机切割、替换等操作。</p><h2 id="5-3-正则化"><a href="#5-3-正则化" class="headerlink" title="5.3 正则化"></a>5.3 正则化</h2><p>正则化是一种常用的缓解过拟合的方法，它通过在损失函数中增加正则项来惩罚模型的复杂度，从而减小模型的过拟合风险。常用的正则化方法包括L1正则化、L2正则化和弹性网络等。</p><h2 id="5-4-批归一化"><a href="#5-4-批归一化" class="headerlink" title="5.4 批归一化"></a>5.4 批归一化</h2><p>  批归一化可以减少每一层输入的分布变化，从而使得网络更快地收敛，同时也可以作为一种正则化技术，减小模型的过拟合风险。</p><h1 id="6-超参数优化方法"><a href="#6-超参数优化方法" class="headerlink" title="6 超参数优化方法"></a>6 超参数优化方法</h1><h2 id="6-1-网格搜索法"><a href="#6-1-网格搜索法" class="headerlink" title="6.1 网格搜索法"></a>6.1 网格搜索法</h2><p>网格搜索法是一种简单直观的超参数优化方法，它通过遍历超参数空间中所有可能的组合，来查找最佳的超参数组合。具体来说，网格搜索法首先需要定义超参数的取值范围，然后将每个超参数的取值范围离散化，生成一个超参数网格。然后遍历这个网格上的所有组合，依次评估每个组合的性能，最终找到最佳的超参数组合。</p><h2 id="6-2-随机搜索法"><a href="#6-2-随机搜索法" class="headerlink" title="6.2 随机搜索法"></a>6.2 随机搜索法</h2><p>随机搜索法是一种更加高效的超参数优化方法，它通过在超参数空间中随机采样，来查找最佳的超参数组合。具体来说，随机搜索法首先需要定义超参数的取值范围，然后在这个范围内随机采样若干组超参数组合，依次评估每个组合的性能。随机搜索法的优点是可以避免网格搜索法中的过拟合问题，同时对于超参数空间较大或维度较高的情况，随机搜索法更加高效。</p><p>可以先粗搜索,搜索间隔调大一些，选定区域后 再细搜索</p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典网络（一）线性分类器</title>
      <link href="/2023/12/16/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1%20%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8/"/>
      <url>/2023/12/16/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1%20%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230314170346906.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230314170346906.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230314170346906"></p><p>为什么我们从线性分类器开始?是由于线性分类器的基本特点决定的</p><h1 id="1-基本特点"><a href="#1-基本特点" class="headerlink" title="1 基本特点"></a>1 基本特点</h1><p>​形式简单、易于理解，通过层级结构混合非线性操作可以形成功能强大的非线性模型</p><p>​线性分类器是一种线性映射，将输入的图像特征映射为类别分数</p><h1 id="2-训练过程"><a href="#2-训练过程" class="headerlink" title="2 训练过程"></a>2 训练过程</h1><h2 id="2-1-图像预处理"><a href="#2-1-图像预处理" class="headerlink" title="2.1  图像预处理"></a>2.1  图像预处理</h2><p>​图像预处理就是将我们的图像转换并表示为可以输入分类器的一串信息数字</p><p>​比如经典图像集CIFAR10 总有十个类别，数据集中每一张图像像素为32×32  ，每一个（采用RGB）像素通道为3，我们首先要将图片转换为一个向量，转换方式多种，现在我们只做简单的转换方式，用一个32×32×3&#x3D;3072维的列向量来表示我们这张图片。具体可以参考这篇博客</p><h2 id="2-2-线性分类器构造"><a href="#2-2-线性分类器构造" class="headerlink" title="2.2 线性分类器构造"></a>2.2 线性分类器构造</h2><p>这里需要一些线性代数矩阵相乘，矩阵转置的知识</p><p>​$f_i(x,w_i)&#x3D;w_i^Tx+b_i$   $i&#x3D;1,…,c$ </p><ul><li>x代表输入的d维图像向量    此个例子中是3072维度的列向量</li><li>$w_i&#x3D;[w_{i1},…,w_{id}]^T$为第i个类别的权值向量，行数由类别数决定，如以上例子有10类，列数由输入的x向量的维度决定，如以上例子为3072维 因而$w_i$的维度为10×3072</li><li>$b_i$为偏置值。维度是10×1</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230313223418957.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230313223418957.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230313223418957"></p><p>这其实相当于我们把一张图片，输入到这个式子中，得到每个类下这张图片的分数。</p><h3 id="2-2-1多角度理解我们分类器的权值W"><a href="#2-2-1多角度理解我们分类器的权值W" class="headerlink" title="2.2.1多角度理解我们分类器的权值W"></a>2.2.1多角度理解我们分类器的权值W</h3><p><strong>理解线性分类器的角度一</strong></p><p>线性分类器的w权值信息，其实就是训练样本的平均值，统计信息，是每一类别的一个模板。由于W也可以看做10个3072维向量组成的矩阵，因而我们可以进行权值模板的可视化</p><p>我们可以把它显示为32×32×3的图片，这时候就会得到10张图片，对应10类，观察我们可以发现：每一类其实就是该类下各个图片的一个均值，一个统计信息，如果我们新输入的图片和某一类模板相似，就会导致该类模板对应的额分数更高。</p><p>比如这里的W8代表马类，观察到两个马头，一个朝左，一个朝右，为什么呢？因为训练样本中就有的马头朝左，有的马头朝右</p><p>   <img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230216213641423.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230216213641423.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230216213641423"></p><p><strong>理解线性分类器权值角度二</strong></p><p>如图，我们实际上就是要找一些分界面，来把不同类比的分开，如下面的红蓝绿线</p><ul><li>我们距离线越远，他的得分越高，也就意味着相应的类别特征越明显</li><li>距离线越近，得分越低，也就类别特征越模糊</li></ul><p>分数等于0的相当于一个决策面 分界面。</p><p>w控制着线的方向，b控制着分界面的偏移</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230216214203831.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230216214203831.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230216214203831" style="zoom:50%;" /> <h2 id="2-3-损失函数计算损失值"><a href="#2-3-损失函数计算损失值" class="headerlink" title="2.3 损失函数计算损失值"></a>2.3 损失函数计算损失值</h2><h3 id="2-3-1-损失函数定义"><a href="#2-3-1-损失函数定义" class="headerlink" title="2.3.1 损失函数定义"></a>2.3.1 损失函数定义</h3><p>什么是损失函数呢？</p><p>比如我们的真实值是猫咪，设有两组权值他们对于猫咪的预测的分数都是最高的，但我们权值一预测猫咪的分数是900分，权值二预测的分数是100分，很明显权值一更好，因而我们就是通过损失函数来定量的展现这样的差异。</p><p>它搭建了模型性能与模型参数之间的桥梁，指导模型参数的优化，</p><p>它其实是预测值与真实值的不一致程度，量化了这个指标，我们把它称为<strong>损失值</strong>，损失值越大，不一致程度越大，也就预测的越不准确</p><p>我们的每一次学习结束后，都可以对应得到一些新的参数，我们检测新的参数的好坏。</p><p>可以拿一百张新的图像去测试，然后把每一张图片的测试结果都对应得到一个损失值，把这一百个损失值加起来除以测试总数一百，就得到我们平均的损失值。反映了这一组参数的整体的水平，抽象为数学表达式为</p><p>$L&#x3D;\frac{1}{N}\sum(L_i)$</p><p>$L_i$为 单张图片的损失值</p><h3 id="2-3-2-损失举例：多类支撑向量机损失"><a href="#2-3-2-损失举例：多类支撑向量机损失" class="headerlink" title="2.3.2 损失举例：多类支撑向量机损失"></a>2.3.2 损失举例：多类支撑向量机损失</h3><p>对于任意一张图片，他都有唯一的与之对应的一个正确类别并有一个分数，我们把他定义为$S_{right}$，而其他类别的分数对这张图片来说都是错误类的分数，我们把它定义为$S_{error , j}$  这里下标有一个j，代表是有多个错误类分数。要把所有的错误类分数都考虑进去</p><p>单样本的多类支撑向量机损失定义式为</p><p>$L_i&#x3D;\sum{max(0,S_{error , j}-S_{right}+1)}$      </p><p>对于每一张图片，把它正确的</p><p><strong>如何直观理解该损失？</strong></p><p>   正确类的分数比错误类的分值大于一分。这时损失函数返回为0，否则的话就是我们错误类的分数加上一分减去我们正确类的分数就是我们得到的损失值。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230217105221052.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230217105221052.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230217105221052"></p><p>如上</p><ul><li>第一行的正确类为鸟类，比猫类分数高超过一分，该项损失值为零，但对于汽车类没有高超过一分，因而错误的汽车类分数+1得到2.9再减去正确类鸟类的分数0.6等于2.3        1.9+1-0.6&#x3D;2.3              总损失0+2.3&#x3D;2.3</li><li>第二行的正确类为猫类，比鸟类分数高超过一分，该项损失值为零，但对于汽车类没有高超过一分，因而错误的汽车类分数+1得到3.3再减去正确类猫类的分数2.9等于0.4        2.3+1-2.9&#x3D;0.4              总损失0+0.4&#x3D;0.4</li><li>第三行的正确类为汽车类，比其他错误类的分数都大于一分，因而总损失为零</li></ul><h3 id="2-3-3-优化损失函数"><a href="#2-3-3-优化损失函数" class="headerlink" title="2.3.3 优化损失函数"></a>2.3.3 优化损失函数</h3><p>即便有了损失值，有时候我们也会出现损失值一模一样的情况，这时候如何评定参数好坏呢？就是通过添加包含超参数正则项损失  其中$\lambda$ 是超参数（超参数 不通过学习设置的参数，预先人为设定好的参数）这个超参数的作用是控制着正则项损失在总损失中占得比重</p><ul><li>$\lambda$为0的时候只依靠前面的损失函数</li><li>$\lambda$为无穷的时候仅考虑正则项损失</li></ul><p>$L&#x3D;\frac{1}{N}\sum(L_i)+\lambda R(W)$</p><p>正则项具体可以分为：</p><p>​L1 正则项     把权值矩阵W的每个元素取绝对值后再相加</p><p>​L2 正则项     把权值矩阵W的每个元素先平方再相加</p><p><strong>如何直观理解正则项</strong></p><p>正则项对于大数权值进行惩罚，喜欢分散权值，鼓励分类器将所有维度的特征值用起来。而不是强烈的依赖其中少说的几维特征。防止模型训练的太好，过拟合（即只能学会自己的数据）。</p><p>使得每个维度的特征运用起来，有什么意义呢？</p><ul><li>避免受到噪声影响，假设它强烈依赖某一维度，那么一但那一维度受到噪声污染，判断就会严重错误，而如果分散权值，那么即便某一维度受到影响，也不影响整体判断</li><li>还有避免模型产生偏好，对某一维度的特征喜欢，产生记忆，因而也就会产生过拟合，所以正则项的一个重要作用就是防止过拟合！！！</li></ul><p>我们目前更多地是使用L2正则项，原因是计算方便</p><p>不过L1损失函数也有优点，就是L1对于异常值更不敏感，鲁棒性更强</p><h2 id="2-4-优化算法"><a href="#2-4-优化算法" class="headerlink" title="2.4 优化算法"></a>2.4 优化算法</h2><h3 id="2-4-1-优化的定义？"><a href="#2-4-1-优化的定义？" class="headerlink" title="2.4.1 优化的定义？"></a>2.4.1 优化的定义？</h3><p>是机器学习的核心步骤，利用函数的输出值作为反馈信号来调整分类器参数，以提升分类器对训练样本的预测性能。</p><p>实际上我们就是要找使得损失函数的值是最小的那一组参数！！！而我们对这类问题并不陌生，高中的时候学习导数的时候讲过求最值问题，实际上是要找一些导数为零的点，这些导数为零的点中就有我们的最小值点。</p><p>假如我们只有一个参数W,且损失函数是</p><p>$L&#x3D;W^2+2W+1$</p><p>我们想要使得损失函数最小，我们可以很轻松知道是在W&#x3D;-1的位置</p><p>但是实际问题中，我们的损失函数L往往非常复杂，同时W也十分庞大，如下图一个简单的线性模型，他的要学习的W的参数量就达到了10*3072维&#x3D;30720。直接求导数为零的点就会变得十分困难，所以我们通过梯度下降算法来使得损失减小。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230313223418957.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230313223418957.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230313223418957"></p><h3 id="2-4-2-梯度下降算法"><a href="#2-4-2-梯度下降算法" class="headerlink" title="2.4.2 梯度下降算法"></a>2.4.2 梯度下降算法</h3><p>​它是其中的一种简单而高效的优化算法</p><p>​设想我们被遮住了双眼，被困在一个寂静的山谷，我们只知道只能在山谷最低的地方才有机会存活下来。我们该怎么办</p><p>​唯一的办法是四处摸，找到向下的路，然后一点一点从高处移动到低处。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230314152142597.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230314152142597.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230314152142597"></p><p>这 便是梯度下降算法的核心思想</p><p>我们需要把全部训练数据样本传入我们的分类器，这时候他就会根据我们的输出类别分数的好坏去调整参数W</p><p>相当于此时我们是$L(W{_i})$    自变量是W,因变量是损失值L</p><p>   我们只需要解决两个问题</p><p><strong>往哪走？</strong></p><p>​负梯度方向，也就是向导数为负数且变化最快的点走</p><p><strong>走多远？</strong></p><p>​步长（也就学习率）来决定，步长也是我们的认识到的第二个超参数</p><p>因而我们把问题由找到导数为零的点转换为求某一点的梯度，$\frac{\partial f}{\partial W_{i}}$进而来不断更新权值</p><blockquote><p> 权值的梯度  &lt;&#x3D;计算梯度（损失，训练样本，权值）  </p><p> ​      权值        &lt;&#x3D;权值-学习率*权值的梯度</p></blockquote><p>如何来求某一点的梯度呢？也就是在 一个已知一个权值矩阵的基础上如何确定他的梯度</p><p><strong>1、 数值法</strong></p><p>​也就是利用求导的定义式，所以求得的是一个近似值</p><p>​数值法求梯度主要用于检验解析梯度是否正确</p><p><strong>2、 解析法</strong></p><p>​求这一点的导数，然后代入这一点的值</p><p>​    但这有一个问题，我们每次迭代计算都得把样本中的每一个数据都算一遍！当数据集样本足够大的时候，运算速度就会很慢，因而我们采用以下的方式改进</p><h3 id="2-4-3-随机梯度下降算法"><a href="#2-4-3-随机梯度下降算法" class="headerlink" title="2.4.3 随机梯度下降算法"></a>2.4.3 随机梯度下降算法</h3><p> 也就是我们这次不参考全部样本，而是从样本集合中随机抽取一个来更新。这样就会计算很多了，但是这样有一个问题，就是可能会抽取到噪声等一些不太好的样本，这时候会把我们带偏，但是这种方法依然可行，因为在大量抽样的情况下，整体还是向着梯度下降的方向去的。</p><h3 id="2-4-4-小批量梯度下降算法"><a href="#2-4-4-小批量梯度下降算法" class="headerlink" title="2.4.4 小批量梯度下降算法"></a>2.4.4 小批量梯度下降算法</h3><p>既然全部抽取速度太慢，部分抽取又可能会不稳定，那我们很容易想到取中间，也就是说我们随机抽取m个样本，计算损失并更新梯度。</p><p>这样的话我们计算效率会更高，同时也会更稳定！！！</p><p><a href="https://zhuanlan.zhihu.com/p/68468520">梯度下降算法（Gradient Descent)的原理和实现步骤 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_41800366/article/details/86583789">梯度下降算法原理讲解——机器学习_zhangpaopao0609的博客-CSDN博客_梯度下降</a></p>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习导读 概念介绍</title>
      <link href="/2023/12/15/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/"/>
      <url>/2023/12/15/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-机器学习是什么？"><a href="#1-机器学习是什么？" class="headerlink" title="1.机器学习是什么？"></a>1.机器学习是什么？</h3><p>机器学习实际上就是以数据为基础，发现数据之间本来存在而没有被发现的规律，它的一个重要特征就是尽量避免人的参与，尝试直接从数据中发现规律和解决问题的方案。</p><h3 id="2-机器学习基础概念"><a href="#2-机器学习基础概念" class="headerlink" title="2.机器学习基础概念"></a>2.机器学习基础概念</h3><h4 id="2-1-机器学习类型"><a href="#2-1-机器学习类型" class="headerlink" title="2.1 机器学习类型"></a>2.1 机器学习类型</h4><h5 id="2-1-1有监督学习"><a href="#2-1-1有监督学习" class="headerlink" title="2.1.1有监督学习"></a>2.1.1有监督学习</h5><p>​用来学习的数据有明确的含义，机器根据数据及其含义学习，把数据称为“特征值”， 数据的含义称为“标签”</p><p>​典型应用比如分类 ，回归</p><h5 id="2-1-2无监督学习"><a href="#2-1-2无监督学习" class="headerlink" title="2.1.2无监督学习"></a>2.1.2无监督学习</h5><p>​指用来学习的数据没有明确的含义</p><p>​典型应用比如异常检测，分类</p><h5 id="2-1-3半监督学习"><a href="#2-1-3半监督学习" class="headerlink" title="2.1.3半监督学习"></a>2.1.3半监督学习</h5><p>​部分数据是有含义的</p><h5 id="2-1-4强化学习"><a href="#2-1-4强化学习" class="headerlink" title="2.1.4强化学习"></a>2.1.4强化学习</h5><p>​它在解决问题的时候不断实践，在实践中探索尝试，然后总结出比较好的策略。比如阿尔法围棋就是这样去做的</p><h4 id="2-2数据集划分"><a href="#2-2数据集划分" class="headerlink" title="2.2数据集划分"></a>2.2数据集划分</h4><p>​数据集收集好后，我们不会把他们全部用于训练，好比题库我们有一百道题，老师给我们讲九十道题，剩下十道题进行训练测试，检验我们的学习效果。</p><p>​机器学习也是如此</p><ul><li>训练数据：又称训练集，是训练模型时使用的数据，使用训练集来生成模型，用于学习参数</li><li>验证数据：又称验证集，用于<strong>选择超参数</strong>，用来评估与选择模型</li><li>测试数据： 又称测试集 ，测试集来测试模型的评估泛化能力</li></ul><p>比如我们将数据分成A,B，C，D，E 五组，其中E做测试组，其余组做训练组。</p><p>在数据很少的情况下，我们也可以采用<strong>交叉验证</strong>的方法，也就是第一次训练用E组测试，其余组训练，第二次训练用D组测试，其余组训练……</p><h4 id="2-3模型拟合"><a href="#2-3模型拟合" class="headerlink" title="2.3模型拟合"></a>2.3模型拟合</h4><p> 模型拟合方式可能存在着三种情况</p><ul><li><p>拟合良好</p><p>既能够很好的拟合训练数据，又能够很好的预测测试数据</p></li><li><p>过拟合</p><p>能够非常好的拟合训练数据，但对测试数据的预测很差</p></li><li><p>欠拟合</p><p>不能够很好的拟合训练数据，也不能用来预测测试数据</p></li></ul><p>我们要避免过拟合和欠拟合情况发生</p><p>可以做这样一个例比，小晓调到了一个新的部门上班，这个部门有30人，他不知道在这个新部门的工资是多少钱，如果他把这个部门的30个人都问一遍，那么预测自己的工资大概率是准确的，这时候我们说他是拟合良好，而他只问身边一两个人就预测自己的工资，大概率是不准确的，此时是欠拟合，如果他问了整个公司4000人的工资，又过拟合，这时候对于自己工资的预测也是不准确的。</p><h4 id="2-4-性能度量"><a href="#2-4-性能度量" class="headerlink" title="2.4 性能度量"></a>2.4 性能度量</h4><h5 id="2-4-1-二分问题的性能度量"><a href="#2-4-1-二分问题的性能度量" class="headerlink" title="2.4.1 二分问题的性能度量"></a>2.4.1 二分问题的性能度量</h5><p>​  准确率</p><p>​</p><p>​      查全率</p><h5 id="2-4-2-其他性能度量"><a href="#2-4-2-其他性能度量" class="headerlink" title="2.4.2 其他性能度量"></a>2.4.2 其他性能度量</h5><p>​方差  相同规模不同训练数据产生的差别</p><p>​偏差   模型输出与真实值的差别</p><h3 id="3-OpenCV中的机器学习方法"><a href="#3-OpenCV中的机器学习方法" class="headerlink" title="3.OpenCV中的机器学习方法"></a>3.OpenCV中的机器学习方法</h3><h4 id="3-1决策树"><a href="#3-1决策树" class="headerlink" title="3.1决策树"></a>3.1决策树</h4>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类器整体介绍</title>
      <link href="/2023/12/14/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E5%88%86%E7%B1%BB%E5%99%A8%E6%95%B4%E4%BD%93/"/>
      <url>/2023/12/14/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E5%88%86%E7%B1%BB%E5%99%A8%E6%95%B4%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图像表示"><a href="#1-图像表示" class="headerlink" title="1 图像表示"></a>1 图像表示</h2><ul><li>基础像素表示</li><li>全局特征表示 如GIST    比较适合风景类，室内场景，城市建筑。要依赖所有像素，对于如遮挡一类问题就不太适合了</li><li>局部特征表示 如GIST</li></ul><p>2012年前，就要找到一个很好的特征，但对于神经网路而言是无所谓的</p><h2 id="2-分类模型"><a href="#2-分类模型" class="headerlink" title="2 分类模型"></a>2 分类模型</h2><p>我们学习神经网络在学些什么？</p><p>其实就是在学</p><ol><li>这每一类分类器的优势，适用于哪些场合</li><li>这每一类分类器的原理，从而我们对于分类器做出合理的调整来解决具体问题</li></ol><p>常见分类器</p><ul><li>近邻分类器</li><li>贝叶斯分类器</li><li>线性分类器</li><li>支撑向量机分类器</li><li>神经网络分类器</li><li>随机森林</li><li>Adaboost<br>sd</li></ul><h2 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3 损失函数"></a>3 损失函数</h2><p>常见的损失函数</p><ul><li>0-1 损失</li><li>多类支撑向量机损失</li><li>交叉熵损失</li><li>L1损失</li><li>L2损失</li></ul><h2 id="4-优化方法"><a href="#4-优化方法" class="headerlink" title="4 优化方法"></a>4 优化方法</h2><p>一阶方法</p><ul><li>梯度下降</li><li>随机梯度下降</li><li>小批量随机梯度下降</li></ul><p>二阶方法</p><ul><li>牛顿法</li><li>BFGS</li><li>L-BFGS</li></ul><p>训练过程本身</p><ul><li>数据集划分</li><li>数据预处理</li><li>数据增强</li><li>欠拟合与过拟合</li><li>超参数调整</li><li>模型集成<img src="/img%5C1.jpg" class="lazyload placeholder" data-srcset="/img%5C1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1"></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（十）直接访问内存DMA</title>
      <link href="/2023/12/11/Computer_system/embedded_system/9%20%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/12/11/Computer_system/embedded_system/9%20%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-直接内存访问概述"><a href="#1-直接内存访问概述" class="headerlink" title="1 直接内存访问概述"></a>1 直接内存访问概述</h1><p>是一种 不经过CPU而直接从内存存取数据的数据交换模式。在 DMA模式下，CPU只须向DMA控制器下达指令，让DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU</p><p><strong>优点</strong></p><p> 减轻CPU资源占有率，同时保证在低功耗模式下的CPU与外设的传送单元数据，进而降低了整个系统的功耗</p><h1 id="2-CC2530的DMA特点"><a href="#2-CC2530的DMA特点" class="headerlink" title="2 CC2530的DMA特点"></a>2 CC2530的DMA特点</h1><p>1  多个独立的 DMA 通道 </p><p>​5个通道编号从0到4，每个通道可以实现DMA内存空间内的数据搬移</p><p>2 多个可以配置的 DMA 通道优先级  3个优先级</p><p>​00:低级，CPU优先<br>​01:保证级，DMA至少在每秒一次的尝试中优先<br>​10:高级，DMA优先</p><p>3  32 个可以配置的传送触发事件</p><p>​就是在这些事件发生的时候，进行DMA传输</p><p>​例如 UART 传输、定时器溢出等等</p><p>​DMA 通道要使用的触发事件由 DMA 通道配置设置，因此直到<strong>配置被读取之后</strong>，才能知道。</p><p>​为了通过 DMA 触发事件开始 DMA 传送，用户软 件也可以设置对应的 DMAREQ 位，强制使一个 DMA 传送开始。</p><p>4  源地址和目标地址的独立控制</p><p>5 多种传送模式——单独传送、数据块传送和重复传送模式</p><p>6  支持传输数据的长度域，设置可变传输长度</p><p>7 既可以工作在字模式，又可以工作在字节模式</p><h1 id="3-使用流程"><a href="#3-使用流程" class="headerlink" title="3  使用流程"></a>3  使用流程</h1><h2 id="3-1-配置DMA通道"><a href="#3-1-配置DMA通道" class="headerlink" title="3.1 配置DMA通道"></a>3.1 配置DMA通道</h2><h3 id="3-1-1-DMA-配置数据结构（配置参数）"><a href="#3-1-1-DMA-配置数据结构（配置参数）" class="headerlink" title="3.1.1   DMA 配置数据结构（配置参数）"></a>3.1.1   DMA 配置数据结构（配置参数）</h3><p>就是DMA的一些参数设置</p><p>五个DMA通道都包括如下的参数设置</p><p>1 源地址：DMA通道要读的数据的首地址。</p><p>2 目标地址：DMA通道从源地址读出的要写数据的首地址。用户必须确认该目标地址可写。</p><p> 3  传送长度：很好理解，长度可以在配置中定义，或可以如下所述定义为VLEN可变长度设置。 </p><p>4  可变长度 （ VLEN） 设置： DMA通道可以利用源数据中的第一 个字节或字作为传送长度进行可变长度传输。使用可变长度传输 时，要给出关于如何计算要传输的字节数的各种选项。</p><p>5 优先级别： DMA通道的DMA传送的优先级别与CPU、其它DMA 通道和访问端口相关</p><h3 id="3-1-2-DMA-寄存器配置"><a href="#3-1-2-DMA-寄存器配置" class="headerlink" title="3.1.2 DMA 寄存器配置"></a>3.1.2 DMA 寄存器配置</h3><p>主要进行中断配置，传输完成等引发中断</p><h2 id="3-2-进入工作状态"><a href="#3-2-进入工作状态" class="headerlink" title="3.2 进入工作状态"></a>3.2 进入工作状态</h2><p>DMA通道通过将DMA通道的工作状态寄存器DMAARM中指定位置1</p><p>一个通道准备工作状态（即获得前面讲到的配置数据）的时间需要 9 个系统 时钟，因此如果相应的 DMAARM 位设置，触发在需要配置通道的时 间内出现，期望的触发将丢失。</p><p>如果多于一个 DMA 通道同时进入工作状态，所有通道配置的的时间 将长一些（按顺序读取内存） 。如果所有 5 个通道都进入工作状态 ，需要 45 个系统时钟，通道 1 首先准备好，然后是通道 2，最后是 通道 0（所有都在最后 8 个系统时钟内） 。</p><h2 id="3-3-等待触发事件发生"><a href="#3-3-等待触发事件发生" class="headerlink" title="3.3  等待触发事件发生"></a>3.3  等待触发事件发生</h2><p>一旦 DMA 通道进入工作状态，当配置的 DMA 触发事件发生时，传送就开始了</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（九）电源低功耗管理</title>
      <link href="/2023/12/10/Computer_system/embedded_system/8%20%E7%94%B5%E6%BA%90%E4%BD%8E%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86/"/>
      <url>/2023/12/10/Computer_system/embedded_system/8%20%E7%94%B5%E6%BA%90%E4%BD%8E%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-低功耗基本介绍"><a href="#1-低功耗基本介绍" class="headerlink" title="1 低功耗基本介绍"></a>1 低功耗基本介绍</h1><p>对于嵌入式系统而言，一个非常重要的内容就是低功耗，尽可能减少电量损耗，然后获得更多的续航时间</p><p>当然功耗越低，被关闭的功能也就越多</p><h2 id="1-1-五种运行模式"><a href="#1-1-五种运行模式" class="headerlink" title="1.1 五种运行模式"></a>1.1 五种运行模式</h2><p>CC2530有5种不同的运行模式（供电模式）：</p><p>分别为主动模式、空闲模式、PM1、PM2 和PM3。</p><p>越靠后，被关闭的功能越多，功耗也越低，PM3具有最低的功耗。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231201200510123.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231201200510123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231201200510123"></p><p>运行的影响如表8.1所示，其中还给出了稳压器和振荡器选择。</p><p><strong>主动模式</strong>是一般模式。主动模式：完全功能模式。稳压器的数字内核开启，16MHz RC振荡</p><p>器或32MHz晶体振荡器运行，或者两者都运行。32kHz RCOSC振荡器或32kHz XOSC运行。</p><p> <strong>空闲模式</strong>：除CPU 内核停止运行（即空闲外），其他功能和主动模式一样。</p><p><strong>PM1</strong>：高频晶振（16MHz或32MHz）关闭，低频晶振（32.768kHzRCOSC&#x2F;XOSC）工作，数字核心模块正常工作。</p><p> <strong>PM2</strong>：低频晶振（32.768KHz RCOSC&#x2F;XOSC ）工作, 数字核心模块关闭，系统通过 RESET,外部中断或睡眠计数器溢出唤醒。</p><p> <strong>PM3</strong>：晶振全部关闭，数字核心模块关闭，系统只能通过 RESET 或外部中断唤醒。</p><h1 id="2-低功耗控制相关寄存器"><a href="#2-低功耗控制相关寄存器" class="headerlink" title="2 低功耗控制相关寄存器"></a>2 低功耗控制相关寄存器</h1><p><strong>睡眠模式控制寄存器SLEEPCMD</strong></p><p>​可以设置我们刚刚讲到的那五种睡眠模式</p><p><strong>供电模式控制寄存器PCON</strong></p><p>​设置睡眠模式之后，还要设置供电模式</p><p><strong>睡眠计数器STx，</strong></p><p>​通过设置STx可以设置睡眠的时间长短</p><p>读睡眠定时器读的流程为：读ST0→读ST1→读ST2。</p><h1 id="3-睡眠唤醒实现方式"><a href="#3-睡眠唤醒实现方式" class="headerlink" title="3 睡眠唤醒实现方式"></a>3 睡眠唤醒实现方式</h1><p>从PM1和PM2唤醒可以通过三种方式：复位、外部中断和睡眠定时器，</p><p>从PM3唤醒可以通过两种方式：复位和外部中断。</p><p>对于复位方式，进行系统的复位，即RESET来唤醒即可，不涉及到编程。</p><p>所以编程主要涉及到外部中断和睡眠定时器唤醒</p><p>对于睡眠定时器方式，涉及到ST2、ST1和ST0寄存器。首先从这三个寄存器中读取到当前定时器的计数值，接着对该计数值进行修改（表示睡眠的时长），最后将该修改后的计数值写入到三个寄存器中，使定时器能够进行比较。对于该种方式，首先要明白，寄存器和定时器是两个独立的东西，当不读ST2、ST1和ST0寄存器时，其中始终保存一个比较值，当定时器值与寄存器值相等时发生中断，而定时器的值会在正边沿时进行一次更新。当读ST2、ST1和ST0寄存器时，会自动获取24位定时器的值</p><p>对于外部中断模式，需要根据选择的外部中断方式编写中断函数，在中断函数中，对标志位进行清零，最后将模式设置为主动模式即可。</p><h2 id="3-1-系统睡眠-定时器唤醒"><a href="#3-1-系统睡眠-定时器唤醒" class="headerlink" title="3.1 系统睡眠+定时器唤醒"></a>3.1 系统睡眠+定时器唤醒</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化休眠定时器,设定后经过指定时间自行唤醒程序如下：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSleepTimer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ST2 = <span class="number">0X00</span>;</span><br><span class="line">ST1 = <span class="number">0X0F</span>;</span><br><span class="line">ST0 = <span class="number">0X0F</span>;</span><br><span class="line">EA = <span class="number">1</span>; <span class="comment">//开中断</span></span><br><span class="line">STIE = <span class="number">1</span>; <span class="comment">//睡眠定时器中断使能0：中断禁止 1：中断使能</span></span><br><span class="line">STIF = <span class="number">0</span>; <span class="comment">//睡眠定时器中断标志 0：无中断未决 1： 中断未决</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置系统工作模式程序如下。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysPowerMode</span><span class="params">(uchar mode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mode &lt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">SLEEPCMD |= mode; <span class="comment">//设置系统睡眠模式</span></span><br><span class="line">PCON = <span class="number">0x01</span>; <span class="comment">//进入睡眠模式 ,通过中断唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PCON = <span class="number">0x00</span>; <span class="comment">//通过中断唤醒系统</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置睡眠时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_ST_Period</span><span class="params">(uint sec)</span></span><br><span class="line">&#123;</span><br><span class="line">ulong sleepTimer = <span class="number">0</span>;</span><br><span class="line">sleepTimer |= (ulong)ST1 &lt;&lt; <span class="number">8</span>;</span><br><span class="line">sleepTimer |= (ulong)ST2 &lt;&lt; <span class="number">16</span>;</span><br><span class="line">sleepTimer += ((ulong)sec * (ulong)<span class="number">32768</span>);</span><br><span class="line">ST2 = (uchar)(sleepTimer &gt;&gt; <span class="number">16</span>);</span><br><span class="line">ST1 = (uchar)(sleepTimer &gt;&gt; <span class="number">8</span>);</span><br><span class="line">ST0 = (uchar) sleepTimer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（八）看门狗</title>
      <link href="/2023/12/09/Computer_system/embedded_system/7%20%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
      <url>/2023/12/09/Computer_system/embedded_system/7%20%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-看门狗原理"><a href="#1-看门狗原理" class="headerlink" title="1 看门狗原理"></a>1 看门狗原理</h1><p>看门狗(Watch Dog Timer， WDT)是一种专门用于监测单片机程序运行状态的芯片组件。其实质是一个计数器，一般给看门狗初始一个比较大的数，</p><p>当程序开始运行后，看门狗开始倒计数。如果程序运行正常，过一段时间CPU应发出指令让看门狗复位，重新开始倒计数。</p><p>如果看门狗一直都没有收到CPU的指令，直到减到了0，就认为程序没有正常工作，将强制整个系统复位</p><h1 id="2-功能"><a href="#2-功能" class="headerlink" title="2 功能"></a>2 功能</h1><p>看门狗是在程序跑飞的情况下，将CPU自恢复的一种方式，当软件在选定的时间间隔内不能置位看门狗定时器，看门狗就复位整个系统。</p><p>看门狗可用于电噪声、电源故障或静电放电等恶劣工作环境或高可靠性要求的环境。如果系统不需要应用看门狗，则看门狗定时器可配置成间隔定时器，在选定时间间隔内产生中断</p><h1 id="3-看门狗工作模式"><a href="#3-看门狗工作模式" class="headerlink" title="3 看门狗工作模式"></a>3 看门狗工作模式</h1><p>两种工作模式</p><p>第一种 定时器模式</p><p>在定时器模式下，它就相当于普通的定时器，当达到定时间隔时会产生中断（可以在 ioCC2530.h 文件中找到其中断向量为 WDT_VECTOR）</p><p>第二种 看门狗模式</p><p>而在看门狗模式下，当达到定时间隔时，不会产生中断，取而代之的是向系统发送一个复位信号。</p><h1 id="4-看门狗控制寄存器"><a href="#4-看门狗控制寄存器" class="headerlink" title="4 看门狗控制寄存器"></a>4 看门狗控制寄存器</h1><p><strong>WDCTL</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231129173953885.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231129173953885.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231129173953885"></p><p>看门狗定时器可以工作于两个模式：<strong>第一个 定时器模式</strong>   <strong>第二个 看门狗模式</strong></p><p><strong>情况一，在一般定时器模式下设置看门狗定时器</strong>，必须把WDCTL.MODE[1:0]位设置为11。且要求看门狗计数器从0开始递增。当计数器达到选定间隔值时，CPU将IRCON2.WDTIF置1。（如果IEN2.WDTIE&#x3D;1且IEN0.EA&#x3D;1，则定时器将产生一个中断请求）</p><p>在定时器模式下，可以通过写入1 到WDCTL.CLR[0]来清除定时器内容。当定时器被清除后，计数器的内容就置为0。写入00 或01 到WDCTL.MODE[1:0]可停止定时器，并对其清零。</p><p><strong>情况二，在看门狗模式模式下设置看门狗定时器</strong>，必须设置WDCTL.MODE[1:0]位为10。</p><h1 id="5-时钟系统-及其寄存器"><a href="#5-时钟系统-及其寄存器" class="headerlink" title="5 时钟系统 及其寄存器"></a>5 时钟系统 及其寄存器</h1><p>由于看门狗本质是一个计时器，所以也要进行计时器相关的设置，比如始终的选择和频率之类的，主要通过</p><p>时钟控制命令寄存器CLKCONCMD</p><p>时钟控制状态寄存器CLKCONSTA(0x9E)</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（七）脉冲宽度调制</title>
      <link href="/2023/12/08/Computer_system/embedded_system/6%20%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/"/>
      <url>/2023/12/08/Computer_system/embedded_system/6%20%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>脉冲宽度调制以其控制简单、灵活和动态响应好的优点而</p><p>成为电工电子技术中广泛应用的控制方式，也是人们研究的热点。</p><p><strong>例：实现LED亮度调节，直流电机转速调节</strong></p><p>本质原理就是 LED灯以一定的亮暗比例时间循环，亮的占比越大，灯的亮度就越大</p><p>占空比：是指脉冲信号的通电时间与通电周期的比</p><h1 id="1-PWM调节LED灯的三种方式"><a href="#1-PWM调节LED灯的三种方式" class="headerlink" title="1 PWM调节LED灯的三种方式"></a>1 PWM调节LED灯的三种方式</h1><p><strong>1）模拟方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">LED=<span class="number">1</span>; delay(cycle*dutycycle);</span><br><span class="line">LED=<span class="number">0</span>; delay(cycle* ( <span class="number">1</span>-dutycycle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 模拟方式就通过调整亮灭后delay延迟函数进行控制</p><p><strong>2)定时器的定时中断方式(溢出中断)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定时cycle*dutycycle，定时中断发生时led=<span class="number">0</span>;再定时cycle( <span class="number">1</span>-dutycycle),定时中断发生时led=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>3）定时器的比较输出(output compare)方式</strong></p><p>Timer1&#x2F;Timer3&#x2F;Timer4的output compare模式</p><p>使用Timer比较输出实现PWM的一般步骤</p><p>1 确定Timer及通道，配置输出引脚</p><p>2 配置Timer的工作模式和计数值上限</p><p>TxCC0</p><p>3 使能Timer通道的比较输出功能，配置通道的比较值</p><p>配置TxCCTLy，TxCCyH和TxCCyL</p><p>比较输出的原理是什么？</p><p>就是调整高电平的比例，比较输出应该就是设了一个比较值，然后有3个工作方式和7个比较模式，选好工作模式和比较模式，然后引脚就能输出特定的波形，设置一个最大值，一个比较值。然后自由模式最大值是固定的不用设置</p><p>3个工作方式，就是之前讲到的</p><p> <strong>1 自由运行模式</strong>：计数器从0x0000开始，在每个活动 时钟边沿增加1，当计数器达到0xFFFF时溢出，计数器重新载入0x0000并开始新一轮的递增计数。该模式的计数周期是固定值0xFFFF，当达到最终计数 值0xFFFF时，标志位T1IF和OVFIF被设置。</p><p><strong>2.模模式</strong>：计数器从0x0000开始，在每个活动时钟边 沿增加1，当计数器达到T1CC0寄存器保存的值时 溢出，计数器又将从0x0000开始新一轮的递增计数， 模模式的计数周期可由用户自行设定。</p><p><strong>3. 正计数&#x2F;倒计数模式</strong>：计数器反复从0x0000 开始，正计数到TICC0保存的最终计数值，然后再倒计数回0x0000，当达到最终计数值时，标志位T1IF和OVFIF被设置</p><p>7个比较模式</p><h1 id="补充例程2"><a href="#补充例程2" class="headerlink" title="补充例程2"></a>补充例程2</h1><p>在模模式下T1计数器的值到达T1CC0后，不会产生溢出中断（相应的溢出标志不会置1），这点需要特别注意。和连续计数模式不同，它必须设置通道0的输出比较，而且溢出时也是通道0的中断标志，而非T1的总溢出中断标志。</p><p>模模式下获取计数值到达T1CC0中断的解决方法：</p><p>– 开启通道0的输出比较模式，在中断函数中也只有CC0的中断标志位，而不是使用溢出中断标记位。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（六）模数转换</title>
      <link href="/2023/12/07/Computer_system/embedded_system/5%20%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/12/07/Computer_system/embedded_system/5%20%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>模拟&#x2F;数字转换 (Analog to Digital Converter，简称ADC)</p><p>是将输入的模拟信号转换为数字信号。</p><p>各种被测控的物理量（如：速度、压力、温度、光照强度、磁场等）是一些连续变化的物理量，传感器将这些物理量转换成与之相对应的电压和电流就是模拟信号。单片机只能接收数字信号，要处理这些信号就必须转换成数字信号，模拟&#x2F;数字转换是数字测控系统中必须的信号转换。</p><p>原理是进行，以一定的频率采样电压值，连续采样一段时间</p><h1 id="1-CC2530的ADC模块"><a href="#1-CC2530的ADC模块" class="headerlink" title="1 CC2530的ADC模块"></a>1 CC2530的ADC模块</h1><p>CC2530的ADC模块 支持最高14位二进制 的模拟数字转换具有12位的有效数据位。</p><p>它包括一个输入多路切换器，具有8个各自可配置的通道；以及一个参考电压发生器。</p><p>转换结果通过DMA（直接内存访问）写入存储器，还具有多种运行模式。</p><p>先介绍运行模式</p><h1 id="2-ADC工作模式"><a href="#2-ADC工作模式" class="headerlink" title="2 ADC工作模式"></a>2 ADC工作模式</h1><p><strong>1 输入</strong></p><p>ADC模块的输入——从哪些端口输入</p><p>对于CC2530的ADC模块，端口P0引脚可以配置为ADC输入端，</p><p>依次为AIN0～AIN7。</p><p>可以把输入配置为<strong>单端或差分</strong>输入</p><p>在选择单端输入的情况下，通道号码0-7</p><p>在选择差分输入的情况下，通道号码8-11，差分输入包括输入对AIN0-AIN1、</p><p>AIN2-AIN3、AIN4-AIN5和AIN6-AIN7 共四对、</p><p>通道12-15分别是GND，预留通道，温度传感器，AVDD5  在应用中这个输入可以实现一个电池电压监测器的功能。</p><p>为什么要进行差分输入，差分输入方式比单端输入来说，有更强的抗干扰能力</p><p>序列ADC转换与单通道ADC转换</p><h1 id="3-ADC相关寄存器"><a href="#3-ADC相关寄存器" class="headerlink" title="3 ADC相关寄存器"></a>3 ADC相关寄存器</h1><h2 id="3-1数据寄存器"><a href="#3-1数据寄存器" class="headerlink" title="3.1数据寄存器"></a>3.1数据寄存器</h2><p>ADC有两个数据寄存器：用来存放转换结果</p><p><strong>ADCL</strong>（0xBA）-ADC数据低位寄存器、</p><p><strong>ADCH</strong>（0xBB）-ADC数据高位寄存器，</p><h2 id="3-2-控制寄存器"><a href="#3-2-控制寄存器" class="headerlink" title="3.2 控制寄存器"></a>3.2 控制寄存器</h2><p><strong>APCFG</strong></p><p>8位模拟量输入来自I&#x2F;O引脚，不必通过编程将这些引脚变为模拟输入。但是，当相应的模拟输入端在APCFG寄存器中被禁用时，此通道将被跳过。当使用差分输入时，相应的两个引脚都必须在<strong>APCFG寄存器</strong>中设置为<strong>模拟输入</strong>引脚。</p><p>APCFG寄存器描述如图所示</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240106211552376.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240106211552376.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240106211552376"></p><p>ADC还有三个控制寄存器：<strong>ADCCON1、ADCCON2和ADCCON3</strong></p><p><strong>ADCCON1</strong></p><p>ADCCON1.ST用于启动一个转换序列。当没有转换正在运行时这个位设置为高电平</p><p>ADCCON1.STSEL位选择哪个事件将启动一个新的转换序列。该选项可以选择为外部引脚P2.0上升沿或外部引脚事件，之前序列的结束事件，定时器1的通道0比较事件或ADCCON1.ST是1。</p><p><strong>ADCCON2</strong></p><p>寄存器位ADCCON2.SCH用于定义一个ADC转换序列，如果ADCCON2.SCH设置为一个小于8的值，ADC转换序列包括</p><p>从0通道开始，直到并包括所设置的通道号码。当ADCCON2.SCH设置为一个8和12之间的值，转换序列包括</p><p>从通道8开始差分输入，到ADCCON2.SCH所设置的通道号码结束。</p><p>ADCCON2.SREF用于选择参考电压。</p><p>ADCCON2.SDIV位用来选择抽取率，抽取率的设置决定分辨率和完成一个转换所需要的时间。</p><p>ADCCON2.SCH设置转换序列的最后一个通道数</p><p><strong>ADCCON3</strong></p><p>单通道ADC转换通过写ADCCON3寄存器触发，转换立即开始。</p><p>除非一个转换序列已经正在进行，在这种情况下序列一完成，单个通道的ADC转换就会被执行。</p><p>除可以设置为按序列进行ADC转换之外，CC2530的ADC模块可以编程实现任何单个通道执行一个转换，包括温度传感器（14）和AVDD5&#x2F;3（15）两个通道。</p><p>单通道ADC转换通过写ADCCON3寄存器触发，转换立即开始。除非一个转换序列已经正在进行，在这种情况下序列一完成，单个通道的ADC转换就会被执行。</p><h1 id="4-ADC初始化配置"><a href="#4-ADC初始化配置" class="headerlink" title="4 ADC初始化配置"></a>4 ADC初始化配置</h1><p>LED初始化</p><p>串口通信初始化</p><p>AD初始化</p><p>注意分辨率与精确度的区别</p><p><strong>分辨率</strong>  分辨率由比特数决定，比如16位器件，则可以表示65536个独立的数字值，那么对于1bit而言，代表着最小的电平为    $ADC电压范围× \frac{1}{65536}$</p><p><strong>精确度</strong>  是指对于给定模拟输入，实际数字输出与理论预期数字输出之间的接近度。</p><p>理论上精确度和分辨率相同，但由于实际中出现各种误差源，因而不能达到很高的精确度，比如只能16位器件只能提供12位精确度（有效数据），对于这种情况，4LSb（最低有效位）表示ADC中生成的随机噪声</p><p>电压计算公式 &#x3D;ADC&#x2F;精度*参考电压。</p><p>Value&#x3D;（ADCH×256+ADCL）×3.3&#x2F;8192。</p><p>ADC：把AD转换后得到的ADCL、ADCH做处理，将ADCL（低6位）放在低字节，ADCH（高8位）放在高字节。将一个uint16右移两位（最后两位没有用），即得到14位ADC。精度：根据所选位数，例如本任务位数选14位，精度&#x3D;2^13&#x3D;8192。</p><p>注意三个ADCCON1,2,3区别</p><p>首先通过ADCCON1寄存器将EOC标志清零。若为序列ADC转化则需要用到ADCCON2寄存器，若为单通道ADC转换则需要使用ADCCON3寄存器。通过这两个寄存器其一可以设置ADC转换的参考电压和通道的抽取率（精度）。若为ADCCON2寄存器还可以设置序列转换的范围，对于ADCCON3寄存器可以设置单个通道的转化。最后通过ADCCON1寄存器的STSEL位和ST位来启动ADC转换。</p><h1 id="5-ADC使用方式"><a href="#5-ADC使用方式" class="headerlink" title="5 ADC使用方式"></a>5 ADC使用方式</h1><h2 id="5-1-轮询方式"><a href="#5-1-轮询方式" class="headerlink" title="5.1 轮询方式"></a>5.1 轮询方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(ADCCON1&gt;=<span class="number">0x80</span>) &#123; <span class="comment">//ADCCON1.EOC,转换完毕判断</span></span><br><span class="line">LED1 = <span class="number">0</span>; <span class="comment">//转换完毕指示</span></span><br><span class="line">LED2= <span class="number">1</span>; <span class="comment">//打开数据处理指示灯</span></span><br><span class="line">temp[<span class="number">1</span>] = ADCL;</span><br><span class="line">temp[<span class="number">0</span>] = ADCH;</span><br><span class="line">adc |= (uint)temp[<span class="number">1</span>];</span><br><span class="line">adc |= ( (uint) temp[<span class="number">0</span>] )&lt;&lt;<span class="number">8</span>;</span><br><span class="line">adc&gt;&gt;=<span class="number">2</span>; <span class="comment">// ADCL[1:0]没用使用</span></span><br><span class="line">num = adc*<span class="number">3.3</span>/<span class="number">8192</span>;<span class="comment">//定参考电压为3.3V。14位分辨率</span></span><br><span class="line">adcdata[<span class="number">1</span>] = (<span class="type">char</span>)(num)%<span class="number">10</span>+<span class="number">48</span>;</span><br><span class="line">adcdata[<span class="number">3</span>] = (<span class="type">char</span>)(num*<span class="number">10</span>)%<span class="number">10</span>+<span class="number">48</span>;</span><br><span class="line">UartTX_Send_String(adcdata,<span class="number">6</span>); <span class="comment">//串口送数</span></span><br><span class="line">LED2= <span class="number">0</span>; <span class="comment">//完成数据处理</span></span><br><span class="line">delay(<span class="number">30000</span>);</span><br><span class="line">InitialAD(); <span class="comment">//启动下一次转换</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-2-中断方式"><a href="#5-2-中断方式" class="headerlink" title="5.2 中断方式"></a>5.2 中断方式</h2><p>通过设置ADCCON3启动的单次ADC转换完成时才会产生中断。 (序列ADC转换完成不会产生中断)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> vector = ADC_VECTOR</span></span><br><span class="line">__interrupt <span class="type">void</span> <span class="title function_">ADC_ISR</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">float</span> num; <span class="type">char</span> temp[<span class="number">2</span>]; uint adc=<span class="number">0</span>;</span><br><span class="line">temp[<span class="number">1</span>] = ADCL;</span><br><span class="line">temp[<span class="number">0</span>] = ADCH;</span><br><span class="line">adc |= (uint)temp[<span class="number">1</span>];</span><br><span class="line">adc |= ( (uint) temp[<span class="number">0</span>] )&lt;&lt;<span class="number">8</span>;</span><br><span class="line">adc&gt;&gt;=<span class="number">2</span>; <span class="comment">// ADCL[1:0]没用使用</span></span><br><span class="line">num = adc*<span class="number">1.25</span>/<span class="number">8192</span>;<span class="comment">//参考电压为1.25V,12位有效位</span></span><br><span class="line">adcdata[<span class="number">1</span>] = (<span class="type">char</span>)(num)%<span class="number">10</span>+<span class="number">48</span>;</span><br><span class="line">adcdata[<span class="number">3</span>] = (<span class="type">char</span>)(num*<span class="number">10</span>)%<span class="number">10</span>+<span class="number">48</span>;</span><br><span class="line">adcComplete1 = <span class="number">1</span>; <span class="comment">//设置转换完成的全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列转换和单次转换的区别</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（六）数据库规范</title>
      <link href="/2023/12/06/Computer_system/Database_system/5%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
      <url>/2023/12/06/Computer_system/Database_system/5%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-好的关系设计的特征"><a href="#1-好的关系设计的特征" class="headerlink" title="1 好的关系设计的特征"></a>1 好的关系设计的特征</h1><p>好的设计</p><p>​要避免冗余</p><p>​要避免更新、删除或者插入异常</p><p>那么为了在设计中进行好的设计</p><p>就应该合理的分解表格</p><p>但是有些时候分解会造成一些不好的影响——会产生有损分解或者无损分解</p><p>所什么是无损分解，什么是有损分解？</p><p><strong>判断方式一</strong></p><p>对于关系R，分解为R1和R2</p><p>讲两个分解后的表R1，R2做自然连接，如连接后和原来表R相等，则是无损分解。</p><p>如果自然连接后产生了原理表R没有的元组，则为有损分解</p><p><strong>判断方式二</strong></p><p>对于关系R，分解为R1和R2</p><p>如果R1和R2的交集是R1或者R2其中之一的超键则为无损分解，否则为有损分解</p><h1 id="2-函数依赖关系"><a href="#2-函数依赖关系" class="headerlink" title="2 函数依赖关系"></a>2 函数依赖关系</h1><p>函数依赖  Functional Dependencies，就是初中高中学习的判断一个对应关系是否为函数</p><p>很简单，就是一个x对应唯一一个y</p><p>需要先着重理解两个概念</p><p><strong>平凡函数依赖</strong>  Trivial Functional Dependencies</p><p>如果x-&gt;y，即y是x的函数，同时y又是x的子集，那么就说x到y是平凡函数依赖</p><p>平凡的含义就是显而易见的，为什么叫显而易见呢？子集我们可以理解为信息的一部分，信息相对原来变少了，那么因为知道更多的信息肯定可以推出更少的信息的，所以这个x-》y的函数依赖关系是显而存在的</p><p>举这样一个例子</p><p>（学生ID，姓名）-&gt;（姓名）</p><p>其中x是（学生ID，姓名），y是（姓名）</p><p>那么如果知道了学生ID，姓名，肯定可以得到唯一的姓名</p><p><strong>非平凡函数依赖</strong></p><p>而如果y不是x的子集，那么就不那么明显了，所以是非平凡函数依赖</p><p>再理解两个概念，部分函数依赖和完全函数依赖</p><p>理解部分函数依赖和完全函数依赖</p><p><strong>部分函数依赖（Partial Functional Dependency）</strong>（候选码）： 部分函数依赖是指在关系中，</p><p>比如x-&gt;y的函数依赖，y只依赖x的一部分，那么则是部分函数依赖，x还可以再拆分</p><p>举个例子，假设有一个包含以下属性的关系表：</p><ul><li>学生ID（StudentID）</li><li>课程号（CourseID）</li><li>学生姓名（StudentName）</li></ul><p>（学生ID，课程号）是可以推出学生姓名的</p><p>而只有学生ID也可以推出决定学生姓名，所以可以继续拆分，为部分函数依赖，换句话说x的子集也能推出决定右边</p><p><strong>完全函数依赖（Full Functional Dependency）</strong>（超码）：完全函数依赖是指在关系中，</p><p>比如x-&gt;y的函数依赖，y依赖x的全部，那么则是全部函数依赖，x不可以再拆分</p><p>换句话说x的子集不能推出决定右边</p><p>包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）<br>不包含在任何候选码中的属性称为非主属性（Nonprime attribute）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231111114502265.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231111114502265.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231111114502265"></p><p>总结来看：我们更期望非平凡函数依赖和完全函数依赖</p><p><strong>函数依赖的闭包</strong> Closure of Functional Dependencies</p><p>函数依赖闭包表示为$F^+$</p><p>函数依赖的闭包是一个属性集合，它包含了一个给定的属性集合关于另一个属性集合的所有可能依赖，所有的可能的函数关系</p><p>如何求函数依赖的闭包</p><p>利用</p><p><strong>Armstrong’s Axioms 阿姆斯特朗公理</strong></p><p>阿姆斯特公理有三条</p><ol><li>自反率（Reflexivity Axiom）： 如果X是一个属性集合，那么X的任何子集都可以推出X，表示为X → X。这意味着一个属性集合的所有子集都具有相同的函数依赖。</li><li>扩展律（Augmentation Axiom）： 如果X → Y，并且Z是一个属性集合，那么XZ → YZ。这个公理表示如果一个属性集合X决定另一个属性集合Y，那么在X的基础上添加属性Z也会决定Y。</li><li>传递律（Transitivity Axiom）： 如果X → Y和Y → Z，那么X → Z。这个公理表示如果一个属性集合X决定另一个属性集合Y，同时Y又决定另一个属性集合Z，那么X也会决定Z。</li></ol><p>另外的</p><ol><li><p>Union Rule（并集规则）： Union Rule 允许我们将两个函数依赖合并成一个更大的函数依赖。规则表述如下：</p><p>如果 X → Y1 和 X → Y2，那么 X → (Y1 ∪ Y2)。</p><p>这意味着如果属性集合 X 决定属性集合 Y1，同时 X 也决定属性集合 Y2，那么 X 也决定属性集合 (Y1 ∪ Y2)，也就是 Y1 和 Y2 的并集。</p></li><li><p>Splitting Rule（拆分规则）： Splitting Rule 允许我们拆分函数依赖，将一个函数依赖分成两个更小的函数依赖。规则表述如下：</p><p>如果 X → (Y1 ∪ Y2)，那么 X → Y1 和 X → Y2。</p><p>这意味着如果属性集合 X 决定属性集合 (Y1 ∪ Y2)，那么 X 也分别决定属性集合 Y1 和属性集合 Y2。这可以用于将一个大的函数依赖分解成多个小的函数依赖。</p></li><li><p>Pseudotransitivity Rule（伪传递规则）： Pseudotransitivity Rule 允许我们在两个已知的函数依赖关系之间推导出一个新的函数依赖。规则表述如下：</p><p>如果 X → Y1 和 Y1Z → Y2，那么 XZ → Y2。</p><p>这意味着如果属性集合 X 决定属性集合 Y1，同时 Y1Z 决定属性集合 Y2，那么属性集合 XZ 也决定属性集合 Y2。这个规则有点类似于传递性，但不完全相同，因此称为伪传递规则。</p></li></ol><p>通过上面的，我们可以求得一个函数依赖关系的闭包，我从网上找到了一道题，但感觉求这个意义不大</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228170252613.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228170252613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228170252613" style="zoom:50%;" /><h1 id="3-Normal-Forms-规范形式"><a href="#3-Normal-Forms-规范形式" class="headerlink" title="3 Normal Forms 规范形式"></a>3 Normal Forms 规范形式</h1><h2 id="3-1-一二三范式"><a href="#3-1-一二三范式" class="headerlink" title="3.1 一二三范式"></a>3.1 一二三范式</h2><h3 id="3-1-1-基本概念"><a href="#3-1-1-基本概念" class="headerlink" title="3.1.1 基本概念"></a>3.1.1 基本概念</h3><p>规范形式（Normalization Forms，通常缩写为NF）是数据库设计中的一组标准，用于确保数据库表的结构满足一定的标准，以提高数据的一致性、避免数据冗余，并提高数据库性能。最常见的规范形式包括第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。</p><ol><li><strong>第一范式（1NF）</strong>：<ul><li>第一范式要求数据库表中的每个列都包含不可分割的、原子的数据，也就是每个单元格只包含一个值。此外，表中的每个行都应具有唯一的标识，通常通过一个主键来实现。1NF消除了重复的列和组合列。</li></ul></li><li><strong>第二范式（2NF）</strong>：<ul><li>第二范式要求在1NF的基础上，确保非主键属性完全依赖于主键。这意味着非主键属性不会部分依赖主键，也就是没有部分函数依赖。如果存在部分函数依赖，需要将表进行拆分，以确保每个非主键属性都依赖于整个主键。通常，2NF适用于具有复合主键的表。</li></ul></li><li><strong>第三范式（3NF）</strong>：<ul><li>第三范式要求在2NF的基础上，消除传递依赖。传递依赖指的是非主键属性依赖于主键以外的非主键属性。如果一个非主键属性依赖于另一个非主键属性，而这个属性又依赖于主键，就存在传递依赖。为了满足3NF，需要将数据库表进行拆分，以确保每个非主键属性只依赖于主键。</li></ul></li></ol><p>实际上3NF达到的效果就是 尽可能保证 非主键属性完全依赖于主建且只依赖于主键</p><p>规范形式的目标是减少数据冗余、提高数据一致性，并简化数据库结构，以便更容易维护和查询数据。虽然1NF、2NF和3NF是最常见的规范形式，但还有更高级别的规范形式，如巴斯－科德范式（BCNF）和第四范式（4NF），它们进一步强化了数据库设计的要求。</p><p>总结</p><p>第一范式：简单说 列不能再分</p><p>第二范式：简单说 建立在第一范式基础上，消除部分依赖</p><p>第三范式：简单说 建立在第二范式基础上，消除传递依赖。</p><p>BCNF是对3NF的改进，消除了对主键子集的依赖</p><h3 id="3-1-2-判断是否满足3NF"><a href="#3-1-2-判断是否满足3NF" class="headerlink" title="3.1.2 判断是否满足3NF"></a>3.1.2 判断是否满足3NF</h3><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228173731436.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228173731436.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228173731436"></p><h2 id="3-2-BCNF"><a href="#3-2-BCNF" class="headerlink" title="3.2 BCNF"></a>3.2 BCNF</h2><h3 id="3-2-1-基本概念"><a href="#3-2-1-基本概念" class="headerlink" title="3.2.1 基本概念"></a>3.2.1 基本概念</h3><p><code>Boyce-Codd Normal Form</code>（巴斯-科德范式（BCNF））是<code>Third Normal Form</code> 的一种扩展，因此有时候也被称为<code>3.5范式</code>。</p><ul><li>Boyce-Codd Normal Form（巴斯-科德范式）</li><li>在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）</li><li>巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。</li></ul><h3 id="3-2-2-判断是否满足BCNF"><a href="#3-2-2-判断是否满足BCNF" class="headerlink" title="3.2.2 判断是否满足BCNF"></a>3.2.2 判断是否满足BCNF</h3><p>判断每一个是否是超码，有一个不是就不是</p><p>a is a superkey for R</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171850258.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171850258.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228171850258"></p><p>因为Sno→Sdept中Sno不是超码<br>Sdept→Mname中Sdept不是超码</p><h3 id="3-2-3-分解得到BCNF"><a href="#3-2-3-分解得到BCNF" class="headerlink" title="3.2.3 分解得到BCNF"></a>3.2.3 分解得到BCNF</h3><p>怎么分解得到呢？</p><p>对于x-&gt;y</p><p>分解为x并y和R-（y-x）</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171802264.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171802264.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228171802264" style="zoom:80%;" /><h1 id="4-属性集闭包和正则覆盖"><a href="#4-属性集闭包和正则覆盖" class="headerlink" title="4 属性集闭包和正则覆盖"></a>4 属性集闭包和正则覆盖</h1><h2 id="4-1-属性集闭包求法"><a href="#4-1-属性集闭包求法" class="headerlink" title="4.1 属性集闭包求法"></a>4.1 属性集闭包求法</h2><p>ps：可以理解为X+表示所有X可以决定的属性</p><p>求取属性集闭包的步骤：</p><p>设要求的闭包属性集是Y，把Y初始化为X.<br>检查函数依赖集F中的每个函数依赖A-&gt;B,如果属性集A中的所有属性都在Y中，而B中有属性不在Y中，则将其加入到Y中。<br>重复第二步，直到没有属性可以添加到Y中为止。最后得出的Y就是X+。<br><em>例子：</em>设有关系模式R（M,N,X,Y,Z）其依赖集F&#x3D;{M-&gt;H,H-&gt;Z,Y-&gt;Z,N-&gt;Y,Z-&gt;M}。求M+,MH+<br>第一步：设要求的闭包属性集是Y，把Y初始化为X.<br>令X&#x3D;{M},我们先看M-&gt;H,由于函数依赖M-&gt;H左边的所有属性都在X中，而右边H不在X中，所以可以把H添加到X 中，此时X&#x3D;{M，H}</p><p>然后按照顺序我们再看H-&gt;Z，我们不难发现函数依赖H-&gt;Z左边的所有属性都在X中,右边的属性Z又不在X中，仍旧添加，这时X&#x3D;{M，H，Z}</p><p>下一个</p><p>Y-&gt;Z，可以发现Y属性不在X中，条件不满足<br>N-&gt;Y，可以发现N属性不在X中，条件不满足<br>Z-&gt;M,Z属性在X中条件满足，但右边M也在X中条件不满足。</p><p>属性判断完 ，那么属性M的闭包：M+&#x3D;MHZ。</p><h2 id="4-2-属性集闭包应用"><a href="#4-2-属性集闭包应用" class="headerlink" title="4.2 属性集闭包应用"></a>4.2 属性集闭包应用</h2><h3 id="4-2-1-测试某个属性集是否为超键"><a href="#4-2-1-测试某个属性集是否为超键" class="headerlink" title="4.2.1 测试某个属性集是否为超键"></a>4.2.1 测试某个属性集是否为超键</h3><p>他的闭包如果包含所有属性，则为超集</p><h3 id="4-2-2-测试一个属性是否无关属性"><a href="#4-2-2-测试一个属性是否无关属性" class="headerlink" title="4.2.2 测试一个属性是否无关属性"></a>4.2.2 测试一个属性是否无关属性</h3><p>右边多余</p><p>如果前面的属性集闭包可以包括后面的，即可以删除无关的</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228172420876.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228172420876.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228172420876"></p><p>左边多余</p><p>还可以计算函数依赖闭包，测试函数依赖是否成立</p><p><a href="https://blog.csdn.net/qq_40177015/article/details/111590534">范式判断的三个步骤以及各个范式标准(1NF,2NF,3NF,BCNF,4NF)_如何判断1nf2nf3nf和bcnf-CSDN博客</a></p><h2 id="4-3正则覆盖Canonical-Cover"><a href="#4-3正则覆盖Canonical-Cover" class="headerlink" title="4.3正则覆盖Canonical Cover"></a>4.3正则覆盖Canonical Cover</h2><p>一.<strong>使用合并律将所有左部相同的函数依赖合并成一个</strong></p><p>设有一函数依赖集F，其中有{A→B，A→E，……}，则将这两个函数依赖合并为{A→BE，……}</p><p>二.<strong>在合并后的函数依赖集中寻找一个无关属性，将它删除</strong></p><p>重复一二，直到每个元素都不是无关元素，无法再删，故解得正则覆盖</p><p>例题可以参考 </p><p><a href="https://blog.csdn.net/weixin_44356079/article/details/108341351">正则覆盖的求法与判断属性是否冗余-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（五）通信协议</title>
      <link href="/2023/12/06/Computer_system/embedded_system/4%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/12/06/Computer_system/embedded_system/4%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>这节我们讲串行通信方式UART，SPI，I2C</p><p>先来看一下常见的通信方式分类方法</p><p><strong>串行or并行？</strong></p><p>​串行通信   一次只能发送一位，要发送8次才能发送一个字节。</p><p>​并行通信   通信时数据的各个位同时传送，可以实现字节为单位通信，但是通信线多占用资源多，成本高。</p><p>**同步or异步？ **</p><p>​同步通信：所有设备使用一个共同的时钟信号，发送和接收双方严格按照该时钟信号处理数据的发送和接收。同步通信的优点是数据传输速率高，缺点是要求发送时钟和接收时钟保持严格同步。 SPI和I2C属于同步通信。</p><p>​异步通信：异步通信中，每个设备都有自己的时钟信号，通信双方的时钟频率保持一致。异步通信以字符为单位进行数据传送，每一个字符均按照固定的格式传送，被称为帧，即串行异步通信一次传送一个帧。UART属于串行异步通信</p><p>​</p><h1 id="0-串口通信协议"><a href="#0-串口通信协议" class="headerlink" title="0 串口通信协议"></a>0 串口通信协议</h1><p>串口通信</p><p>​串口通信，顾名思义也就是利用串行接口进行通信。串口通信和串行通信的区别在于：串行通信是一种概念，串口通信是一种是实现串行通信的具体的通信手段。</p><p>​串口通信连接包括两根线，发送和接受双方交叉连接</p><p>​一个RXD（Receive Data，RXD），表示接收数据</p><p>​一个TXD（Transmit Data，RXD），表示发送数据</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240106103135169.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240106103135169.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240106103135169"></p><h1 id="1-通用异步收发传输器-UART"><a href="#1-通用异步收发传输器-UART" class="headerlink" title="1 通用异步收发传输器 UART"></a>1 通用异步收发传输器 UART</h1><p>串行通信，异步通信，既可以半双工也可以全双工</p><p>那么实际传输过程中，串口通信是一帧一帧组成的。每一帧数据由起始位（低电平）、数据位、奇偶校验位（可选）、停止位（高电平）组成</p><h2 id="1-1-串口配置"><a href="#1-1-串口配置" class="headerlink" title="1.1 串口配置"></a>1.1 串口配置</h2><p>而通信前，需要进行配置协商，需要配置的量有</p><p>​串口号</p><p>​波特率：波特率必须一致，是传输速率，每秒传多少码元</p><p>​数据位：设置数据位有几位</p><p>​停止位：设置停止位几位</p><p>​校验位：设置是否有校验位</p><p>​流控制</p><p>这里有一个概念，叫做波特率</p><p>波特率 vs 比特率</p><p>• 波特率表示每秒钟传送的码元符号的个数，它用单位时间内载波调制状态改变的次数来表示。单位：码元&#x2F;s，所以它与比特率是不同的概念</p><p>• 比特率表示每秒钟通过信道传输的信息量，也就是每秒钟传送的二进制位数。 单位：bit&#x2F;s、比特&#x2F;秒</p><p>• 不同的调制方法可在一个码元上负载多个比特信息。比特率&#x3D;波特率*单个调制状态对应的二进制位数</p><p>• 对于二进制的信号，码元速率和信息速率在数值上是相等的。 因此，对于串口来说，比特率&#x3D;波特率</p><p>• 但要注意：这里的比特率并不是应用层的有效数据传输率，因为开始位、停止位、校验位占了开销。</p><h2 id="1-2-串口初始化"><a href="#1-2-串口初始化" class="headerlink" title="1.2 串口初始化"></a>1.2 串口初始化</h2><p><strong>1 时钟速率配置</strong></p><p>时钟控制命令寄存器CLKCONCMD</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009143452186.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009143452186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231009143452186"></p><p>举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLKCONCMD &amp;=<span class="number">0x80</span>; <span class="comment">//时钟频率为32ＭＨＺ</span></span><br></pre></td></tr></table></figure><p>使用UART之前的引脚配置步骤</p><p> <strong>2 功能选项位置配置</strong></p><p>使用寄存器PERCFG</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009143715239.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009143715239.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231009143715239"></p><p>举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERCFG=<span class="number">0x00</span>;</span><br></pre></td></tr></table></figure><p><strong>3 使能引脚的外设功能 -USART功能</strong></p><p>P0SEL寄存器</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009144625957.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009144625957.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231009144625957"></p><p><strong>4  确定多功能的优先级</strong></p><p>P2DIR寄存器</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009144444119.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009144444119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231009144444119"></p><p>P2DIR&amp;&#x3D; ~0XC0; &#x2F;&#x2F;P0优先作为串口0</p><p><strong>5 使能USARTx的UART模式</strong></p><p>U0CSR寄存器  &#x2F;&#x2F;UART模式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231021221049756.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231021221049756.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231021221049756"></p><p>U0GCR寄存器  &#x2F;&#x2F;baud_e</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231021220750715.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231021220750715.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231021220750715"></p><p>U0CSR |&#x3D; 0x80; &#x2F;&#x2F;UART模式</p><p>U0GCR |&#x3D; 10;   &#x2F;&#x2F;baud_e</p><p>没有用到U0UCR</p><p><strong>6 波特率设置</strong></p><p>U0BAUD寄存器</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009144900868.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231009144900868.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231009144900868"></p><p><strong>7 初始化中断标志位</strong></p><p>UTX0IF寄存器</p><p><strong>8 使能总中断</strong></p><p>1 确定PIN</p><p>2 使能引脚外设功能</p><p>3 确定功能选项位置，确定多功能的优先级（可选）</p><p>4 使能USARTx的UART模式</p><p>寄存器USARTx</p><p>寄存器UxCSR</p><p>UxGCR</p><h2 id="1-3-串口发送和接收方式"><a href="#1-3-串口发送和接收方式" class="headerlink" title="1.3 串口发送和接收方式"></a>1.3 串口发送和接收方式</h2><h3 id="1-3-1-轮询方式发送"><a href="#1-3-1-轮询方式发送" class="headerlink" title="1.3.1 轮询方式发送"></a>1.3.1 轮询方式发送</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UartState == UART0_TX)              <span class="comment">//发送状态 </span></span><br><span class="line">        &#123;                         </span><br><span class="line">            U0CSR &amp;= ~<span class="number">0x40</span>;                    <span class="comment">//禁止接收 </span></span><br><span class="line">            UartSendString(RxData, count);     <span class="comment">//发送已记录的字符串。</span></span><br><span class="line">            U0CSR |= <span class="number">0x40</span>;                     <span class="comment">//允许接收 </span></span><br><span class="line">            UartState = UART0_RX;              <span class="comment">//恢复到接收状态 </span></span><br><span class="line">            count = <span class="number">0</span>;                         <span class="comment">//计数清0</span></span><br><span class="line">            <span class="built_in">memset</span>(RxData, <span class="number">0</span>, SIZE);           <span class="comment">//清空接收缓冲区</span></span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure><h3 id="1-3-2-中断方式发送"><a href="#1-3-2-中断方式发送" class="headerlink" title="1.3.2 中断方式发送"></a>1.3.2 中断方式发送</h3><p>每个USART都有两个中断：</p><p>– 发送数据完成中断(URXxIF) </p><p>– 接收数据完成中断(UTXxIF)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEN2 |=<span class="number">0x04</span>;  <span class="comment">//开USART0发送中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vector = UTX0_VECTOR</span></span><br><span class="line">__interrupt <span class="type">void</span> <span class="title function_">UART0TX_ISR</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">txNext=<span class="number">1</span> ; </span><br><span class="line">UTX0IF = <span class="number">0</span>; <span class="comment">//清中断标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-查询方式接收"><a href="#1-3-3-查询方式接收" class="headerlink" title="1.3.3 查询方式接收"></a>1.3.3 查询方式接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UartState == UART0_RX)              <span class="comment">//接收状态 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">while</span>(URX0IF==<span class="number">0</span>);</span><br><span class="line">  URX0IF=<span class="number">0</span>;</span><br><span class="line">  RxBuf = U0DBUF;  </span><br><span class="line">  <span class="keyword">if</span>(RxBuf != <span class="number">0</span>) </span><br><span class="line">  &#123;                 </span><br><span class="line">        <span class="keyword">if</span>((RxBuf != <span class="string">&#x27;#&#x27;</span>)&amp;&amp;(count &lt; <span class="number">50</span>))<span class="comment">//以&#x27;＃&#x27;为结束符,一次最多接收50个字符            </span></span><br><span class="line">            RxData[count++] = RxBuf; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">50</span>)             <span class="comment">//判断数据合法性，防止溢出</span></span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">0</span>;              <span class="comment">//计数清0</span></span><br><span class="line">                <span class="built_in">memset</span>(RxData, <span class="number">0</span>, SIZE);<span class="comment">//清空接收缓冲区</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                UartState = UART0_TX;  <span class="comment">//进入发送状态 </span></span><br><span class="line">        &#125;</span><br><span class="line">        RxBuf  = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-中断方式接收"><a href="#1-3-4-中断方式接收" class="headerlink" title="1.3.4 中断方式接收"></a>1.3.4 中断方式接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEN0 |=<span class="number">0x84</span>;  <span class="comment">//开接收中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vector = URX0_VECTOR</span></span><br><span class="line">__interrupt <span class="type">void</span> <span class="title function_">UART0RX_ISR</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> RxBuf = U0DBUF; <span class="comment">//取出接收到字节</span></span><br><span class="line"> URX0IF = <span class="number">0</span>; <span class="comment">//清中断标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-串行外设接口-SPI"><a href="#2-串行外设接口-SPI" class="headerlink" title="2 串行外设接口 SPI"></a>2 串行外设接口 SPI</h1><p>串行通信，全双工，同步通信</p><h2 id="2-1-标准的四线SPI接口"><a href="#2-1-标准的四线SPI接口" class="headerlink" title="2.1 标准的四线SPI接口"></a>2.1 标准的四线SPI接口</h2><p>UART只有两根线，而SPI要四根线</p><p>– SSEL：片选，也写做SSN，从设备片选使能信号。<br>– SCLK：时钟，也写作SCK，由主机产生，和SCL类似<br>– MOSI：主机输出从机输入，Master Output&#x2F;Slave Input，主机给从机发送指令或<br>者数据的通道。<br>– MISO：主机输入从机输出，Master Input&#x2F;Slave Output，主机读取从机的状态或<br>者数据的通道</p><p>Master-Slave</p><p>– SPI通信的参与方中只有一端提供时钟，称为Master,其他为Slave</p><p>– SPI通信可以一个Master,多个Slave, 通过片选信号选择当前通信的Slave设备</p><h2 id="2-2-SPI的四种模式"><a href="#2-2-SPI的四种模式" class="headerlink" title="2.2 SPI的四种模式"></a>2.2 SPI的四种模式</h2><p>CPOL：时钟极性，CPOL&#x3D;1，表示空闲状态为高电平，CPOL&#x3D;0，表示空闲状态为低电平,就是不处于发送状态的时候是什么电平</p><p>CPHA：时钟相位，CPHA&#x3D;1 表示数据的输出是在第一个时钟周期的第一个沿，CPHA&#x3D;0，表示数据的采样是在第一个时钟周期的第一个沿</p><p>数据的输出和数据的采样的区别</p><p>就是这样的</p><p>首先数据传输的时候肯定会有一个发送方（主机）和一个接收方（从机）</p><p>他们（发送方和接收方）俩在我们这门课里是通过一条线相连的</p><p>发送方一个比特一个比特的发送，发送1 的时候将线上的电平置位高电平，发送0 的时候将线上的电平置位低电平（也就是我们的数据输出，数据输出可以理解为将电线上电平进行调整的过程）</p><p>接收方一个比特一个比特的接收（也就是我们的数据采样，数据采样就可以理解为接收方获得线上此时的电平高低，高电平则收到1，低电平则收到0</p><h2 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h2><p><strong>1 引脚配置</strong></p><p>• Slave模式中，四条线都配置为外设功能</p><p>• Master模式中，MOSI, MISO, and SCK配置为外设功能，SSN配置为GPIO功能(output)</p><p>寄存器PERCFG</p><p>PxSEL</p><p>PxDIR</p><p><strong>2 配置SPI时钟的波特率</strong></p><p>在UxBAUD中配置BAUD_M</p><p>在U型GCR中配置BAUD_E</p><p>3 <strong>配置SPI的 Master或SPI Slave模式</strong></p><p>用UxCSR寄存器</p><p>4 <strong>配置时钟极性、时钟相位、Bit顺序</strong></p><p>UxGCR.CPHA和UxGCR.CPOL </p><h2 id="2-4-发送和接收"><a href="#2-4-发送和接收" class="headerlink" title="2.4 发送和接收"></a>2.4 发送和接收</h2><h3 id="Master向Slave传输数据"><a href="#Master向Slave传输数据" class="headerlink" title="Master向Slave传输数据"></a>Master向Slave传输数据</h3><p>比如 CC2530向液晶屏传输信息</p><h3 id="Slave向Master传输数据"><a href="#Slave向Master传输数据" class="headerlink" title="Slave向Master传输数据"></a>Slave向Master传输数据</h3><p>比如外界向CC2530传输信息</p><h3 id="液晶屏接口"><a href="#液晶屏接口" class="headerlink" title="液晶屏接口"></a>液晶屏接口</h3><p>SPI液晶屏是典型应用</p><h1 id="3-I2C总线接口-I2C"><a href="#3-I2C总线接口-I2C" class="headerlink" title="3  I2C总线接口 I2C"></a>3  I2C总线接口 I2C</h1><p>需要两线式 串行总线，可以发送和接收数据</p><p>从应用上来讲，UART通信多用于板间通信，I2C多用于板内通行</p><p>I2C总线组成线与的关系，任何一个器件都可以拉低电平</p><p>I2C总线可以并联多个器件</p><p>I2C总线有起始信号，数据传输和停止信号</p><h2 id="3-1-通信时序解析"><a href="#3-1-通信时序解析" class="headerlink" title="3.1 通信时序解析"></a>3.1 通信时序解析</h2><p><strong>起始信号</strong> SCL为高电平期间，SDA由高电平向低电平变化时产生一个下降沿</p><p><strong>数据传输</strong>  MSB first，SCL是低电平，才可以改变数据线SDA，输出要发送的数据的一位，SCL在高电平的时候，SDA绝对不可以变化，每个字节跟了一个<strong>应答位</strong>（拉低SDA即输出“0”）</p><p><strong>停止信号</strong> SCL为高电平期间，SDA由低电平向高电平变化产生一个上升沿</p><h2 id="3-2-寻址及其示例"><a href="#3-2-寻址及其示例" class="headerlink" title="3.2  寻址及其示例"></a>3.2  寻址及其示例</h2><p>​<strong>发送方</strong>：7位地址+1位读写位，其中高四位是厂商固定设备ID，低三位取决于具体电路设计，最后1位代表是读1还是写0</p><p>​<strong>接收方</strong>：回应一个ACK</p><h2 id="3-3通信速率"><a href="#3-3通信速率" class="headerlink" title="3 3通信速率"></a>3 3通信速率</h2><p>I2C通信分为低速模式100kbit&#x2F;s、快速模式400kbit&#x2F;s和高速模式3.4Mbit&#x2F;s。</p><h2 id="3-4-传送和接收-读写数据"><a href="#3-4-传送和接收-读写数据" class="headerlink" title="3.4 传送和接收 读写数据"></a>3.4 传送和接收 读写数据</h2><p>单字节读，多字节读</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（五）数据库设计</title>
      <link href="/2023/12/05/Computer_system/Database_system/4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/12/05/Computer_system/Database_system/4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/633814658">ER 图是什么？这一篇让你搞懂 ER 图！ - 知乎 (zhihu.com)</a></p><p>数据库设计核心就是</p><p>1 理解用户需求</p><p>2 使用E-R关系模型，绘制E-R图</p><p>3 将E-R关系模型转换为数据库表</p><p>本节核心在第二部分到第三部分</p><h1 id="1-实体关系模型-ER模型ER-model"><a href="#1-实体关系模型-ER模型ER-model" class="headerlink" title="1 实体关系模型 ER模型ER model"></a>1 实体关系模型 ER模型ER model</h1><h2 id="1-1-E-R模型结构"><a href="#1-1-E-R模型结构" class="headerlink" title="1.1 E-R模型结构"></a>1.1 E-R模型结构</h2><p>E-R模型实际上是由多个实体集（含有不同属性）和联系集组成</p><h3 id="1-1-1-实体和实体集"><a href="#1-1-1-实体和实体集" class="headerlink" title="1.1.1 实体和实体集"></a>1.1.1 实体和实体集</h3><p><strong>实体 Entity</strong>    是一个物体，客观存在并且相互区别</p><p>​比如一个学生，一个公司</p><p><strong>实体集合 Entity Sets</strong> 具有相同属性的实体的集合</p><p>​比如一群学生，一系列公司</p><h3 id="1-1-2-属性"><a href="#1-1-2-属性" class="headerlink" title="1.1.2 属性"></a>1.1.2 属性</h3><p><strong>属性 Attributes</strong></p><p>​比如ID，姓名，这些属性能够区别不同的实体</p><p>​就好比我们每个人都有自己的特征，这些特征区分了不同的实体</p><p>除了基本属性还有如下一些属性概念需要了解</p><p><strong>简单属性 Simple 和复合属性 composite</strong></p><ul><li>简单属性：不可再拆分，如数学成绩是一个简单属性</li><li>复合属性：可以再拆分，即属性的嵌套组合，如名字这个属性可以拆分为姓这个属性和名这个属性</li></ul><p><strong>单值属性 Single-valued和多值属性  multi-valued</strong></p><ul><li>单值属性：即只能是一个的属性，如一个人性别值只能是一个男或女 （排除个别特殊现象哈哈哈）</li><li>多值属性：即可能有多个值的属性，如电话号码可以有多个</li></ul><p><strong>派生属性  Derived attributes</strong> </p><p>​可以从一个已知的属性的值推理出来，比如知道出生可以退出年龄</p><p>​所以年龄就是一个派生属性</p><p><strong>描述属性 descriptive attributes</strong></p><p>描述属性一般都是给关系集合的，</p><p>如学生实体集合Student和考试实体集合section通过take（参加）这一个关系集合联系起来，那么take这个关系集合可以用grade成绩这一属性来描述</p><h3 id="1-1-3-关系集合"><a href="#1-1-3-关系集合" class="headerlink" title="1.1.3 关系集合"></a>1.1.3 关系集合</h3><p><strong>关系 Relationship</strong>  在一些实体中的关系</p><p><strong>关系集合 Relationship Sets</strong>  相同类型的关系的集合</p><p>关系集合往往要建立多个实体集的关系</p><p><strong>递归关系集合 Recursive relationship set</strong> </p><p>​同一实体集以不同的角色多次参与关系集。</p><p><strong>二元关系</strong></p><p>​只包含两个实体集的关系</p><p><strong>非二元关系集合</strong></p><p>​含超过两个实体集的关系</p><h2 id="1-2-ER关系图绘制"><a href="#1-2-ER关系图绘制" class="headerlink" title="1.2 ER关系图绘制"></a>1.2 ER关系图绘制</h2><p>E-R diagram  ER关系图</p><h3 id="1-2-1-实体集绘制"><a href="#1-2-1-实体集绘制" class="headerlink" title="1.2.1 实体集绘制"></a>1.2.1 实体集绘制</h3><p>1 矩形表示一个实体集，矩形上方写实体集的名字</p><p>2 实体集的属性一个一个列在矩形框内，用下横线标识主键</p><p>举例如下 Student表的关系图绘制</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111215170.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111215170.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221111215170"></p><h3 id="1-2-2-关系集绘制"><a href="#1-2-2-关系集绘制" class="headerlink" title="1.2.2 关系集绘制"></a>1.2.2 关系集绘制</h3><p>1 用一个菱形方块代表关系集，连接多个实体集矩形</p><p>举例如下 advisor代表一个关系集</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111620929.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111620929.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221111620929"></p><p>2 上面讲到描述性属性，用虚线表示，如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221112506608.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221112506608.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221112506608"></p><p>上面我们讲完了实体集的一些初步介绍，接下来重点讲其中一些部分</p><h1 id="2-映射基数-Mapping-Cardinalities"><a href="#2-映射基数-Mapping-Cardinalities" class="headerlink" title="2  映射基数 Mapping Cardinalities"></a>2  映射基数 Mapping Cardinalities</h1><p>Mapping Cardinalities 映射基数    表示另一个实体可以通过关系集与之关联的实体数。</p><p>有以下几种类型</p><p>一对一，一对多，多对一，多对多</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231217192825529.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231217192825529.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231217192825529"></p><h2 id="2-1-映射基数类型"><a href="#2-1-映射基数类型" class="headerlink" title="2.1 映射基数类型"></a>2.1 映射基数类型</h2><h3 id="2-1-1-一对一"><a href="#2-1-1-一对一" class="headerlink" title="2.1.1 一对一"></a>2.1.1 一对一</h3><p>一对一 one to one：一个导师最多指导一个学生，一个学生最多被一个导师指导。说明导师可以不指导学生，学生也可以单干。</p><p>绘制E-R图如下 左右各一个箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113358521.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113358521.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113358521"></p><h3 id="2-1-2-一对多"><a href="#2-1-2-一对多" class="headerlink" title="2.1.2 一对多"></a>2.1.2 一对多</h3><p>一对多 one to many：一个导师可以指导任意多个学生，一个学生至多被一个导师指导。</p><p>绘制E-R图如下 只有one的那一侧有箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113429002.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113429002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113429002"></p><h3 id="2-1-3-多对一"><a href="#2-1-3-多对一" class="headerlink" title="2.1.3 多对一"></a>2.1.3 多对一</h3><p>多对一 many to one：一个导师至多指导一个学生，一个学生可以被任意个导师指导。</p><p>绘制E-R图如下 只有one的那一侧有箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143036766.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143036766.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221143036766"></p><h3 id="2-1-4-多对多"><a href="#2-1-4-多对多" class="headerlink" title="2.1.4 多对多"></a>2.1.4 多对多</h3><p>多对多 many to many：一个导师可以指导任意学生，一个学生可以被任意多个导师指导。<br>说明导师可以不指导学生，也可以指导好些个。学生可以单干，也可以多拜几个师傅</p><p>绘制E-R图如下两侧都没有箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113506699.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113506699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113506699"></p><p>总结：one指向的那一侧是箭头-&gt;</p><p>对于以上的各种关系，每一个advisor关系集合的超键都由各个实体集合的主键并集组成</p><p>但是超键却不太一样，一般选择many那一侧的主键做关系集合的主键</p><p>多对多</p><ul><li>主键和超键相同</li></ul><p>一对多</p><ul><li>多的那一侧，当做主键</li></ul><p>一对一</p><ul><li>任何一侧都可以当做主键</li></ul><h2 id="2-2-全部或部分参与约束"><a href="#2-2-全部或部分参与约束" class="headerlink" title="2.2 全部或部分参与约束"></a>2.2 全部或部分参与约束</h2><p>Total and Partial Participation 全部或部分参与</p><p>如下图所示，绘制E-R图时候 双线代表全部，单线代表部分</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113951144.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113951144.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113951144"></p><p>学生一侧是全部，含义代表每一个学生必须有一个指导老师</p><p>导师一侧是部分，含义代表有些老师指导学生，有些老师不指导学生</p><h2 id="2-3-最小最大基数约束"><a href="#2-3-最小最大基数约束" class="headerlink" title="2.3 最小最大基数约束"></a>2.3 最小最大基数约束</h2><p>在之前的基础上，可以加数量上的范围约束</p><p>E-R关系图上用双点表示, *表示无限制</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小值..最大值</span><br></pre></td></tr></table></figure><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221114723404.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221114723404.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221114723404"></p><p>含义如下</p><p>左侧老师一侧：0..* 代表一个指导老师能够指导0个或者更多个学生，没有上限</p><p>右侧学生一侧：1..1 代表一个学生至少1 个老师，至多也只有1个指导老师</p><p>超键是都有的</p><p>但主键根据情况不同而不同</p><p>比如</p><p>+ </p><h1 id="3-弱实体集"><a href="#3-弱实体集" class="headerlink" title="3 弱实体集"></a>3 弱实体集</h1><p>他的存在依赖于另一个实体集（被依赖的那个称作标识实体集identifying entity sets）</p><p>比如 考试这个存在就是依赖于课程的存在，所以课程实体集叫做标识实体集identifying entity sets，考试这个实体集叫做弱实体集Weak Entity Sets</p><p>E-R图中，用双框矩形表示，关系集合由双框菱形组成，虚线代表辨别属性</p><p>如下图所示</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143918389.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143918389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221143918389"></p><p>该关系集合sec_course  的主键由标识实体集的主键和弱实体集的辨别属性（即虚线画出来的）一起构成</p><p>弱实体集那一侧一定是全部total participation</p><h1 id="4-ER模型转换为关系模式Relation-Schema"><a href="#4-ER模型转换为关系模式Relation-Schema" class="headerlink" title="4 ER模型转换为关系模式Relation Schema"></a>4 ER模型转换为关系模式Relation Schema</h1><p>初步解决</p><h2 id="4-1-强实体集表示"><a href="#4-1-强实体集表示" class="headerlink" title="4.1 强实体集表示"></a>4.1 强实体集表示</h2><p>对于强实体集而言有着简单的属性，直接转即可</p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145145498.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145145498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145145498"></p><p>对于强实体集有着复合属性，转换后成为一个一个简单属性（复合属性不会出现在其中）</p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145301321.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145301321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145301321"></p><p>对于多值属性而言如电话号码，我们再创建一个新的表</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145336791.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145336791.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145336791"></p><p>派生属性不要出现在表中，直接计算得到</p><h2 id="4-2-弱实体集表示"><a href="#4-2-弱实体集表示" class="headerlink" title="4.2 弱实体集表示"></a>4.2 弱实体集表示</h2><p>弱实体集形成新的表包含标识实体集的主键和它自己的属性</p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145718330.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145718330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145718330"></p><h2 id="4-3-关系集合表示"><a href="#4-3-关系集合表示" class="headerlink" title="4.3 关系集合表示"></a>4.3 关系集合表示</h2><p><strong>多对多</strong></p><p>两个实体集的主键+他自己的描述属性</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145851411.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145851411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145851411"></p><p>多对一</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151001627.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151001627.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151001627"></p><p>优化如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151014043.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151014043.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151014043"></p><p>一对一</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151038725.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151038725.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151038725"></p><p>优化如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151058298.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151058298.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151058298"></p><h1 id="5-实体关系设计"><a href="#5-实体关系设计" class="headerlink" title="5 实体关系设计"></a>5 实体关系设计</h1><p>问题一：假设一个部分可能有许多不同的分配。</p><p>解决：使用多值复合属性赋值</p><p>问题二：假设有关于作业的其他信息，例如最高分或截止日期</p><p>解决：将叶属性添加到分配属性</p><p>但是问题二有冗余问题</p><p>将赋值模型建模为由部分标识的弱实体集</p><h1 id="6-扩展E-R特征"><a href="#6-扩展E-R特征" class="headerlink" title="6 扩展E-R特征"></a>6 扩展E-R特征</h1><h2 id="6-1-IS-A-继承"><a href="#6-1-IS-A-继承" class="headerlink" title="6.1 IS-A 继承"></a>6.1 IS-A 继承</h2><p>Person可以经过Specialization（特化）称为两个小的如学生也是雇员</p><p>实体集可以包括实体的子分组，这些实体在某种程度上与集中的其他实体不同。</p><p>较低级别的实体集继承（inheritance）了较高级别实体集的所有属性和关系参与。</p><p>多重继承 简单继承</p><p>例如 人员集包括子组——员工集和学生集</p><p>重叠（Overlapping）——一个实体可能属于多个专用实体集，约束要求一个实体可以属于多个较低级别的实体集如，一个人可能既是学生也是雇员</p><p>不相交（Disjointness）——一个实体最多必须属于一个专用实体集，约束要求一个实体只能属于一个较低级别的实体集，如一个人只能是雇员里的前台柜员或者秘书之一</p><p>通过架构表示 IS-A 关系</p><p>方式一</p><p>​建立一个高水平实体集的架构，建立一个低水平的架构。通过外键建立两个练习</p><p>缺点：获取有关的信息，一个员工需要访问两个关系（低级架构和高级架构）</p><p>方式二</p><p>​使用所有本地属性和继承属性为每个实体集形成架构</p><p>缺点：冗余</p><p>用聚合的方式</p><p>使用聚合 – 可以将聚合实体集视为单个单元，而不考虑其内部结构的细节。</p><p>聚合是一种抽象，通过该抽象，将关系视为更高级别的实体</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（四）嵌入式系统定时器</title>
      <link href="/2023/12/05/Computer_system/embedded_system/3%20%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/12/05/Computer_system/embedded_system/3%20%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定时器工作原理"><a href="#1-定时器工作原理" class="headerlink" title="1 定时器工作原理"></a>1 定时器工作原理</h1><p>打开定时器后，定时器“存储寄存器”的值经过 一个机器周期自动加1（或减1），也就是说，机器周期 是定时器的计数周期。通过控制定时器运行的计数周期的个数实现定时功能。</p><p>每当出现一个计数信号，计数器就自动加1（或自动减1）。当计数值从最大 值变成0（或从0变成最大值）溢出时，定时器&#x2F;计数器便向CPU提出中断请求，中断请求我们在上面一节已经讲过了<a href="https://blog.csdn.net/Q52099999/article/details/135394651?spm=1001.2014.3001.5501">嵌入式（三）中断解析 | 中断基本概念 CC2530中断系统 中断编程全解析-CSDN博客</a>。</p><p>计数信号的来源可选择</p><p>​  周期性的内部时钟信号（如定时功能）</p><pre><code> 非周期性的外界输入信号（如计数功能）</code></pre><h1 id="2-定时器功能"><a href="#2-定时器功能" class="headerlink" title="2 定时器功能"></a>2 定时器功能</h1><p>那么定时器在我们实际中有什么样的作用呢？</p><p>1.定时器功能 </p><p>• 最本身直接的功能，比如我期望1s后灯熄灭，那么这个1s就得由定时器来完成</p><p>2计数器功能 </p><p>• 对任意时间间隔的输入信号的个数进行计数，一般用来对外界事件进行计数。其输入信号一般来自单片机外部开关型传感器， 可用于生产线产品计数、信号数量统计和转速测量等方面。</p><p>3 输入捕获功能 </p><p>对规定时间间隔的输入信号的个数进行计数，当外界输入有效 信号时，捕获计数器的计数值。该功能通常用来测量外界输入 脉冲的脉宽或频率，需要在外界输入信号的上升沿和下降沿进 行两次捕获，通过计算两次捕获的差值可计算出脉宽或周期等 信息。 </p><p>4 输出比较功能 </p><p> 当计数值与需要进行比较的值相同时，向CPU提出中断请求或改 变I&#x2F;O口输出控制信号。该功能一般用来控制LED灯亮度或电机 转速。</p><p>如按键消抖什么的</p><p>而在CC2530中 定时器不光只有一个，实际上有5个，分别各自的特点及其功能参考如下</p><h1 id="3-定时器分类"><a href="#3-定时器分类" class="headerlink" title="3 定时器分类"></a>3 定时器分类</h1><p>四个通用+两个特殊</p><p>四个通用：定时器1,2,3,4</p><p>两个特殊：睡眠定时器+看门狗定时器</p><h2 id="3-1-定时器1"><a href="#3-1-定时器1" class="headerlink" title="3.1 定时器1"></a>3.1 定时器1</h2><p>定时器1是一个16位定时器，是功能最全的定时器&#x2F;计数器。</p><p>支持输入捕获、输出比较、PWM输出（脉冲宽度调制，后面讲到）、触发DMA<br>5个独立的捕获&#x2F;比较通道</p><h2 id="3-2-定时器2"><a href="#3-2-定时器2" class="headerlink" title="3.2 定时器2"></a>3.2 定时器2</h2><p>定时器2主要用于为IEEE 802.15.4 CSMA&#x2F;CA算法提供定时， 以及为IEEE 802.15.4 MAC层提供一般的计时功能，也称为 MAC定时器。用户一般不使用该定时器</p><h2 id="3-3-定时器3和定时器4"><a href="#3-3-定时器3和定时器4" class="headerlink" title="3.3 定时器3和定时器4"></a>3.3 定时器3和定时器4</h2><p>定时器3和定时器4都是8位定时器，可用于PWM（脉冲宽度调制，后面讲到）控制。</p><h2 id="3-4-睡眠定时器"><a href="#3-4-睡眠定时器" class="headerlink" title="3.4 睡眠定时器"></a>3.4 睡眠定时器</h2><p><strong>24位</strong>正计数定时器，运行在<strong>32KHz</strong>的时钟频率，主要用于系统进入或退出<strong>低功耗睡眠模式</strong>之间的周期定时</p><h2 id="3-5-看门狗定时器"><a href="#3-5-看门狗定时器" class="headerlink" title="3.5 看门狗定时器"></a>3.5 看门狗定时器</h2><p>用于看门狗功能（后面讲到）</p><p><strong>15位</strong>计数器，频率由<strong>32KHz</strong>时钟源规定（不使用看门狗功能时，可作为通用的定时器）</p><p>实际上对于一个定时器而言，他可以有不同的工作模式</p><h1 id="4-定时器工作模式"><a href="#4-定时器工作模式" class="headerlink" title="4 定时器工作模式"></a>4 定时器工作模式</h1><h2 id="4-1-自由运行模式"><a href="#4-1-自由运行模式" class="headerlink" title="4.1 自由运行模式"></a>4.1 自由运行模式</h2><p>在自由运行模式下，计数器从0x0000开始，在每个活动时 钟边沿增加1，当计数器达到0xFFFF时溢出，计数器重新载 入0x0000并开始新一轮的递增计数。</p><p>相当于默认定时器的计数为0xFFFF</p><h2 id="4-2-模模式"><a href="#4-2-模模式" class="headerlink" title="4.2 模模式"></a>4.2 模模式</h2><p>在模模式下，计数器从0x0000开始，在每个活动时钟边沿 增加1，当计数器达到T1CC0寄存器保存的值时溢出，计数 器将复位到0x0000并开始新一轮递增计数</p><p>相当于可以人为设定计数为T1CC0寄存器</p><h2 id="4-3-正计数-倒计数模式"><a href="#4-3-正计数-倒计数模式" class="headerlink" title="4.3 正计数&#x2F;倒计数模式"></a>4.3 正计数&#x2F;倒计数模式</h2><p>在正计数&#x2F;倒计数模式下，计数器反复从0x0000开始，正计数 到T1CC0保存的最终计数值，然后倒计时返回0x0000，如下图 所示</p><p>相当于模模式的两倍</p><p>总结：自由运行模式的溢出值为0xFFFF不可变的，而其他两种模式则可以通过对T1CC0赋值，精确控制定时器的溢出值</p><p>实际我们对定时器的设置都是通过寄存器来实现的，接下来我们重点介绍寄存器，其中重点介绍定时器1的各种寄存器</p><h1 id="5-定时器1寄存器"><a href="#5-定时器1寄存器" class="headerlink" title="5 定时器1寄存器"></a>5 定时器1寄存器</h1><h2 id="5-1-计数寄存器"><a href="#5-1-计数寄存器" class="headerlink" title="5.1 计数寄存器"></a>5.1 计数寄存器</h2><p>首先我们是怎么知道当前已经计数到哪里了呢？通过T1CNTH和T1CNTl两个寄存器</p><p><strong>T1CNTH</strong>  定时器1的高位字节，在读T1CNTL时，计数器的高位字节缓冲到该寄存器</p><p><strong>T1CNTL</strong>   定时器1的低位字节，向该寄存器写任何值，将导致计数器被清零</p><p>在程序中应先读取T1CNT寄存器获取当前计数的低位字节，高位会被缓存到T1CNTH中，然后读取T1CNTH寄存器获取当前计数的高位字节</p><h2 id="5-2-计数控制寄存器"><a href="#5-2-计数控制寄存器" class="headerlink" title="5.2 计数控制寄存器"></a>5.2 计数控制寄存器</h2><p>控制寄存器<strong>T1CTL</strong>主要进行定时器分频系数和工作模式的选择。工作模式我们刚刚讲过了，这里多出来一个概念，叫做分频系数</p><p>可以理解为把一次计数的时间延长多少倍，举一个例子</p><p>CC2530在上电后，默认使用内部频率为16MHz的RC振荡器，这时候计数器增加一次耗费的时间是$\frac{1}{16MHZ}秒$  假设我们设置为128分频</p><p>那么也就意味着计数器增加一次耗费的时间变为$128*\frac{1}{16MHZ}秒$ </p><p>倘若我们设置为自由模式，那么只有当计数到0xFFFF（转换为十进制位65535）的时候，才会产生中断</p><p>那么最后产生最终中断的时间为</p><p>$65535<em>128</em>\frac{1}{16MHZ}秒&#x3D;&#x3D; 0.52428 秒$ </p><p>综上</p><p><strong>T1CTL</strong>  设置分频系数和工作模式，每一位的含义如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001173800132-17045494272601.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001173800132-17045494272601.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001173800132"></p><p><strong>IRCON</strong></p><p>Timer1中断标志位T1IF位于<strong>IRCON寄存器</strong>中，查询模式下需要手工进行清除，中断模式下进入中断服务函数，将由硬件自动清零</p><p><strong>T1STAT</strong> Timer1溢出中断及比较&#x2F;捕获中断标志</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001174054397.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001174054397.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001174054397"></p><p>这里的中断标志位T1IF，溢出中断标志位 ，捕获中断标志 有什么区别？查询模式和中断模式区别？</p><p>输入捕获事件？输出比较事件？</p><p><strong>T1CCxH   T1CCxL</strong> </p><p>计时器1 实际上有不同的通道，这样我们就可以设置多个的计数值，进行不同功能的不同时间的计数了</p><p>比如我一个LED灯想2s后灭，而一个LED灯想要1s后灭，就可以通过设置不同的计时器通道实现</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001174245418.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001174245418.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001174245418"></p><p>– T1CCTLn –</p><p>– TIMIF.OVFIM register bit resides in the TIMIF register</p><h1 id="6-定时器的两种使用方式"><a href="#6-定时器的两种使用方式" class="headerlink" title="6 定时器的两种使用方式"></a>6 定时器的两种使用方式</h1><h2 id="6-1-查询方式"><a href="#6-1-查询方式" class="headerlink" title="6.1 查询方式"></a>6.1 查询方式</h2><p>查询方式可以只定义分频系数（T1CTL）的值并且启动自由运行模式即可。利用溢出标志位IRCON状态</p><p>值进行判断即可</p><p>下面是一个通过查询方式实现LED3闪烁效果的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitT1</span><span class="params">()</span> &#123;</span><br><span class="line">T1CTL = <span class="number">0x0d</span>; <span class="comment">//128分频,自动重装 0x0000-0xFFFF</span></span><br><span class="line">T1STAT= <span class="number">0x21</span>; <span class="comment">//通道0,中断有效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">uchar count=<span class="number">0</span>;</span><br><span class="line">InitLed(); <span class="comment">//调用初始化函数</span></span><br><span class="line">InitT1();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(IRCON &gt; <span class="number">0</span>) &#123; <span class="comment">//查询溢出标志</span></span><br><span class="line">IRCON=<span class="number">0</span>;     <span class="comment">//溢出后清0</span></span><br><span class="line"><span class="keyword">if</span>(count++ &gt;= <span class="number">1</span>) &#123; <span class="comment">//约1s (2 * 0.52s)周期性闪烁，示波器测约为1025MS</span></span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line">LED3 = !LED3; <span class="comment">//LED3闪烁</span></span><br><span class="line">&#125; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-中断方式"><a href="#6-2-中断方式" class="headerlink" title="6.2 中断方式"></a>6.2 中断方式</h2><p>中断方式是通过最后溢出后，引发中断调用中断函数实现的。需要使能计时器1的中断功能，设置步骤较多</p><p><strong>配置流程如下</strong></p><p>配置 T1CTl 设置分频和工作模式</p><p>配置T1CC0L，T1CC0H， 配置最大计数数值的低，高八位</p><p>使能定时器1的溢出中断</p><p>使能定时器1中断</p><p>使能全局中断</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（四）中级和进阶SQL</title>
      <link href="/2023/12/04/Computer_system/Database_system/3-2%E4%B8%AD%E7%BA%A7%E5%92%8C%E8%BF%9B%E9%98%B6SQL/"/>
      <url>/2023/12/04/Computer_system/Database_system/3-2%E4%B8%AD%E7%BA%A7%E5%92%8C%E8%BF%9B%E9%98%B6SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="1-中级"><a href="#1-中级" class="headerlink" title="1 中级"></a>1 中级</h1><h2 id="1-1-Join表达式"><a href="#1-1-Join表达式" class="headerlink" title="1.1 Join表达式"></a>1.1 Join表达式</h2><p><a href="https://blog.csdn.net/dingjianmin/article/details/92009385">inner join、outer join、right join、left join 之间的区别_left inner join outer join 区别-CSDN博客</a></p><p>natural join 在所有共同属性上做等值连接，然后再投影去掉重复值</p><p>Inner join  在on的条件上做等值连接 或者叫join</p><p>outer join（外连接）又可以分为 left join，right join</p><p>cross join（笛卡尔积） 又叫full join（全连接）左连接和右连接的并集</p><p>和之前数据库关系代数那里讲的是一样的</p><p>加条件用on</p><h2 id="1-2-View-虚表"><a href="#1-2-View-虚表" class="headerlink" title="1.2 View 虚表"></a>1.2 View 虚表</h2><p>创建一个虚拟表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span> <span class="operator">&lt;</span>query expression<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中v是新表的表名，<query expression>对于原表的一个SQL查询</p><p>一但创建就可以在后面继续使用</p><p>我们之前讲过with as，虽然他看起来可以实现和view一样的效果，但实际上view是全局的，之后也可以调用，而with as是局部的，之后就不能继续调用了。</p><p>对于 更新View</p><p>会遇到很多问题</p><p>一个问题，就是更新之后View虚拟表，要映射回原本的表，</p><p>大多数 SQL 实现只允许在简单视图上进行更新</p><p>插入的话会是原表会是null</p><h2 id="1-3-完整性限制constraint"><a href="#1-3-完整性限制constraint" class="headerlink" title="1.3 完整性限制constraint"></a>1.3 完整性限制constraint</h2><p>完整性约束可防止对数据库造成意外损坏。</p><p>常见的一些限制</p><p>非空限制</p><p>独一限制</p><p>大于限制等等</p><p>比如如下一些限制实现</p><p>An instructor name cannot be null.<br>No two instructors can have the same instructor ID.<br>Every department name must have a matching department name in the department relation.<br>The salary of an instructor must be greater than $29000.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table instructor</span><br><span class="line">(ID varchar (5),</span><br><span class="line">name varchar (20) not null,</span><br><span class="line">dept_name varchar (20),</span><br><span class="line">salary numeric (8,2) check (salary &gt; 29000),</span><br><span class="line">primary key (ID),</span><br><span class="line">foreign key (dept_name) references department);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如会在插入的时候遇到</p><h1 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2 进阶"></a>2 进阶</h1><h2 id="2-1-数据库触发器trigger"><a href="#2-1-数据库触发器trigger" class="headerlink" title="2.1 数据库触发器trigger"></a>2.1 数据库触发器trigger</h2><p>触发器是一种特殊的<code>存储过程</code>。但触发器没有输入和输出参数，因而不能被显示调用。它作为语句的执行结果自动引发，而存储过程则是通过存储过程名称被直接调用。</p><p>触发器 可以自动执行一些内容，加强数据的完整性约束和业务规则等</p><p> 比如在插入一个语句后，我判断他是否完整！</p><p>触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。 触发器可以从 DBA_TRIGGERS ，USER_TRIGGERS 数据字典中查到。SQL3的触发器是一个能由系统自动执行对数据库修改的语句。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231227140119379.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231227140119379.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231227140119379"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（三）嵌入式中断</title>
      <link href="/2023/12/04/Computer_system/embedded_system/2%20%20%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/12/04/Computer_system/embedded_system/2%20%20%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="1中断的概念和作用"><a href="#1中断的概念和作用" class="headerlink" title="1中断的概念和作用"></a>1中断的概念和作用</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>指CPU在执行当前程序的时候，由于系统中出现某种急需要处理的情况，CPU暂停正在执行的程序，转而执行别的一段特殊处理程序来处理出现的紧急事物，处理结束后，CPU自动返回原先暂停的程序中断继续</p><h2 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h2><p>1 提高工作效率</p><p>2 具备应对突发状况的能力</p><h2 id="1-3-中断-其他概念"><a href="#1-3-中断-其他概念" class="headerlink" title="1.3 中断 其他概念"></a>1.3 中断 其他概念</h2><p>主程序  在发生中断前，CPU正常执行的处理程序。</p><p>中断源  引起中断的原因，或发生中断申请的来源</p><p>中断请求  中断源要求CPU提供服务的请求</p><p>断点   CPU响应中断后，主程序被打断的位置</p><p>中断处理函数  CPU响应中断后所执行的相应处理程序</p><p>中断向量      中断处理函数的入口地址，当CPU响应中断请求时，会跳转到该地址去 执行代码</p><p>CC2530的中断源如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240104172227718.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240104172227718.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240104172227718"></p><p>中断是有优先级的,按照不同优先级可以看到如下的系统</p><h1 id="2-CC2530的中断系统"><a href="#2-CC2530的中断系统" class="headerlink" title="2. CC2530的中断系统"></a>2. CC2530的中断系统</h1><p>CC2530将18个中断源划分成6个中断优先级组IPG0～IPG5， 每组包括3个中断源</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230927101249199.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230927101249199.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230927101249199"></p><p>用户可以指定这6个中断优先组的优先级 （称作<strong>用户指定优先级</strong>）可以设置0～3级</p><p>其中0级属于最低优先级，3级为最高优先级。 </p><p>为了保证中断系统的正常工作 还存在（<strong>自然优先级</strong>）的一些规则</p><p>1 如果多个组被设置成相同级别，则组号小的要比组 号大的优先级高。 </p><p>2 同一组中包括的3个中断源，最左侧的优先级最高， 最右侧的优先级最低。</p><p><strong>如何设置中断优先级？</strong></p><p>通过IP1和IP0两个寄存器</p><p>由于每个组可能的情况一共是0，1，2三种情况，所以每个组需要2位来代表不同的优先级，那么至少需要两个寄存器，IP1是高位，IP0是低位，每个寄存器最高的2位空置不使用</p><p>从右到左，依次为0.1.2.3.4.5组</p><p>具体来说，比如我要设置0组优先级为3</p><p>IP0的[0]设置为0</p><p>IP1的[0]设置为1</p><p>再举例</p><p>要设置中断源的优先级为P0INT&gt;P1INT&gt;P2INT</p><p>查表可知</p><p>P0INT对应的组为 IPG5</p><p>P1INT对应的组为 IPG4</p><p>P2INT对应的组为 IPG1</p><p>则可使用以下代码实现。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP1 = <span class="number">0x30</span>;   <span class="comment">//IPG5级别为3，IPG4级别为2，IPG1级别为1，其他组级别为0</span></span><br><span class="line">IP0 = <span class="number">0x22</span>; </span><br></pre></td></tr></table></figure><h1 id="3-中断编程"><a href="#3-中断编程" class="headerlink" title="3 中断编程"></a>3 中断编程</h1><h2 id="3-1-中断配置"><a href="#3-1-中断配置" class="headerlink" title="3.1 中断配置"></a>3.1 中断配置</h2><h3 id="3-1-1-使能端口组的中断功能"><a href="#3-1-1-使能端口组的中断功能" class="headerlink" title="3.1.1 使能端口组的中断功能"></a>3.1.1 使能端口组的中断功能</h3><p>相当于是上面有18种终端，对应不同的端口</p><p>我们首先要打开端口组中断的开关，比如P0，P1，P2</p><p><strong>寄存器IEN1和IEN2</strong></p><p>需要通过IEN1和IEN2特殊功能寄存器。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001163605503.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001163605503.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001163605503"></p><h3 id="3-1-2-使能当前端口组有哪些端口引脚中断"><a href="#3-1-2-使能当前端口组有哪些端口引脚中断" class="headerlink" title="3.1.2 使能当前端口组有哪些端口引脚中断"></a>3.1.2 使能当前端口组有哪些端口引脚中断</h3><p>实际上一个端口组对应多个引脚，所以我们需要指定</p><p>需要设<strong>置当前端口组中哪几个引脚具有外部中断功能</strong>，将不需要使用外部中断的引脚屏蔽掉。使用Px_IEN寄存器。</p><p><strong>寄存器Px_IEN</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001163623956.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001163623956.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001163623956"></p><h3 id="3-1-3-设置中断触发方式"><a href="#3-1-3-设置中断触发方式" class="headerlink" title="3.1.3 设置中断触发方式"></a>3.1.3 设置中断触发方式</h3><p><strong>用PICTL寄存器</strong></p><p>触发方式有</p><p>1）电平触发 </p><p>①高电平触发：输入信号为高电平时会引起中断请求</p><p> ②低电平触发：输入信号为低电平时会引起中断请求</p><p> 电平触发引起的中断，在中断处理完成后，如果输入电平 仍旧保持有效状态，则会再次引发中断请求，适用于连续 信号检测，如外接设备故障信号检测。 </p><p>2）边沿触发</p><p> ①上升沿触发：输入信号出现由低电平到高电平的跳变时 会引起中断请求。</p><p> ②下降沿触发：输入信号出现由高电平到低电平的跳变时 会引起中断请求。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001163657255.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001163657255.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001163657255"></p><p><strong>4 设置外部中断优先级</strong></p><p>用刚刚讲到的IP1和IP0两个寄存器</p><p><strong>5 使能系统总中断</strong> </p><p>使用EA寄存器</p><p>除了各个中断源有自己的中断开关之外，中断系统还有一 个总开关。如果说各个中断源的开关相当于楼层各个房间 的电闸，则中断总开关相当于楼宇的总电闸。中断总开关 控制位是EA位，在IEN0寄存器中</p><p>IEN0寄存器可以进行位寻址，因此要使能总中断，可以直</p><p>接采用如下方法实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EA =<span class="number">1</span>; <span class="comment">//使能总中断</span></span><br></pre></td></tr></table></figure><h2 id="3-2-中断处理函数编写"><a href="#3-2-中断处理函数编写" class="headerlink" title="3.2 中断处理函数编写"></a>3.2 中断处理函数编写</h2><p>刚刚进行了中断使能和初始化，接下来我们重点介绍中断后的检测</p><p>中断处理函数就是在中断后进行的操作</p><p>比如我想要按键之后亮灯</p><p>那么就可以在中断处理函数种进行亮灯的代码编写</p><h3 id="3-2-1-基本编写格式"><a href="#3-2-1-基本编写格式" class="headerlink" title="3.2.1 基本编写格式"></a>3.2.1 基本编写格式</h3><p>中断服务处理的编写格式具体如下</p><p>中断向量可以查上面的表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> vector=<span class="string">&lt;中断向量&gt;</span> <span class="comment">//编译指示</span></span></span><br><span class="line"></span><br><span class="line">__interrupt <span class="type">void</span> &lt;函数名称&gt; (<span class="type">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*编写中断处理程序*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“__interrupt ”表示函数是一个中断处理函数，函数体</p><p>不能带参数或有返回值。注意： “interrupt”前面的“_”</p><p>是两个短下画线构成的。</p><h3 id="3-2-2-识别触发外部中断的端口Port"><a href="#3-2-2-识别触发外部中断的端口Port" class="headerlink" title="3.2.2 识别触发外部中断的端口Port"></a>3.2.2 识别触发外部中断的端口Port</h3><p><strong>寄存器用P0IF、P1IF和P2IF</strong></p><p><strong>先识别</strong></p><p>P0、P1和P2口分别使用P0IF、P1IF和P2IF作为中断标志位，任何一个端口组的I&#x2F;O口产生外部中断时，会将对应端口组的外部中断标志位自动置位。例如，本任务中当SW1按下后，P1IF会变成1，此时CPU将进入P1口中断处理函数中处理事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（P1IF==<span class="number">1</span>）</span><br></pre></td></tr></table></figure><p>注意使用后<strong>要清除中断标志</strong></p><p>外部中断标志位不能自动复位，因此必须在中断处理</p><p>函数中手工清除该中断标志位，否则CPU将反复进入中断过</p><p>程。清除P1口外部中断标志位的方法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1IF=<span class="number">0</span>;  <span class="comment">// 清除P1口中断标志位</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-识别触发外部中断的引脚（Pin）"><a href="#3-2-3-识别触发外部中断的引脚（Pin）" class="headerlink" title="3.2.3 识别触发外部中断的引脚（Pin）"></a>3.2.3 识别触发外部中断的引脚（Pin）</h3><p><strong>寄存器 P0IFG、P1IFG和P2IFG</strong></p><p><strong>先识别</strong></p><p>•CC2530中有3个端口状态标志寄存器P0IFG、P1IFG和P2IFG，分别对应P0、P1和P2各引脚的中断触发状态。</p><p>•当被配置成外部中断的某个I&#x2F;O口触发中断请求时，对应标志位会被自动置位，在进行中断处理时可通过判断相应寄存器的值来确定是哪个引脚引起的中断</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001172709621.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001172709621.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231001172709621"></p><p>使用后<strong>清除引脚中断标志</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (P1IFG &amp; <span class="number">0x04</span>) <span class="comment">//如果P1_2引脚中断标志位置位</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag_Pause ==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag_Pause =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">flag_Pause =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">P1IFG &amp;=~<span class="number">0x04</span>; <span class="comment">//清除P1_2引脚(PIN)中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（三）SQL语句全解析</title>
      <link href="/2023/12/03/Computer_system/Database_system/3-1SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/12/03/Computer_system/Database_system/3-1SQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SQL表内类型"><a href="#1-SQL表内类型" class="headerlink" title="1 SQL表内类型"></a>1 SQL表内类型</h1><p>char(n)  固定长度n的字符</p><p>varchar（n）  最大长度n的可变字符</p><p> 比如我char(20) 的一个元素值为“vs”则占用20字节，如果varchar（20）的一个元素值为”vs”，则占用字节为2</p><p>int   整形</p><p>smallint   小整形</p><p>numeric（p,d ）   固定小数点位数，特定精度 如 numeric(3,1) 支持 44.5</p><p>float  </p><p>double</p><h1 id="2-SQL增删改语句"><a href="#2-SQL增删改语句" class="headerlink" title="2 SQL增删改语句"></a>2 SQL增删改语句</h1><h2 id="2-1-创建表-create"><a href="#2-1-创建表-create" class="headerlink" title="2.1 创建表 create"></a>2.1 创建表 create</h2><p>语法</p><p>注意不要丢掉分号</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">building <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">budget <span class="type">numeric</span> (<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">primary</span> key(dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>指定主键</strong></p><p>primary key(dept_name)</p><p><strong>指定非空属性</strong></p><p>dept_name varchar(20)  not null </p><p><strong>制定外键</strong></p><p>foreign key (name) references instructor</p><h2 id="2-2-删除表-drop"><a href="#2-2-删除表-drop" class="headerlink" title="2.2 删除表 drop"></a>2.2 删除表 drop</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> r;</span><br></pre></td></tr></table></figure><p>删除原本表</p><h2 id="2-3-表中添加属性-alter…-add"><a href="#2-3-表中添加属性-alter…-add" class="headerlink" title="2.3 表中添加属性 alter… add"></a>2.3 表中添加属性 alter… add</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">add</span> A D;</span><br></pre></td></tr></table></figure><p>为表添加A D属性</p><h2 id="2-4-添加新的元组信息-insert…into…"><a href="#2-4-添加新的元组信息-insert…into…" class="headerlink" title="2.4 添加新的元组信息 insert…into…"></a>2.4 添加新的元组信息 insert…into…</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructors <span class="keyword">values</span>(&quot;10211&quot;,&quot;Simith&quot;,&quot;Biology&quot;)</span><br></pre></td></tr></table></figure><h2 id="2-5-删除表所有元组-delete-from-…"><a href="#2-5-删除表所有元组-delete-from-…" class="headerlink" title="2.5 删除表所有元组  delete from …"></a>2.5 删除表所有元组  delete from …</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p>删除元组，但表还在</p><h2 id="2-6-更改元组-update"><a href="#2-6-更改元组-update" class="headerlink" title="2.6 更改元组  update"></a>2.6 更改元组  update</h2><p>示例：给收入低于 70000 的教师加薪 5%</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">70000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-查询语句"><a href="#3-查询语句" class="headerlink" title="3 查询语句"></a>3 查询语句</h1><p><strong>查询结构</strong></p><p>select 属性</p><p>from 表</p><p>where  谓词条件</p><p>多个表的时候，需要加表名.属性区分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, instructor.dept_name, building</span><br><span class="line"><span class="keyword">from</span> instructor, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name<span class="operator">=</span> department.dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><p>1 SQL语句<strong>大小写不敏感</strong>  name&#x3D;NAME</p><p>2 选择结果可能会包含<strong>重复</strong>的结果</p><p>使用distinct<strong>去除重复</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>3 使用*<strong>查询全部</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>4 选择中可以包括<strong>运算表达式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span> <span class="keyword">as</span> monthly_salary  </span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表示选择工资除以12后选择出来</p><p>5  <strong>where谓词</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>  <span class="keyword">and</span> salary <span class="operator">&gt;</span> <span class="number">70000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name, instructor.dept_name, building</span><br><span class="line"><span class="keyword">from</span> instructor, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> department.dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-重命名"><a href="#4-重命名" class="headerlink" title="4 重命名"></a>4 重命名</h1><h2 id="4-1-为什么用"><a href="#4-1-为什么用" class="headerlink" title="4.1 为什么用"></a>4.1 为什么用</h2><p><strong>as</strong></p><p>1 在相同的关系中比较元组</p><p>示例：查找 Comp.Sci 部门中薪水高于至少一名讲师的所有讲师的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2 将长的名字改短</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.name, S.course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, teaches <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.ID<span class="operator">=</span> S.ID;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3 结果属性修改名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.name <span class="keyword">as</span> instructor_name, S.course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, teaches <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.ID<span class="operator">=</span> S.ID;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-字符操作"><a href="#5-字符操作" class="headerlink" title="5 字符操作"></a>5 字符操作</h1><h2 id="5-1-寻找匹配"><a href="#5-1-寻找匹配" class="headerlink" title="5.1 寻找匹配"></a>5.1 寻找匹配</h2><p><strong>like</strong></p><p><strong>%</strong> 子字符串匹配</p><p><strong>__</strong> 匹配任何字符串</p><p>|| 运算符用于附加两个字符串</p><p>举例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Intro%&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string beginning <span class="keyword">with</span> “Intro”.</span><br><span class="line"><span class="string">&#x27;%Comp%&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string containing “Comp” <span class="keyword">as</span> a substring.</span><br><span class="line"><span class="string">&#x27;_ _ _&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string <span class="keyword">of</span> exactly three characters.</span><br><span class="line"><span class="string">&#x27;_ _ _ %&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string <span class="keyword">of</span> <span class="keyword">at</span> least three characters.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><p>1 大小写敏感</p><p>2 转义字符区分%</p><p>Match the string “100%”<br>            like ‘100 %‘  </p><h2 id="5-2-function"><a href="#5-2-function" class="headerlink" title="5.2 function"></a>5.2 function</h2><p>Trim用来 移除字符串后面的空格</p><h1 id="6-生序降序"><a href="#6-生序降序" class="headerlink" title="6 生序降序"></a>6 生序降序</h1><p><strong>order</strong>关键字</p><p><strong>desc 降序</strong></p><p><strong>asc升序</strong></p><p>示例1：按字母顺序列出物理系的所有教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例2：按薪水和姓名列出讲师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>, name <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><p><strong>between</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span> <span class="keyword">and</span> salary <span class="operator">&gt;=</span> <span class="number">90000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-联合操作"><a href="#7-联合操作" class="headerlink" title="7 联合操作"></a>7 联合操作</h1><h2 id="7-1-并集Union"><a href="#7-1-并集Union" class="headerlink" title="7.1 并集Union"></a>7.1 并集Union</h2><p>可以直接自动消除重复，不像选择子句。</p><p>例子1 ：查找 2017 年秋季或 2018 年春季开设的课程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"> <span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们想要保留所有重复值</p><p>用union all</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"> <span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-2-交集-INTERSECT"><a href="#7-2-交集-INTERSECT" class="headerlink" title="7.2 交集 INTERSECT"></a>7.2 交集 INTERSECT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-3-差集-EXCEPT"><a href="#7-3-差集-EXCEPT" class="headerlink" title="7.3 差集 EXCEPT"></a>7.3 差集 EXCEPT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-4-对于空值补充"><a href="#7-4-对于空值补充" class="headerlink" title="7.4 对于空值补充"></a>7.4 对于空值补充</h2><p>1 任何包含Null的表达式返回为Null</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="operator">+</span> <span class="keyword">null</span>  <span class="keyword">returns</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>2 任何包含Null的比较返回的值是未知的</p><p>例 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="operator">&lt;</span> <span class="keyword">null</span>  <span class="keyword">or</span>  <span class="keyword">null</span> <span class="operator">&lt;&gt;</span> <span class="keyword">null</span>   <span class="keyword">or</span>   <span class="keyword">null</span> <span class="operator">=</span> <span class="keyword">null</span>  <span class="keyword">returns</span> <span class="literal">unknown</span></span><br></pre></td></tr></table></figure><p>3 对于布尔运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> : (<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">unknown</span>)  <span class="operator">=</span> <span class="literal">unknown</span>,  </span><br><span class="line">  (<span class="literal">false</span> <span class="keyword">and</span> <span class="literal">unknown</span>) <span class="operator">=</span> <span class="literal">false</span>,</span><br><span class="line">      (<span class="literal">unknown</span> <span class="keyword">and</span> <span class="literal">unknown</span>) <span class="operator">=</span> <span class="literal">unknown</span></span><br><span class="line"><span class="keyword">or</span>: (<span class="literal">unknown</span> <span class="keyword">or</span> <span class="literal">true</span>)   <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line"> <span class="literal">unknown</span> <span class="keyword">or</span> <span class="literal">false</span>)  <span class="operator">=</span> <span class="literal">unknown</span></span><br><span class="line">    (<span class="literal">unknown</span> <span class="keyword">or</span> <span class="literal">unknown</span>) <span class="operator">=</span> <span class="literal">unknown</span></span><br><span class="line"><span class="keyword">not</span>:  <span class="operator">=</span><span class="literal">unknown</span></span><br></pre></td></tr></table></figure><p>空值，未知检测</p><p>示例：查找工资为空的所有教师。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">is</span> <span class="keyword">null</span><span class="operator">/</span> <span class="literal">unknown</span></span><br></pre></td></tr></table></figure><p>都是用is的，注意不能用&#x3D;来替代is 在null的情况下</p><h1 id="8-聚合函数"><a href="#8-聚合函数" class="headerlink" title="8 聚合函数"></a>8 聚合函数</h1><p>Average: avg<br>Minimum: min<br>Maximum: max<br>Total: sum<br>Count: count</p><p>示例：查找计算机科学系教师的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-1-group-by"><a href="#8-1-group-by" class="headerlink" title="8.1 group by"></a>8.1 group by</h2><p>group by是一个限定函数，意味着在这种情况下，限定在哪里的一个范围内进行比较寻找</p><p>比如下面的例子，要找到每一个部门的平均值</p><p>示例:查找每个部门讲师的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-2-having"><a href="#8-2-having" class="headerlink" title="8.2 having"></a>8.2 having</h2><p>having相当于要加一个限定条件</p><p>示例：查找平均工资大于42000的所有部门的名称和平均工资</p><p>having相当于就是给Group加一个条件，比如在这个范围内大于42000的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span> (salary) <span class="operator">&gt;</span> <span class="number">42000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9-Nested-Subqueries-嵌套子查询"><a href="#9-Nested-Subqueries-嵌套子查询" class="headerlink" title="9 Nested Subqueries 嵌套子查询"></a>9 Nested Subqueries 嵌套子查询</h1><h2 id="9-1-Set-Membership"><a href="#9-1-Set-Membership" class="headerlink" title="9.1 Set Membership"></a>9.1 Set Membership</h2><p>in 和not in</p><p>示例： 查找所有姓名为“莫扎特”或“爱因斯坦”的教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">in</span>(&quot;Mozart&quot;,&quot;Einstein&quot;)</span><br></pre></td></tr></table></figure><p>示例：查找已参加 ID 为 10101 的教师教授的课程部分的（不同）学生总数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id, sec_id, semester, <span class="keyword">year</span>) <span class="keyword">in</span>  (<span class="keyword">select</span> course_id, sec_id, semester, <span class="keyword">year</span></span><br><span class="line">                                 <span class="keyword">from</span> teaches</span><br><span class="line">                                 <span class="keyword">where</span> teaches.ID<span class="operator">=</span> <span class="number">10101</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-2-Set-Comparison"><a href="#9-2-Set-Comparison" class="headerlink" title="9.2 Set Comparison"></a>9.2 Set Comparison</h2><p>SQL also allows &lt; some, &lt;&#x3D; some, &gt;&#x3D; some, &#x3D; some, and &lt;&gt; some<br>定义： y &lt; some (X) : y小于X中任一元素，则结果为true</p><p>比较</p><p>some 只要一个满足即可</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114912021.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114912021.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231211114912021"></p><p>all 所有满足</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114933982.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114933982.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231211114933982"></p><h2 id="9-3-exist-or-not-exists"><a href="#9-3-exist-or-not-exists" class="headerlink" title="9.3 exist or not exists"></a>9.3 exist or not exists</h2><p>exists 它的作用是检查子查询是否返回结果。如果子查询返回至少一行数据（即至少存在一个满足条件的匹配项），那么”EXISTS”返回TRUE，否则返回FALSE。</p><p>示例: 查找学过生物系所有课程的学生（ID、姓名）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( (<span class="keyword">select</span> course_id</span><br><span class="line">                                 <span class="keyword">from</span> course</span><br><span class="line">                                 <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>)</span><br><span class="line">                               <span class="keyword">except</span></span><br><span class="line">                                 (<span class="keyword">select</span> T.course_id</span><br><span class="line">                                   <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">                                   <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-4-with-as"><a href="#9-4-with-as" class="headerlink" title="9.4 with as"></a>9.4 with as</h2><p>临时的关系，一会儿的查询用到</p><p>示例: 查找预算最高的所有部门</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> max_budget (<span class="keyword">value</span>) <span class="keyword">as</span>       </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">max</span>(budget)</span><br><span class="line">    <span class="keyword">from</span> department)</span><br><span class="line"><span class="keyword">select</span> department.name</span><br><span class="line"><span class="keyword">from</span> department, max_budget</span><br><span class="line"><span class="keyword">where</span> department.budget <span class="operator">=</span> max_budget.value;</span><br></pre></td></tr></table></figure><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>答案在最后</p><p>1 This Query can be replaced by which one of the following?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, course_id</span><br><span class="line">FROM instructor, teaches</span><br><span class="line">WHERE instructor_ID= teaches_ID;</span><br></pre></td></tr></table></figure><p>a) Select name,course_id from teaches,instructor where instructor_id&#x3D;course_id;<br>b) Select name, course_id from instructor natural join teaches;<br>c) Select name, course_id from instructor;<br>d) Select course_id from instructor join teaches;</p><p>2 In the SQL given above there is an error . Identify the error.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employee WHERE dept_name=&quot;Comp Sci&quot;;</span><br></pre></td></tr></table></figure><p>a) Dept_name<br>b) Employee<br>c) “Comp Sci”<br>d) From</p><p>Explanation: For any string operations single quoted(‘) must be used to enclose.</p><p>3 Which one of the following has to be added into the blank to select the dept_name which has Computer Science as its ending string?<br>a) %<br>b) _<br>c) ||<br>d) $</p><p>4 If we want to retain all duplicates, we must write ________ in place of union.<br>a) Union all<br>b) Union some<br>c) Intersect all<br>d) Intersect some</p><p>5  _____ clause is an additional filter that is applied to the result.<br>a) Select<br>b) Group-by<br>c) Having<br>d) Order by</p><p>6 A _____ indicates an absent value that may exist but be unknown or that may not exist at all.<br>a) Empty tuple<br>b) New value<br>c) Null value<br>d) Old value</p><p>7 Using the ______ clause retains only one copy of such identical tuples.<br>a) Null<br>b) Unique<br>c) Not null<br>d) Distinct</p><p>8  In an employee table to include the attributes whose value always have some value which of the following constraint must be used?<br>a) Null<br>b) Not null<br>c) Unique<br>d) Distinct</p><p>9   If the attribute phone number is included in the relation all the values need not be entered into the phone number column. This type of entry is given as<br>a) 0<br>b) –<br>c) Null<br>d) Empty space</p><p>10 Aggregate functions are functions that take a ___________ as input and return a single value.<br>a) Collection of values<br>b) Single value<br>c) Aggregate value<br>d) Both Collection of values &amp; Single value</p><p>11 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT __________</span><br><span class="line">FROM instructor</span><br><span class="line">WHERE dept name= ’Comp. Sci.’;</span><br></pre></td></tr></table></figure><p>Which of the following should be used to find the mean of the salary ?<br>a) Mean(salary)<br>b) Avg(salary)<br>c) Sum(salary)<br>d) Count(salary)</p><p>12 All aggregate functions except _____ ignore null values in their input collection.<br>a) Count(attribute)<br>b) Count(*)<br>c) Avg<br>d) Sum</p><p>13 </p><p>A Boolean data type that can take values true, false, and________<br>a) 1<br>b) 0<br>c) Null<br>d) Unknown</p><p>14</p><p>Which of the following is used to find all courses taught in both the Fall 2009 semester and in the Spring 2010 semester .<br>a)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT course id</span><br><span class="line">FROM SECTION AS S</span><br><span class="line">WHERE semester = ’Fall’ AND YEAR= 2009 AND</span><br><span class="line">EXISTS (SELECT *</span><br><span class="line">FROM SECTION AS T</span><br><span class="line">WHERE semester = ’Spring’ AND YEAR= 2010 AND</span><br><span class="line">S.course id= T.course id);</span><br></pre></td></tr></table></figure><p>b)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM instructor</span><br><span class="line">WHERE salary &gt; SOME (SELECT salary</span><br><span class="line">FROM instructor</span><br><span class="line">WHERE dept name = ’Biology’);</span><br></pre></td></tr></table></figure><p>c)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT (DISTINCT ID)</span><br><span class="line">FROM takes</span><br><span class="line">WHERE (course id, sec id, semester, YEAR) IN (SELECT course id, sec id, semester, YEAR</span><br><span class="line">FROM teaches</span><br><span class="line">WHERE teaches.ID= 10101);</span><br></pre></td></tr></table></figure><p>d)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(SELECT course id</span><br><span class="line">FROM SECTION</span><br><span class="line">WHERE semester = ’Spring’ AND YEAR= 2010)</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT dept_name, ID, avg (salary)</span><br><span class="line">FROM instructor</span><br><span class="line">GROUP BY dept_name;</span><br><span class="line">This statement IS erroneous because</span><br></pre></td></tr></table></figure><p>a) Avg(salary) should not be selected<br>b) Dept_id should not be used in group by clause<br>c) Misplaced group by clause<br>d) Group by clause is not valid in this query</p><p>答案</p><p>1-5  B C A A  C   6-10 C D B C  </p><p>11- 15  B B D A B</p><p>对exit比较模糊</p><p>从Nested -2 开始只做后五道题</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统实验-GPIO实验</title>
      <link href="/2023/12/03/Computer_system/embedded_system/1.1%20GPIO%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/12/03/Computer_system/embedded_system/1.1%20GPIO%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>硬件图如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240104111601639.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240104111601639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="硬件图"></p><p>实际上他们在端口命名的时候进行了分组</p><p>如上所示，P和点号之间的我认为他就是代表一个组，用某个寄存器控制，所以有0，1，2组</p><h1 id="1-GPIO编程用到的寄存器介绍"><a href="#1-GPIO编程用到的寄存器介绍" class="headerlink" title="1 GPIO编程用到的寄存器介绍"></a>1 GPIO编程用到的寄存器介绍</h1><h2 id="1-1-PxSEL寄存器"><a href="#1-1-PxSEL寄存器" class="headerlink" title="1.1 PxSEL寄存器"></a>1.1 PxSEL寄存器</h2><p><strong>基本介绍</strong></p><p>端口功能选择，用来设置端口为通用I&#x2F;O还是外设I&#x2F;O功能</p><p>关于这两个功能区别如下</p><p>通用I&#x2F;O功能，可以输出高低电平，在本实验中我们只需要给LED灯高低电平即可，因而设置为通用的</p><p>外设I&#x2F;O功能  一般的外部设备，例如摄像头或者打印机他们具体实现某些功能（拍照或打印文档），单片机要控制这些外部设备，一般的来说单片机的I&#x2F;O口与这些外设的引脚相连，通过I&#x2F;O引脚实现对外部设备的控制，让它们完成我们要求的功能</p><p><strong>使用方法</strong></p><p>PxSEL中的x代表几号端口组</p><p>比如上面的按键1KEY1对应的是P0.1  所以就应该控制P0SEL寄存器</p><p>那么每一位上面含义呢，对于位位0代表是通用I&#x2F;O，1代表外设I&#x2F;O</p><p>例如：将P1_0、P1_1、P1_3和P1_4设置成通用I&#x2F;O，即相应的bit置0   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1SEL &amp;=~<span class="number">0x1B</span>; <span class="comment">//0001 1011</span></span><br></pre></td></tr></table></figure><p>注意这里有取反操作，</p><p>设0用取反与，设1用或</p><h2 id="1-2-PxDIR寄存器"><a href="#1-2-PxDIR寄存器" class="headerlink" title="1.2 PxDIR寄存器"></a>1.2 PxDIR寄存器</h2><p><strong>基本介绍</strong></p><p>端口方向选择，是输入还是输出</p><p>注意这里的输入还是输出都是站在单片机角度的</p><p>比如：对于LED灯是单片机输出信号到灯，所以对应端口设置为输出，按键是外部给单片机输入，所以设置为输入</p><p><strong>使用方法</strong></p><p>PxDIR中的x代表几号端口组</p><p>将P1_0、P1_1、P1_3和P1_4设置成输出口，即相应的bit置1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1DIR |=<span class="number">0x1B</span>; <span class="comment">//0001 1101</span></span><br></pre></td></tr></table></figure><p>设置了传输方向为输出后，比如输出给LED灯，然后我们通过在端口设置高电平直接就可以控制灯的亮暗了 </p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1_0=<span class="number">1</span>； P1_1=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="1-3-PxINP寄存器"><a href="#1-3-PxINP寄存器" class="headerlink" title="1.3 PxINP寄存器"></a>1.3 PxINP寄存器</h2><p><strong>基本介绍</strong></p><p>当端口设置为输入模式的时候，即上面的PxDIR对应位设置为0的时候，可以进一步设置输入</p><p>具体有三种，上拉和下拉和三态</p><p>上拉是指单片机的引脚通过一个电阻连接到电源（高电平），当外界没有信号输入到引脚时，引脚被上拉电阻固定在高电平（逻辑值1）。相当于初始给引脚一个高电平</p><p>下拉是指单片机的引脚通过一个电阻连接到地（低电平），当外界没有信号输入到引脚时，引脚被下拉电阻固定在低电平（逻辑值0）。相当于初始给引脚一个低电平</p><p>三态也称高阻，即I&#x2F;O引脚既没有上拉到电源，也没有下拉到地，呈现高阻值状态。三态模式一般用于引脚的输出功能，特别当单片机的引脚接在多个设备公用的通信总线上时。当单片机不发送信号时，采用三态工作模式可以保证不干扰其他设备之间的通信。三态模式用于输入引脚时，引脚必须外接其他器件，此时不存在上拉或下拉电阻，还能降低单片机的功耗。</p><p><strong>使用方法</strong></p><p>P0INP，P1INP寄存器每一位含义如下</p><p><img src="/image-20240104114100233.png" class="lazyload placeholder" data-srcset="/image-20240104114100233.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240104114100233"></p><p>P2INP寄存器每一位含义如下</p><p><img src="/image-20240104114159092.png" class="lazyload placeholder" data-srcset="/image-20240104114159092.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240104114159092"></p><p>可以在输入端口读取电平值</p><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(P1_2 == <span class="number">0</span>) <span class="comment">//判断按键被按下</span></span><br></pre></td></tr></table></figure><h1 id="2-按键消抖"><a href="#2-按键消抖" class="headerlink" title="2 按键消抖"></a>2 按键消抖</h1><h2 id="2-1-软件消抖"><a href="#2-1-软件消抖" class="headerlink" title="2.1 软件消抖"></a>2.1 软件消抖</h2><p>最简单的消抖原理，就是当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才检测到的状态相同，就可以确认按键已经稳定的动作了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(SW1 == 0) //判断按键被按下</span><br><span class="line">&#123;</span><br><span class="line">DelayMS (10); //为消抖进行延时</span><br><span class="line">if(SW1 == 0 ) //经过延时后按键仍处在按下状态</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">while(!SW1); //等待按键松开</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-经典任务代码解析"><a href="#3-经典任务代码解析" class="headerlink" title="3 经典任务代码解析"></a>3 经典任务代码解析</h1><p>三个LED灯跑马灯效果，采用软件消抖</p><p>注意InitKey的初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 文 件 名: main.c</span></span><br><span class="line"><span class="comment">* 描    述: 按下按键KEY1控制LED1.LED2.LED3实现跑马灯效果</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  uint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P1_0       <span class="comment">//定义P1.0口为LED1控制端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P1_1       <span class="comment">//定义P1.1口为LED2控制端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3 P1_4       <span class="comment">//定义P1.4口为LED3控制端</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 P0_1       <span class="comment">// P0.1口控制按键KEY1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2 P2_0       <span class="comment">// P2.0口控制按键KEY2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3 P0_7       <span class="comment">// P0.7口控制按键KEY3</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON      1    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF     0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 名    称: DelayMS()</span></span><br><span class="line"><span class="comment">* 功    能: 以毫秒为单位延时，系统时钟不配置时默认为16M(用示波器测量相当精确)</span></span><br><span class="line"><span class="comment">* 入口参数: msec 延时参数，值越大，延时越久</span></span><br><span class="line"><span class="comment">* 出口参数: 无</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayMS</span><span class="params">(uint msec)</span></span><br><span class="line">&#123; </span><br><span class="line">    uint i,j;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> DelayCallCount=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;msec; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">535</span>; j++);</span><br><span class="line">    DelayCallCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 名    称: LedOnOrOff()</span></span><br><span class="line"><span class="comment">* 功    能: 点亮或熄灭所有LED灯    </span></span><br><span class="line"><span class="comment">* 入口参数: mode为0时LED灯亮  mode为1时LED灯灭</span></span><br><span class="line"><span class="comment">* 出口参数: 无</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LedOnOrOff</span><span class="params">(uchar mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED1 = mode;</span><br><span class="line">    LED2 = mode;</span><br><span class="line">    LED3 = mode; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 名    称: InitLed()</span></span><br><span class="line"><span class="comment">* 功    能: 设置LED相应的IO口</span></span><br><span class="line"><span class="comment">* 入口参数: 无</span></span><br><span class="line"><span class="comment">* 出口参数: 无</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  P1DIR |= <span class="number">0x01</span>;               <span class="comment">//P1.0定义为输出口  </span></span><br><span class="line">  P1DIR |= <span class="number">0x02</span>;               <span class="comment">//P1.1定义为输出口 </span></span><br><span class="line">  P1DIR |= <span class="number">0x10</span>;               <span class="comment">//P1.4定义为输出口 </span></span><br><span class="line">  <span class="keyword">asm</span>(<span class="string">&quot;NOP&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  LedOnOrOff(<span class="number">0</span>);  <span class="comment">// 使所有LED灯默认为熄灭状态  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 名    称: InitKey()</span></span><br><span class="line"><span class="comment">* 功    能: 设置按键相应的IO口</span></span><br><span class="line"><span class="comment">* 入口参数: 无</span></span><br><span class="line"><span class="comment">* 出口参数: 无</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitKey</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    P0SEL &amp;= ~<span class="number">0x02</span>;     <span class="comment">//设置P0.1为普通IO口  </span></span><br><span class="line">    P0DIR &amp;= ~<span class="number">0x02</span>;     <span class="comment">//按键接在P0.1口上，设P0.1为输入模式 </span></span><br><span class="line">    P0INP &amp;= ~<span class="number">0x02</span>;     <span class="comment">//打开P0.1上拉电阻</span></span><br><span class="line">    </span><br><span class="line">    P2SEL &amp;= ~<span class="number">0x01</span>;     <span class="comment">//设置P2.0为普通IO口</span></span><br><span class="line">    P2DIR &amp;= ~<span class="number">0x01</span>;     <span class="comment">//按键接在P2.0口上，设P2.0为输入模式 </span></span><br><span class="line">    P2INP &amp;= ~<span class="number">0x01</span>;     <span class="comment">//打开P2.0上拉电阻</span></span><br><span class="line">    </span><br><span class="line">    P0SEL &amp;= ~<span class="number">0x80</span>;     <span class="comment">//设置P0.7为普通IO口  </span></span><br><span class="line">    P0DIR &amp;= ~<span class="number">0x80</span>;     <span class="comment">//按键接在P0.7口上，设P0.7为输入模式 </span></span><br><span class="line">    P0INP &amp;= ~<span class="number">0x80</span>;     <span class="comment">//打开P0.7上拉电阻</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 名    称: KeyScan()</span></span><br><span class="line"><span class="comment">* 功    能: 读取按键状态</span></span><br><span class="line"><span class="comment">* 入口参数: 无</span></span><br><span class="line"><span class="comment">* 出口参数: 0为抬起   1为按键按下</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line">uchar <span class="title function_">KeyScan_1</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//检测按键key1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (KEY1 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayMS(<span class="number">10</span>);      <span class="comment">//延时10MS去抖</span></span><br><span class="line">        <span class="keyword">if</span> (KEY1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!KEY1); <span class="comment">//松手检测</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//有按键按下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar <span class="title function_">KeyScan_2</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//检测按键key2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (KEY2 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayMS(<span class="number">10</span>);      <span class="comment">//延时10MS去抖</span></span><br><span class="line">        <span class="keyword">if</span> (KEY2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!KEY2); <span class="comment">//松手检测</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//有按键按下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uchar <span class="title function_">KeyScan_3</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//检测按键key3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (KEY3 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayMS(<span class="number">10</span>);      <span class="comment">//延时10MS去抖</span></span><br><span class="line">        <span class="keyword">if</span> (KEY3 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!KEY3); <span class="comment">//松手检测</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//有按键按下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 程序入口函数</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitLed();      <span class="comment">//设置LED灯相应的IO口</span></span><br><span class="line">    InitKey();                <span class="comment">//设置按键KEY1相应的IO口</span></span><br><span class="line">    <span class="type">int</span> flow_1=<span class="number">1</span>;             <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">int</span> flow_2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flow_3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayMS(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(KeyScan_1())</span><br><span class="line">        &#123;</span><br><span class="line">          flow_1=!flow_1;  </span><br><span class="line">          <span class="keyword">if</span>(flow_1==<span class="number">1</span>)  <span class="comment">//判断如果此时flow1按下，则把其余按键置零，防止干扰</span></span><br><span class="line">            flow_2=<span class="number">0</span>;</span><br><span class="line">            flow_3=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KeyScan_2())  </span><br><span class="line">        &#123;</span><br><span class="line">          flow_2=!flow_2; </span><br><span class="line">          <span class="keyword">if</span>(flow_2==<span class="number">1</span>)  <span class="comment">//判断如果此时flow2按下，则把其余按键置零，防止干扰</span></span><br><span class="line">            flow_1=<span class="number">0</span>;</span><br><span class="line">            flow_3=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KeyScan_3())</span><br><span class="line">        &#123;</span><br><span class="line">          flow_3=!flow_3;  <span class="comment">//判断如果此时flow2按下，则把其余按键置零，防止干扰</span></span><br><span class="line">          <span class="keyword">if</span>(flow_3==<span class="number">1</span>)  </span><br><span class="line">            flow_1=<span class="number">0</span>;</span><br><span class="line">            flow_2=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描按键当前状态,按下抬起一次改变LED显示效果，在跑马灯效果从左到右，从右到左，与LED2灯闪烁效果间切换</span></span><br><span class="line">        <span class="keyword">if</span> (flow_1)    <span class="comment">//依次点亮 LED1  LED2 LED3 实现跑马灯效果</span></span><br><span class="line">        &#123;   LED1 = ON;    <span class="comment">//点亮LED1      </span></span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">            LED1 = OFF;   <span class="comment">//熄灭LED1 </span></span><br><span class="line">            LED2 = ON;                </span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">            LED2 = OFF;            </span><br><span class="line">            LED3 = ON;           </span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">            LED3 = OFF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flow_2)     <span class="comment">//依次点亮 LED3  LED2 LED1 实现跑马灯效果  </span></span><br><span class="line">        &#123;   LED3 = ON;    <span class="comment">//点亮LED1      </span></span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">            LED3 = OFF;   <span class="comment">//熄灭LED1 </span></span><br><span class="line">            LED2 = ON;                </span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">            LED2 = OFF;            </span><br><span class="line">            LED1 = ON;           </span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">            LED1 = OFF;</span><br><span class="line">        &#125;               </span><br><span class="line">        <span class="keyword">if</span> (flow_3)     <span class="comment">//依次点亮 LED2 实现亮灯是灭灯时长的2倍效果 </span></span><br><span class="line">        &#123;   LED2 = ON;    <span class="comment">//点亮LED1      </span></span><br><span class="line">            DelayMS(<span class="number">1000</span>); </span><br><span class="line">            LED2 = OFF;   <span class="comment">//熄灭LED1 </span></span><br><span class="line">            DelayMS(<span class="number">500</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（二）关系代数</title>
      <link href="/2023/12/02/Computer_system/Database_system/2%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/2023/12/02/Computer_system/Database_system/2%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单张表运算"><a href="#1-单张表运算" class="headerlink" title="1 单张表运算"></a>1 单张表运算</h1><h2 id="1-1-选择-select"><a href="#1-1-选择-select" class="headerlink" title="1.1 选择 select"></a>1.1 选择 select</h2><p>选择就是从一个表中选择满足条件的一些元组</p><p>“Predicate” 可以翻译为 “谓词” 或者 “断言”。在数据库和计算机科学的上下文中，谓词通常是用来描述条件或断言的术语，用于筛选数据或控制程序的执行流程。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101604316.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101604316.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924101604316"></p><p>选择的条件可以 是表达式</p><p>可以包括等于，大于小于，不等于等等</p><p>当有多个条件时，可以通过and，or等连接</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101756697.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101756697.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924101756697"></p><p>还可以连接两个属性</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205219240.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205219240.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209205219240"></p><h2 id="1-2-投影-project"><a href="#1-2-投影-project" class="headerlink" title="1.2  投影 project"></a>1.2  投影 project</h2><p>投影可以理解为选择某些属性的值（注意去掉重复的，如下图例子</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101936020.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101936020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924101936020"></p><p>允许算术表达式，如下面的例子，会计算salary&#x2F;12的值</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205609680.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205609680.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209205609680"></p><p>关系代数运算可以组合成一个关系代数表达式</p><p>如下面的例子，可以发现这里的参数是一个表达式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205737774.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205737774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209205737774"></p><h1 id="2-多张表之间运算"><a href="#2-多张表之间运算" class="headerlink" title="2 多张表之间运算"></a>2 多张表之间运算</h1><h2 id="2-1-笛卡尔积-Cartesian-product"><a href="#2-1-笛卡尔积-Cartesian-product" class="headerlink" title="2.1 笛卡尔积 Cartesian-product"></a>2.1 笛卡尔积 Cartesian-product</h2><p>前面表的第一行依次和后面表的每一行连接</p><p>前面表的第二行依次和后面表的每一行连接</p><p>……</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102145234.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102145234.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924102145234"></p><p>当然这样得到的结果可能是不合理的，所以我们可以在这个的基础上进行一些操作，选出符合要求的</p><p>自然引出我们下面的一种操作叫Theta连接</p><h2 id="2-2-Theta连接-操作-Theta-join"><a href="#2-2-Theta连接-操作-Theta-join" class="headerlink" title="2.2  Theta连接 操作 Theta-join"></a>2.2  Theta连接 操作 Theta-join</h2><p>先笛卡尔积，再选出符合要求θ的</p><p>Theta-Join 操作是数据库中的一种关联操作，它不仅仅基于相等的条件来关联两个表，而是允许使用任何满足特定谓词（通常是一个比较运算符，如小于、大于、等于等）的条件来关联表中的行。这个谓词通常用θ（希腊字母Theta）来表示，因此得名 Theta-Join。<img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102429670.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102429670.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924102429670"></p><h2 id="2-3-自然连接操作-natural-join"><a href="#2-3-自然连接操作-natural-join" class="headerlink" title="2.3 自然连接操作 natural-join"></a>2.3 自然连接操作 natural-join</h2><p>自然连接依赖于表之间的隐式连接条件，这些条件是基于表的列名相匹配的（找两个表中相同的列名）。具体来说，自然连接将两个表中列名相同的列用作连接条件，并且只返回这些列的一份副本。</p><p>——只有两个表都有的元素才会被链接</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102507760.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102507760.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924102507760"></p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223518297.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223518297.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930223518297"></p><p>注意这里会产生悬浮元组，即没有对应一样的元组</p><p>所以就产生了下面的一种连接方式</p><h2 id="2-4-外连接"><a href="#2-4-外连接" class="headerlink" title="2.4  外连接"></a>2.4  外连接</h2><p>把悬浮元组保存在结果表中，在其他属性上填NULL</p><p>右外连接：保留右边表中的悬浮元组</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223630637.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223630637.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930223630637"></p><p>左外连接：保留左边表中的悬浮元组</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223645041.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223645041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930223645041"></p><h2 id="2-5-并union，交Set-Intersection，差运算Set-Difference"><a href="#2-5-并union，交Set-Intersection，差运算Set-Difference" class="headerlink" title="2.5 并union，交Set-Intersection，差运算Set Difference"></a>2.5 并union，交Set-Intersection，差运算Set Difference</h2><p>使用并运算条件</p><p>1 两个表必须有相同的属性</p><p>2  属性域必须兼容（对于每个 i，输入关系的第 i 个属性的类型必须相同）</p><p>举例</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224051965.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224051965.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224051965"></p><p>交运算</p><p>1 两个表必须有相同的属性</p><p>2  属性域必须兼容（对于每个 i，输入关系的第 i 个属性的类型必须相同）</p><p>举例</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224114274.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224114274.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224114274"></p><p>差运算</p><p>1 两个表必须有相同的属性</p><p>2  属性域必须兼容（对于每个 i，输入关系的第 i 个属性的类型必须相同）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224159418.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224159418.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224159418"></p><h2 id="2-6-除法-Division"><a href="#2-6-除法-Division" class="headerlink" title="2.6 除法 Division"></a>2.6 除法 Division</h2><p>除操作是同时从行和列角度进行运算</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225613708.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225613708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930225613708"></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225711834.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225711834.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930225711834"></p><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3 其他"></a>3 其他</h1><h2 id="3-1-赋值操作-Assignment"><a href="#3-1-赋值操作-Assignment" class="headerlink" title="3.1 赋值操作 Assignment"></a>3.1 赋值操作 Assignment</h2><p>为了方便，简化表达式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224341845.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224341845.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224341845"></p><h2 id="3-2-重命名-Rename"><a href="#3-2-重命名-Rename" class="headerlink" title="3.2 重命名 Rename"></a>3.2 重命名 Rename</h2><p>对表达式的结果或者表等重命名</p><p>两种表达形式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224900175.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224900175.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224900175"></p><p>举例</p><p>可以方便复用一个表</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224921443.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224921443.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224921443"></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225152778.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225152778.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930225152778"></p><p>对于查询，可能有多种表达形式，他们的结果是一样的</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（二）单片机基础</title>
      <link href="/2023/12/02/Computer_system/embedded_system/1%20%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/12/02/Computer_system/embedded_system/1%20%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章我们介绍了嵌入式系统</p><p>嵌入式系统（Embedded System）是一种特定用途的计算机系统，它通常嵌入在更大的产品或系统中，用于控制、监测或执行特定的任务。这些系统通常由硬件和软件组成，旨在满足特定的需求，如嵌入在家电、汽车、医疗设备、工业自动化、消费电子产品、通信设备等各种应用领域。</p><p>简单说嵌入式：<strong>就是嵌入到对象体中的专用计算机系统</strong>  三要素 嵌入 专用 计算机</p><p>嵌入式系统往往是一个较为复杂的系统，由单片机和硬件平台和嵌入式计算机系统等组成，其中的核心是<strong>嵌入式处理器</strong></p><p>我们主要讲解单片机</p><h1 id="1-单片机基本介绍"><a href="#1-单片机基本介绍" class="headerlink" title="1 单片机基本介绍"></a>1 单片机基本介绍</h1><h2 id="1-1-单片机组成"><a href="#1-1-单片机组成" class="headerlink" title="1.1 单片机组成"></a>1.1 单片机组成</h2><p>单片机系统是经典的嵌入式系统</p><p>单片微型计算机简称单片机，他不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一块芯片上，往往集合了如下一些部分</p><p>​（1）CPU中央处理器</p><p>​（2）RAM 随机存取存储器</p><p>​（3）ROM 只读存储器</p><p>​（4）定时&#x2F;计数器&#x2F; IO接口</p><p>采用<strong>哈佛结构 Harvard结构</strong></p><p>将程序 指令储存和数据储存分开的存储器 结构。拥有独立的指令总线和数据 总线，可以让取指与数据访问分开 进行，提高了执行效率。</p><p>而不是传统我们熟悉的冯诺依曼结构</p><h2 id="1-2-单片机特点"><a href="#1-2-单片机特点" class="headerlink" title="1.2 单片机特点"></a>1.2 单片机特点</h2><p>1）高集成度，体积小，高可靠性</p><p> 2）控制功能强  </p><p>3）低电压，低功耗，便于生产便携式产品  </p><p>4）易扩展  </p><p>5）优异的性能价格比</p><h2 id="1-3-单片机分类"><a href="#1-3-单片机分类" class="headerlink" title="1.3 单片机分类"></a>1.3 单片机分类</h2><p><strong>1 按数据处理位数来分</strong></p><p>由于4位单片机性能比较低，目前已逐步退出市场。</p><p>而16位 和32位单片机虽然性能比8位的强得多，但由于成本和应用 场合的限制，尤其是近年来ARM嵌入式技术的发展，导致它 的应用空间也不如8位单片机广泛。而16位和32位单片机主 要应用于视频采集、图形处理等方面。</p><p><strong>2 按内核分类</strong></p><p>单片机按内核分为</p><p>51系列  爱特梅尔公司</p><p>ARM系列  安谋国际科技股份有限公司</p><p>PIC系列  美国微芯科技公司</p><p>AVR系列  爱特 梅尔公司</p><p> MSP430系列   德州 仪器公司</p><p><strong>3 按指令类型分类 单片机按指令类型可以分为</strong></p><p>精简指令集和复杂指令集。</p><h2 id="1-4-单片机内部结构"><a href="#1-4-单片机内部结构" class="headerlink" title="1.4 单片机内部结构"></a>1.4 单片机内部结构</h2><p>1）<strong>中央处理器</strong> </p><p>运算器和控制器是核心，合称中央处理器或中央处理单元。</p><p> 运算器执行所有的算术和逻辑运算；</p><p>控制器负责把指令逐 条从存储器中取出，经译码后向计算机发出各种控制命令；</p><p> 而寄存器为处理单元提供操作所需要的数据。</p><p> 2）<strong>存储器</strong> </p><p>存储器主要包括只读存储器和随机存储器。</p><p> 3）<strong>输入设备和输出设备</strong> </p><p>输入设备和输出设备主要包括<strong>并行I&#x2F;O端口</strong>和<strong>串行接口</strong>等通 信方式。 </p><p><strong>并行I&#x2F;O端口</strong>即输入&#x2F;输出引脚，这是单片机与外部电路和 器件主要联系的端口，它既可以接收外界输入的电平信号， 也可以向外发送指定的电平信号</p><p><strong>串行通信</strong>是一条信息的各位数据逐位按顺序传送的通信方 式。其数据传送按位顺序进行，最少只需要一根传输线即可。串行通信主要采用通用异步收发传输器（UART）实现。 其中，RxD表示接收数据端口，TxD表示发送数据端口</p><p>4）<strong>时钟电路</strong></p><p>主要为单片机提供运行所需要的节拍信号，每到 来一个节拍，单片机就执行一步操作，所以时钟电路提供 的信号频率越高，单片机的运行速度就越快，相应的功耗 也越大。</p><p>5）<strong>中断控制系统</strong> </p><p>中断的种类大体来说，主要包括<strong>硬体中断、软体中断</strong>两类。 </p><p><strong>硬体中断</strong>的形成，通常是外界的硬体装置利用由CPU拉出的 中断要求信号线来通知 CPU中断的请求。</p><p><strong>软体中断</strong>，通 常是CPU自己引发的，比如说执行了不该执行的指令、计算 错误或者执行了某个用来产生软体中断的指令。</p><p>6）<strong>定时器&#x2F;计数器</strong></p><p> 单片机将CPU、存储器、输入&#x2F;输出设备、中断控制系统、 定时器&#x2F;计数器和通信等多种功能部件集成到一块硅片上， 从而构成一个体积小但功能完善的微型计算机系统。</p><p>解下来我们重点介绍一款应用较多的单片机</p><h1 id="2-8051单片机内部结构"><a href="#2-8051单片机内部结构" class="headerlink" title="2. 8051单片机内部结构"></a>2. 8051单片机内部结构</h1><h2 id="2-1-CPU-核心"><a href="#2-1-CPU-核心" class="headerlink" title="2.1 CPU 核心"></a>2.1 CPU 核心</h2><p>以ALU为中心的运算器</p><p>还有以各种寄存器和译码器为核心的控制器</p><p><img src="/!%5Bimage-20230918141136476%5D(https:/qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230918141136476.png)" class="lazyload placeholder" data-srcset="/!%5Bimage-20230918141136476%5D(https:/qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230918141136476.png)" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运算器和控制器"></p><p>除了CPU以外，有名的是单片机的三大资源</p><p>FLASH（程序存储空间ROM）</p><p>RAM  （数据存储空间）</p><p>SFR 特殊功能寄存器</p><h2 id="2-2-ROM-Flash-程序存储空间"><a href="#2-2-ROM-Flash-程序存储空间" class="headerlink" title="2.2 ROM   Flash  程序存储空间"></a>2.2 ROM   Flash  程序存储空间</h2><p>FLASH 存储器是一种非易失性存储器，用于存储嵌入式系统的程序代码。它通常用于存储固件、操作系统、应用程序和其他必要的程序代码。与传统的RAM不同，FLASH 存储器的数据在断电后仍然保持，因此适用于存储长期保持的程序代码。</p><p>对于单片机来说Flash最大的意义是断电后 数据不丢失，</p><h2 id="2-3-RAM-数据存储空间"><a href="#2-3-RAM-数据存储空间" class="headerlink" title="2.3  RAM 数据存储空间"></a>2.3  RAM 数据存储空间</h2><p>RAM是单片机的数据存储空间，用来存储程序运 行过程中产生的和需要的数据</p><p>跟电脑的内存是 相似的概念，关电后数据丢失，所以我 们每次打开计算器，都是从归零开始计算。</p><p> 它的优点，第一是读写速度非常快，第二是理论 上是可无限次写入的，即寿命无限，不管程序怎 么运行怎么读写它都不会坏。</p><h2 id="2-4-SFR-特殊功能寄存器"><a href="#2-4-SFR-特殊功能寄存器" class="headerlink" title="2.4 SFR 特殊功能寄存器"></a>2.4 SFR 特殊功能寄存器</h2><p>特殊功能寄存器是嵌入式系统中的一类寄存器，用于控制和配置系统的特殊功能和硬件模块。这些寄存器通常包括控制寄存器、时钟寄存器、中断寄存器、输入&#x2F;输出端口控制寄存器等。通过编写和读取这些寄存器的值，开发者可以配置和控制系统的各种功能。</p><p>SFR，特殊功能寄存器。这 个概念大家可能刚开始理解不了，但是一 定要记住。单片机有很多很多功能，每个 功能都会对应一个或多个SFR，我们就是 通过对SFR的读写来实现单片机的多种多 样的功能的。</p><h1 id="3-CC2530芯片介绍"><a href="#3-CC2530芯片介绍" class="headerlink" title="3 CC2530芯片介绍"></a>3 CC2530芯片介绍</h1><h2 id="3-1-组成"><a href="#3-1-组成" class="headerlink" title="3.1 组成"></a>3.1 组成</h2><p><strong>（1）CPU和内存</strong> </p><p>CC2530芯片中使用的8051CPU内核是一个单周期的8051兼容内核。</p><p>它有3种不同的内存访问总线，分别用于访问特殊功 能寄存器、数据和代码&#x2F;外部数据</p><p>此外，它还包括一个调试接口和一个18路输入扩展中断单元。</p><p><strong>（2）时钟和电源管理</strong> </p><p>数字内核和外设由一个1.8V低压差稳压器供电。它提供了 电源管理功能，可以实现使用不同供电模式的长电池寿命 的低功耗运行。CC2530有5种不同的复位源来复位设备</p><p><strong>（3）外设</strong> </p><p>调试接口执行一个专有的两线串行接口，用于内电路调试。 通过这个调试接口，可以执行整个闪存存储器的擦除、控 制振荡器、停止和开始执行用户程序、执行8051内核提供 的指令、设置代码断点，以及内核中全部指令的单步调试。 使用这些技术，可以很好地执行内电路的调试和外部闪存 的编程。</p><p> 定时器1是一个16位定时器，具有定时器&#x2F;PWM功能。的消费 型IR信号。 </p><p>定时器2是专门为支持IEEE 802.15.4 MAC或软件中其他时 槽的协议设计的。该定时器有一个可配置的定时器周期和 一个8位溢出计数器</p><p>定时器3和定时器4是8位定时器，具有定时器&#x2F;计数器&#x2F;PWM功能。 </p><p>睡眠定时器在除供电模式3之外的所有工作模式下不断运行。该定时器 的典型应用是作为实时计数器，或作为一个唤醒定时器跳出供电模式1 或2</p><p>ADC支持7～12位的分辨率，分别在30kHz或4kHz的带宽。DC和音频转换 可以使用高达8个输入通道（端口0），输入可以选择作为单端或差分。 参考电压可以是内部电压、AVDD或一个单端或差分外部信号。ADC还有 一个温度传感输入通道。ADC可以自动执行定期抽样或转换通道序列的 程序</p><p>串口1（USART 0）和串口2（USART 1）被配置为一个SPI主&#x2F;从或一个 UART。它们为RX和TX提供双缓冲，以及硬件流控制。</p><h1 id="4-单片机最小系统"><a href="#4-单片机最小系统" class="headerlink" title="4 单片机最小系统"></a>4 单片机最小系统</h1><p>单片机最小系统 ，也叫做单片机 最小应用系统， 是指用最少的原 件组成单片机可 以工作的系统。 单片机最小系统 的三要素就是电源、晶振、复位</p><h2 id="4-1-电源"><a href="#4-1-电源" class="headerlink" title="4.1  电源"></a>4.1  电源</h2><p>常用单片机的电源系统有5V系统 和3.3V系统这两种。</p><h2 id="4-2-晶振"><a href="#4-2-晶振" class="headerlink" title="4.2 晶振"></a>4.2 晶振</h2><h3 id="4-2-1-定义种类"><a href="#4-2-1-定义种类" class="headerlink" title="4.2.1 定义种类"></a>4.2.1 定义种类</h3><p>晶振，又叫晶体振荡器，他起到的作用是 为单片机系统提供基准时钟信号。 </p><p> 单片机内部所有的工作都是以这个时钟信号为步调基准来进行工作的。</p><p> STC89C52单片机的18脚和19脚是晶振引 脚，我们接了一个11.0592M的晶振（它每 秒钟振荡11,059,200次），外加两个20pF 的电容，电容的作用是帮助晶振起振，并 维持振荡信号的稳定</p><p>电容分为不同种</p><p>晶振分为有源晶振和无源晶振</p><p>两种时钟产生方式</p><p>​内部振荡器方式</p><p>​外部时钟源方式</p><h3 id="4-2-2-基本时序周期"><a href="#4-2-2-基本时序周期" class="headerlink" title="4.2.2 基本时序周期"></a>4.2.2 基本时序周期</h3><p>CPU总是按照一定的时钟节拍与时序工作，时序 定时单位共有４个，从小到大依次是：</p><p>振荡周期&#x2F;时钟周期：Tc&#x3D;晶振频率fosc（或外加频率）的倒数 MCS-51单片机中最小的时序单位 </p><p>状态周期：Ts&#x3D;2个时钟周期(Tc)（很少用到此概念） </p><p>机器周期：CPU完成一个基本操作所需的时间称为机器周期</p><p> 指令周期: 执行一条指令所需的机器周期(Tm)数，是MCS-51 单片机最大的时序单位。通常含有1～4个机器周期。</p><p>相互转换关系</p><p>振荡周期 &#x3D; 晶振频率fosc的倒数；</p><p> 1个状态周期&#x3D; 2个振荡周期；</p><p> 1个机器周期 &#x3D; 12个振荡周期&#x3D;6个状态周期； </p><p>1个指令周期 &#x3D; 1、2、4个机器周</p><p>CC2530指令周期与标准51不同</p><p>标准51：1个机器周期为12个振荡周期 • CC2530包含一个单周期的增强51内核，不 同于标准51</p><p>CC2530</p><p>四个时钟源  两个内部振荡器，两个外部晶振</p><p>： 不做任何配置时，系统时钟 为16Mhz • 机器周期是多少？ 1&#x2F;16 us</p><h2 id="4-3-复位"><a href="#4-3-复位" class="headerlink" title="4.3 复位"></a>4.3 复位</h2><p>复位电路需要接到接到了单片机的RST(Reset)复位引脚 上。</p><p> 单片机复位一般是3种情况：</p><p>上电复位、手动复位、程序 自动复位。</p><p>（1）上电复位：单片机上电后进行的一个内部的初始化过程。保证单 片机每次都从一个固定的相同的状态开始工作。</p><p>（2）手动复位： 遭受到意外干扰而导致程序死机，或 者程序跑飞的时候，我们就可以按下一个复位按键，让程序重新 初始化重新运行。</p><p>（3）自动复位  当程序死机或者跑飞的时候，单片机往往有一套自动复位机制， 比如看门狗。如果程序长时间失去响应，单片机看门狗模块会自 动复位重启单片机</p><p>电源、晶振、复位构成了单片机最小系统 的三要素，也就是说，一个单片机具备了 这三个条件，就可以运行我们下载的程序 了</p><p>而其他的比如LED小灯、数码管、液晶等设 备都是属于单片机的外部设备，即外设。</p><p> 外设</p><p>通常红色贴片LED:靠电流驱动，电压 1.8V~2.2V，电流1到20mA，在1到 5mA亮度有所变化，5mA以上亮度基本 无变化</p><h1 id="5-编程"><a href="#5-编程" class="headerlink" title="5 编程"></a>5 编程</h1><p>嵌入编程中要注意数据类型，</p><p>char 8位  一般给寄存器赋值，因为寄存器一般是八位</p><p>需要考虑编程的取值范围</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（一）概述</title>
      <link href="/2023/12/01/Computer_system/Database_system/1%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/12/01/Computer_system/Database_system/1%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据库的一些基础概念"><a href="#1-数据库的一些基础概念" class="headerlink" title="1 数据库的一些基础概念"></a>1 数据库的一些基础概念</h1><h2 id="1-1-数据库和数据库管理系统"><a href="#1-1-数据库和数据库管理系统" class="headerlink" title="1.1 数据库和数据库管理系统"></a>1.1 数据库和数据库管理系统</h2><p>A <strong>database-management system</strong> (<strong>DBMS</strong>) is a collection of interrelated data and a set of programs to access those data. </p><p>It is a powerful tool for managing large amount of data efficiently and allowing data to persist safely.</p><p><strong>Database</strong> refers to a collection of data that is managed by a DBMS</p><p>数据库是一组相关数据的集合，而数据库管理系统（DBMS）是管理、维护和操作这些数据的软件系统。简单来说，数据库是数据的集合，而DBMS是用来管理和操作这些数据的工具。</p><h2 id="1-2-关系模式和关系实例"><a href="#1-2-关系模式和关系实例" class="headerlink" title="1.2 关系模式和关系实例"></a>1.2 关系模式和关系实例</h2><p>关系模式（Relation Schema）和关系实例Relation Instance是关系型数据库中的两个不同但相关的概念。</p><p>A relation schema (关系模式) consists of a list of attributes and their corresponding domains.It defines the structure of the table, but does not include any actual data.</p><p>关系模式（Relation Schema）是指关系型数据库中表格的结构，包括表格的名称、列名、数据类型、主键和外键等。它定义了表格的结构，但并不包含任何实际的数据。关系模式通常通过CREATE TABLE语句来定义。</p><p>A relation instance (关系实例) is a set of tuples over a relation schema</p><p>关系实例（Relation Instance）是指关系模式中表格中的具体数据，也就是表格中的行和列。它是关系模式的一个具体实例，包括表格中的所有数据。关系实例可以通过SELECT语句来检索和查询。</p><p>例如，假设我们有一个关系模式为“学生（Student）”，包括学生编号（Student ID）、姓名（Name）、年龄（Age）和性别（Gender）等列。那么，关系实例就是表格中的具体数据，如学生编号为001、姓名为张三、年龄为20岁、性别为男性等。</p><h2 id="1-3-数据库模式和数据库实例"><a href="#1-3-数据库模式和数据库实例" class="headerlink" title="1.3 数据库模式和数据库实例"></a>1.3 数据库模式和数据库实例</h2><p>数据库模式（Database Schema）是数据库的结构图，它描述了数据库中各个表、列、主键、外键等的结构和关系。也就是说，数据库模式定义了数据库中数据的逻辑结构，包括表格、关系、约束和索引等元素。它是一个静态概念，不会发生变化，除非进行数据库结构的修改。</p><p>Database schema (数据库模式) – is the logical structure of the database</p><p>数据库实例（Database Instance）是指在计算机内存中运行的数据库，它是数据库在运行时的状态。也就是说，数据库实例包含了数据库中所有数据的副本以及处理这些数据的进程和线程。每个数据库实例都有自己的内存空间和处理器资源，可以独立地进行处理和管理。</p><p>Database instance (数据库实例) – is a snapshot of the data in the database at a given instant in time. </p><h1 id="2-数据库组织形式"><a href="#2-数据库组织形式" class="headerlink" title="2 数据库组织形式"></a>2 数据库组织形式</h1><h2 id="2-1-数据采用文件的缺点"><a href="#2-1-数据采用文件的缺点" class="headerlink" title="2.1  数据采用文件的缺点"></a>2.1  数据采用文件的缺点</h2><p>1 获得数据很困难，得为每一个潜在的程序写代码程序</p><p>Difficulty in accessing data</p><p>2 数据丢失或者不一致</p><p>Data redundancy and inconsistency</p><p>3 完整性问题</p><p>Integrity problem</p><p>4 并发访问，或者操作到一半的时候可能会出现程序崩掉，这时候数据库可能会把前面未完整执行的进行执行</p><p>Concurrent-access problem </p><p>5 安全访问问题</p><p>Security problem</p><p>6 操作原子性问题</p><p>Atomicity problem </p><h2 id="2-2-使用数据库管理系统的-优点"><a href="#2-2-使用数据库管理系统的-优点" class="headerlink" title="2.2  使用数据库管理系统的 优点"></a>2.2  使用数据库管理系统的 优点</h2><p> 主要是两方面</p><p>​便于查询和修改数据</p><p>​便于确定数据逻辑结构</p><p>​支持大量数据</p><p>​访问控制</p><p>​原子性操作</p><p>即事务是原子的。原子性是指事务中的所有操作被视为一个单独、不可分割的操作，要么全部执行成功，要么全部失败回滚，不会出现部分执行的情况。</p><p>这意味着，如果一个事务包含多个操作，如果其中任何一个操作失败，整个事务就会回滚，回到原始状态，所有的操作都会取消。这种方式可以确保数据的一致性和完整性，避免了数据损坏或错误的情况。</p><h1 id="3-关系型数据库特点"><a href="#3-关系型数据库特点" class="headerlink" title="3  关系型数据库特点"></a>3  关系型数据库特点</h1><ol><li>数据以表格（表）的形式存储，其中每个表包含行和列，每个表有独一无二的名称</li><li>表之间可以建立关系，通过外键（foreign key）实现表之间的连接。</li><li>数据库使用结构化查询语言（SQL）进行查询和操作。</li><li>关系型数据库通常支持事务处理和数据完整性控制。</li></ol><h1 id="4-三个层次的数据抽象Data-Abstraction"><a href="#4-三个层次的数据抽象Data-Abstraction" class="headerlink" title="4 三个层次的数据抽象Data Abstraction"></a>4 三个层次的数据抽象Data Abstraction</h1><p>Logical level：users can see all tables and how they are related</p><p>比如数据表的组织方式</p><p>Physical level: describe how data is stored in a file.</p><p>比如某一个内容占据多少字节等等</p><p>View level: users can see the tables within the scope of their requirements and permissions.</p><p>比如教师可以看到教师的数据表，而学生只能看到学生的数据表</p><h1 id="5-超键、候选码、主码、外码"><a href="#5-超键、候选码、主码、外码" class="headerlink" title="5 超键、候选码、主码、外码"></a>5 超键、候选码、主码、外码</h1><p><strong>超键</strong></p><p>在关系型数据库中，<strong>超键（Superkey）</strong>是能够唯一标识一个关系中元组的一组属性集合。简单来说，超键是可以唯一区分关系模式中不同元组的一组属性。</p><p>超键具有以下特点：</p><ol><li>超键必须是唯一的，即在关系模式中没有两个元组具有相同的超键值。</li><li>超键可以包含一个或多个属性。</li><li>超键可以是候选键（Candidate Key）的超集，也可以是包含主键（Primary Key）的超键。</li></ol><p>注意这里是超键的每一个子集都一样</p><p>ID，ID2，姓名，年龄，性别</p><p><strong>候选码</strong></p><p>​最小的超键，可以有多个</p><p><strong>主码</strong></p><p>​从候选码里选出来，唯一的一个  主码是数据库表中的一个字段或一组字段，用于唯一标识表中的每一行记录。</p><p>主码是数据库表中唯一标识记录的字段或字段集合，每个表只能有一个主码。候选码也是具有唯一性的字段或字段集合，但一个表可以有多个候选码，其中一个通常会被选择为主码。主要区别在于主码是表的主要标识符，而候选码是备选的唯一标识符。</p><p>写一个关系模式，将主键用下划线画出来，且一般在其他元素前</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231130203407360.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231130203407360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231130203407360"></p><p>写出他的关系模式</p><p>注意这里，用 两个才能唯一区别building, room number同时画下划线</p><p><strong>外码</strong></p><p>“参照关系”和”被参照关系”是用来描述表之间关系的术语，它们涉及到外码（Foreign Key）和主码（Primary Key）之间的联系。以下是它们的解释：</p><ol><li><p>参照关系（Referencing Relationship）：</p><ul><li>“参照关系”指的是包含外码（Foreign Key）的表，该外码引用另一张表的主码（Primary Key）或候选码（Candidate Key）。</li><li>在参照关系中，外码字段存储了关联表的键值，它用于确立两个表之间的关联。</li><li>表示为：表A包含一个外码字段，该字段引用了表B的主码或候选码，这时表A就与表B存在参照关系。</li></ul></li><li><p>被参照关系（Referenced Relationship）：</p><ul><li>“被参照关系”指的是包含主码或候选码的表，该表的键值被外码字段引用，从而使其他表可以与它建立关联。</li><li>在被参照关系中，一个表的主码或候选码通常被其他表的外码引用，这表明它在其他表中作为关联的目标。</li><li>表示为：表B的主码或候选码被表A的外码引用，这时表B就与表A存在被参照关系。</li></ul></li></ol><p>例如，考虑以下两个表：Customers（客户）和Orders（订单）。Customers 表的 CustomerID 字段是主码，而 Orders 表的 CustomerID 字段是外码。这种情况下：</p><ul><li>Customers 表是被参照关系表，因为它的主码（CustomerID）被 Orders 表的外码字段（CustomerID）引用，允许订单表与客户表建立关联，以指示哪些客户下了哪些订单。</li><li>Orders 表是参照关系表，因为它包含了外码字段（CustomerID），该字段引用了客户表的主码（CustomerID），用于建立订单表与客户表之间的关联。</li></ul><p>总之，参照关系和被参照关系描述了表之间的关联，外码与主码之间的关系非常重要，它们有助于维护数据完整性，并允许查询和检索相关数据</p><p>一个关系数据库由多个表组成，每个表有自己独一无二的名字</p><p>一个表通常内概念有 属性，元组，分量</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209203747546.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209203747546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209203747546"></p><p>概念</p><p>属性的域（domain）：属性允许的值的集合，比如年龄这个属性，允许的值是正整数</p><p>r 的所有属性的域都应该是原子的。什么原子的？域的元素被认为是不可分割的单元</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统（一）概述</title>
      <link href="/2023/12/01/Computer_system/embedded_system/0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/12/01/Computer_system/embedded_system/0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-嵌入式系统基本介绍"><a href="#1-嵌入式系统基本介绍" class="headerlink" title="1 嵌入式系统基本介绍"></a>1 嵌入式系统基本介绍</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p>嵌入式系统（Embedded System）是一种特定用途的计算机系统，它通常嵌入在更大的产品或系统中，用于控制、监测或执行特定的任务。这些系统通常由硬件和软件组成，旨在满足特定的需求，如嵌入在家电、汽车、医疗设备、工业自动化、消费电子产品、通信设备等各种应用领域。</p><p>简单说嵌入式：<strong>就是嵌入到对象体中的专用计算机系统</strong>  </p><p>三要素 嵌入 专用 计算机</p><p>嵌入式系统往往是一个较为复杂的系统，由单片机等组成，其中的核心是<strong>嵌入式处理器</strong></p><p>嵌入式系统的特点</p><p>​嵌入式面相具体的应用产品</p><p>​嵌入式软件特性</p><p>​需要软硬件开发工具和系统软件</p><p>​</p><h2 id="1-2-嵌入式微处理器分类"><a href="#1-2-嵌入式微处理器分类" class="headerlink" title="1.2 嵌入式微处理器分类"></a>1.2 嵌入式微处理器分类</h2><h3 id="1-2-1-微控制器MCU"><a href="#1-2-1-微控制器MCU" class="headerlink" title="1.2.1 微控制器MCU"></a>1.2.1 微控制器MCU</h3><p>嵌入式微控制器的典型代表是单片机这种８位的处理器,目前在嵌入式设备中仍然有着极其广泛的应用。</p><p>单片化、体积大大减小、功耗和成本降低、可靠性提高,处理器的能力非常有限</p><p>单片机芯片内部集成ROM&#x2F;EPROM、RAM、总线逻辑、定时&#x2F;计数器、I&#x2F;O、串行口、EEPROM 等各种必要功能和外设。</p><p>但MCU处理器的能力非常有限，因此提出下面的产品</p><h3 id="1-2-2-微处理器MPU"><a href="#1-2-2-微处理器MPU" class="headerlink" title="1.2.2 微处理器MPU"></a>1.2.2 微处理器MPU</h3><p>微处理器单元，功能和微处理器基本一样，是具有32位或64位的处理器,具有较高的性能。</p><p>面相移动计算，智能手机的处理器</p><h3 id="1-2-3-数字信号处理器（DSP）"><a href="#1-2-3-数字信号处理器（DSP）" class="headerlink" title="1.2.3 数字信号处理器（DSP）"></a>1.2.3 数字信号处理器（DSP）</h3><p>专门用来进行信号方面的处理的，在数字滤波，FFT，频谱分析等各种仪器上DSP获得了更大规模的应用</p><p>一般用作密集的数据处理，不适用于控制所以不适合运行操作系统</p><h3 id="1-2-4-混合处理器和片上系统（SOC）"><a href="#1-2-4-混合处理器和片上系统（SOC）" class="headerlink" title="1.2.4 混合处理器和片上系统（SOC）"></a>1.2.4 <strong>混合处理器和片上系统（SOC）</strong></h3><p>SOC（片上系统）是IC设计的发展趋势。采用SOC设计技术，可以大幅度地提高系统的可靠性,降低成本，提高性价比</p><p>结构简洁，体积小、功耗低，可靠性高，设计生产效率高</p><p>SOC芯片已经成为提高移动通信、网络、信息家电、高速计算、多媒体应用及军用电子系统性能的核心器件。</p><h3 id="1-2-5-可编程片上系统（SOPC）"><a href="#1-2-5-可编程片上系统（SOPC）" class="headerlink" title="1.2.5  可编程片上系统（SOPC）"></a>1.2.5  <strong>可编程片上系统（SOPC）</strong></h3><p>基于SOC 并且可以进行个性化编程</p><h2 id="1-3-嵌入式系统组成"><a href="#1-3-嵌入式系统组成" class="headerlink" title="1.3 嵌入式系统组成"></a>1.3 嵌入式系统组成</h2><p>粗略划分为 </p><p>嵌入式处理器 外围设备  嵌入式操作系统（可选） 嵌入式应用软件</p><p>我们往往主要涉及到软件开发部分</p><h1 id="2-嵌入式系统开发"><a href="#2-嵌入式系统开发" class="headerlink" title="2 嵌入式系统开发"></a>2 嵌入式系统开发</h1><h2 id="2-1-开发特点"><a href="#2-1-开发特点" class="headerlink" title="2.1 开发特点"></a>2.1 开发特点</h2><p>嵌入式系统和传统桌面应用开发不同，由于其资源有限所以要</p><p>1 接口方便、操作容易</p><p>2 稳定可靠、维护简便</p><p>3 功耗管理、降低成本</p><p>4  功能实用、便于升级</p><p>5  并发处理、及时响应</p><p>虽然我们开发式偏上层，但还是需要<strong>软硬件综合开发，二者密切相关</strong>。</p><h2 id="2-2-开发流程"><a href="#2-2-开发流程" class="headerlink" title="2.2 开发流程"></a>2.2 开发流程</h2><p>1 需求分析</p><p>2 体系结构设计</p><p>3 硬件 软件设计</p><p>4 系统集成</p><p>5 系统测试</p><h2 id="2-3-开发模式"><a href="#2-3-开发模式" class="headerlink" title="2.3 开发模式"></a>2.3 开发模式</h2><p>嵌入式系统软件的开发模式</p><p>需要使用交叉编译器，进行交叉开发。</p><p><strong>交叉编译</strong>（Cross-Compilation）是一种在一个计算机系统上为另一个不同架构或操作系统的目标平台生成可执行代码的编译过程。比如我在Windows电脑上生成嵌入式单片机的可执行的代码文件</p><h1 id="3-嵌入式系统的应用"><a href="#3-嵌入式系统的应用" class="headerlink" title="3 嵌入式系统的应用"></a>3 嵌入式系统的应用</h1><p>嵌入式系统在各种领域中都有广泛的应用，它们是许多现代电子设备的核心组成部分。以下是一些嵌入式系统的主要应用领域：</p><ol><li><p>汽车和交通：</p><ul><li>汽车行业是嵌入式系统的主要应用领域之一。嵌入式系统用于控制引擎管理、车辆稳定性控制、安全气囊、娱乐系统、导航系统、自动驾驶技术等。它们帮助提高驾驶安全性、效率和便利性。</li></ul></li><li><p>消费电子：</p><ul><li>嵌入式系统广泛用于各种消费电子产品，如智能手机、平板电脑、电视、音响系统、家用电器、游戏机和智能家居设备。这些系统提供了多媒体功能、连接性和用户界面，使消费者能够更好地享受生活。</li></ul></li><li><p>医疗设备：</p><ul><li>医疗行业使用嵌入式系统来开发各种医疗设备，包括体征监测设备、医用成像设备、手术机器人、药物输送系统等。这些设备可以改善医疗诊断、治疗和患者监测。</li></ul></li><li><p>工业自动化：</p><ul><li>嵌入式系统在工业自动化中发挥着关键作用，用于控制生产线、机器人、传感器、PLC（可编程逻辑控制器）等。它们提高了生产效率、质量控制和生产过程的自动化程度。</li></ul></li><li><p>物联网（IoT）：</p><ul><li>物联网是连接物理世界的嵌入式系统网络。嵌入式系统在传感器、节点设备和云端通信中发挥着关键作用，使设备能够互相通信、监测环境和执行自动化任务。</li></ul></li><li><p>航空航天：</p><ul><li>航空航天行业广泛使用嵌入式系统，包括导航和飞行控制系统、通信设备、卫星控制和地面站设备。这些系统需要极高的可靠性和性能。</li></ul></li><li><p>军事和国防：</p><ul><li>嵌入式系统在军事和国防应用中起着关键作用，包括通信、导航、雷达、无人飞行器（无人机）和武器系统。它们用于提高军事作战的效能和安全性。</li></ul></li><li><p>能源管理：</p><ul><li>嵌入式系统用于能源管理领域，包括电力网络监控、智能电表、太阳能和风能系统的控制、能源优化和电池管理。</li></ul></li><li><p>通信：</p><ul><li>通信设备、基站、路由器和网络交换设备等都使用嵌入式系统来处理和路由数据。这些系统支持互联网和通信网络的稳定运行。</li></ul></li></ol><p>总的来说，嵌入式系统在各种领域中都发挥着重要作用，为现代生活和工业生产提供了高度智能化、自动化和连接性。这些系统的应用领域不断扩展，随着技术的进步，它们将继续推动创新和改善各种行业的效率和功能。</p><p>接下来我们会重点介绍51单片机</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（十）运输层下</title>
      <link href="/2023/11/24/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/24/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h1><h2 id="4-1-邮件系统概述"><a href="#4-1-邮件系统概述" class="headerlink" title="4.1 邮件系统概述"></a>4.1 邮件系统概述</h2><p>邮件系统往往由三个主要组成构件，这就是用户代理，邮件服务器以协议</p><p>其中用户代理往往被浏览器所替代了，现在很少人用专门的用户代理程序了</p><p><strong>用户代理</strong> 就是用户与电子邮件系统的接口，大多数情况下他就是运行在用户计算机中的一个程序，用户代理向用户提供了一个很友好的接口（目前主要是图形界面）来发送和接收邮件。用户代理往往需要四个功能，撰写，显示，处理和通信</p><p><strong>邮件服务器</strong>  往往是既充当客户又充当服务器</p><p><strong>协议</strong>  协议主要由邮件发送协议（如SMTP）和邮件读取协议（如POP3）组成</p><p>电子邮件地址格式</p><p><code>用户名@邮件服务器域名</code>  如  <a href="mailto:&#x71;&#111;&#100;&#105;&#x63;&#x61;&#116;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#x6d;">&#x71;&#111;&#100;&#105;&#x63;&#x61;&#116;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#x6d;</a></p><h2 id="4-2-邮件传输协议SMTP"><a href="#4-2-邮件传输协议SMTP" class="headerlink" title="4.2 邮件传输协议SMTP"></a>4.2 邮件传输协议SMTP</h2><p>本质上是发送命令</p><p>它的工作流程可分为几个关键步骤：</p><ol><li><strong>连接建立</strong>：SMTP客户端（通常是电子邮件客户端）开始与SMTP服务器（通常是邮件发送者的邮件服务器）建立连接。这通常通过端口25进行。使用命令如<code>HELO</code>（或<code>EHLO</code>）来识别发送者。</li><li><strong>邮件发送</strong>：建立连接后，SMTP客户端会请求发送邮件。这涉及到一系列命令，用于指定发件人（<code>MAIL FROM</code>），收件人（<code>RCPT TO</code>），以及开始邮件内容的传输（<code>DATA</code>）。在<code>DATA</code>命令之后，客户端开始传输邮件的实际内容，包括邮件的头部（如主题，发送者，接收者信息）和正文。</li><li><strong>连接释放</strong>：邮件发送后，客户端发送<code>QUIT</code>命令以关闭连接。</li></ol><h2 id="4-3-邮件发送协议POP3"><a href="#4-3-邮件发送协议POP3" class="headerlink" title="4.3 邮件发送协议POP3"></a>4.3 邮件发送协议POP3</h2><p>邮局协议版本3（POP3）是一种用于从远程邮件服务器检索电子邮件的标准协议。它被设计为简单、有效，主要用于支持离线邮件处理。POP3允许电子邮件客户端下载服务器上的邮件，并通常在下载后从服务器上删除这些邮件。</p><p>它的工作流程可分为几个关键步骤</p><ol><li><strong>连接</strong>：POP3客户端（如电子邮件应用程序）与POP3服务器（通常是邮件服务提供商的服务器）通过TCP&#x2F;IP网络建立连接。这通常使用端口110，或995（用于加密连接）。</li><li><strong>用户认证</strong>：一旦建立连接，POP3客户端需要通过发送用户名和密码对自己进行认证。通常使用<code>USER</code>和<code>PASS</code>命令来完成这一过程。</li><li><strong>检索邮件列表</strong>：认证成功后，客户端可以请求邮件列表，通常使用<code>LIST</code>命令。这个命令让客户端知道邮箱中有多少邮件以及它们的大小。</li><li><strong>下载邮件</strong>：客户端使用<code>RETR</code>命令来下载单个邮件。邮件被下载到本地设备上，客户端可以决定是否在下载后从服务器上删除邮件。</li><li><strong>删除邮件</strong>：如果客户端决定删除邮件，它会使用<code>DELE</code>命令。通常，邮件不会立即从服务器上删除，而是在客户端发送<code>QUIT</code>命令、结束会话时才删除。</li><li><strong>退出</strong>：客户端使用<code>QUIT</code>命令结束会话。这个命令告诉服务器可以释放与此会话相关的所有资源，并执行任何待处理的邮件删除操作。</li></ol><h1 id="5-动态主机配置协议DHCP"><a href="#5-动态主机配置协议DHCP" class="headerlink" title="5 动态主机配置协议DHCP"></a>5 动态主机配置协议DHCP</h1><p>为了让协议软件可以移植，协议软件的编写者不会把所有的细节都固定在源代码中，他们会将其参数化，使得很多台计算机可以使用同一个经过编译的二进制代码</p><p>在协议软件中给这些参数赋值的动作叫做协议配置</p><p>例如，连接到互联网的计算机协议软件需要配置的有 IP地址，子网掩码，默认路由IP地址，域名服务器IP地址等</p><p>但是人工配置又很不方便，所以目前采用自动协议配置方法，用动态主机配置协议DHCP，提供了一种即插即用的联网方式，当一台计算机加入新的网络和获取新的IP地址时，不用手工参与</p><h1 id="6-简单网络管理协议SNMP"><a href="#6-简单网络管理协议SNMP" class="headerlink" title="6 简单网络管理协议SNMP"></a>6 简单网络管理协议SNMP</h1><p>网络管理包括对硬件，软件和人力的使用综合协调，以便对于网络资源进行监视，测试，配置，分析和评价控制这样就能以合理的价格满足网络的需求</p><p>简单网络管理协议（Simple Network Management Protocol，SNMP）是一种用于管理和监控网络设备的标准协议。它允许网络管理员通过远程方式获取有关网络设备的信息、配置设备参数、监控设备性能并执行远程管理操作。</p><ol><li><p>SNMP的历史：<br>SNMP最早由IETF（Internet Engineering Task Force）于1988年开发，最初的版本是SNMPv1。后续发展了SNMPv2c和SNMPv3，分别于1993年和1998年发布。SNMPv3是目前广泛使用的版本，它提供了更强的安全性和认证功能。</p></li><li><p>SNMP的组成：<br>SNMP由三个主要组成部分组成：</p><ul><li>SNMP管理站（Management Station）：通常是网络管理员使用的计算机或应用程序，用于远程管理和监控网络设备。</li><li>SNMP代理（Agent）：运行在网络设备上的软件，负责收集设备信息、响应管理站的请求以及执行管理操作。</li><li>MIB（Management Information Base）：是一个层次化的数据库，存储了关于网络设备的信息。MIB是SNMP的核心，它定义了可以监控和管理的对象，这些对象有唯一的标识符（OID，Object Identifier）。</li></ul></li><li><p>SNMP通信方式：<br>SNMP使用UDP协议进行通信，通常使用161端口进行管理站到代理的通信（SNMP的Trap消息则使用162端口）。通信的基本过程如下：</p><ul><li>管理站向代理发送请求消息（Get、Set、GetNext等）。</li><li>代理响应请求，并返回相应的数据或执行请求的操作。</li><li>管理站根据响应数据进行相应的管理操作。</li></ul></li><li><p>SNMP消息类型：<br>SNMP定义了不同类型的消息，包括：</p><ul><li>Get：管理站请求代理返回指定OID的数据。</li><li>Set：管理站请求代理修改指定OID的数据。</li><li>GetNext：管理站请求代理返回比指定OID大的下一个数据。</li><li>Trap：代理主动发送通知消息给管理站，用于报告事件或警告。</li></ul></li><li><p>SNMP版本和安全性：<br>SNMPv1和SNMPv2c在安全性方面存在问题，因为它们在通信中使用明文社区字符串（Community String），容易受到攻击。SNMPv3引入了更强的安全性功能，包括消息加密、认证和访问控制，以确保通信的机密性和完整性。</p></li><li><p>SNMP的用途：<br>SNMP广泛用于监控和管理各种网络设备，包括路由器、交换机、防火墙、服务器、打印机等。它允许管理员实时监控设备性能、收集数据、执行配置更改和故障排除。</p></li></ol><p>总之，SNMP是一种用于网络管理和监控的标准协议，它提供了一种方便的方式来远程管理和监视网络设备，使网络管理员能够及时响应和解决问题，以确保网络的正常运行。通过SNMP，管理员可以获取设备的状态信息、配置参数和性能数据，从而提高网络的可靠性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（九）应用层</title>
      <link href="/2023/11/23/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2023/11/23/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>之前我们讲运输层的时候已经讲了运输层可以给不同进程之间通信，但我们还需要应用层原因是，许多 应用需要多个进程之间相互配合完成，所以应用层进程用来约束这些配合！</p><p>每个应用层协议用来解决一个问题</p><p>应用层的许多协议都是基于客户服务器方式  客户是请求方，服务器是服务提供方</p><p>最重要内容</p><p>1 域名系统DNS——从域名解析出IP地址</p><p>2 万维网和HTTP协议，以及万维网的两种不同的信息搜索引擎</p><p>3 电子邮件的传输过程，SMTP协议和POP3协议，IMAP协议使用的场合</p><p>4 动态主机配置协议DHCP的特点</p><p>5 网络管理的三个组成部分</p><p>6 系统调用和应用编程接口的基本概念</p><p>7 P2P文件系统</p><h1 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1 域名系统DNS"></a>1 域名系统DNS</h1><h2 id="1-1-域名vsIP？"><a href="#1-1-域名vsIP？" class="headerlink" title="1.1 域名vsIP？"></a>1.1 域名vsIP？</h2><p>为什么给人们用域名？方便记忆，如baidu.com就比一串的IP好记</p><p>为什么给机器用IP？IP长度固定，方便机器处理</p><p>初期的时候，由于主机个数比较少，所以一台机器的hosts文件列出所有的域名和IP的对应关系，需要转换时查表即可。</p><p>目前计算机网络理论上也可以把所有的域名和IP的对应关系放到一个服务器中，但是问题是</p><p>1 地球上计算机过多，该服务器负荷太大</p><p>2 如果这台服务器出现问题，会导致整体的网络的瘫痪</p><p>所以提出树状结构的命名方法，并采用分布式的域名系统DNS（分布式就是分散的意思）这样即便某一台计算机出了问题，也不会导致整体出现问题</p><h2 id="1-2-域名结构"><a href="#1-2-域名结构" class="headerlink" title="1.2 域名结构"></a>1.2 域名结构</h2><p>域名一般由标号组成，标号间通过.分割</p><p>顶级域名，二级域名，三级域名……</p><p>顶级域名一般有</p><ul><li>国家顶级域名 如cn表示中国，us表示美国，uk表示英国等等</li><li>通用顶级域名 如com表示公司企业，org表示非盈利组织</li><li>基础结构域名 arpa 用于反向域名解析</li></ul><p>更高级的域名负责管理下属的域名</p><p>比如我国中国cn顶级域名下划分了41个二级域名（分为类别域名7个和行政区域名34个）</p><h2 id="1-3-域名到IP的解析过程"><a href="#1-3-域名到IP的解析过程" class="headerlink" title="1.3 域名到IP的解析过程"></a>1.3 域名到IP的解析过程</h2><p>先来了解域名服务器，即存放域名和IP对应的服务器</p><p><strong>域名服务器</strong></p><p>一个服务器所负责管辖的范围叫做区</p><p>各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有节点必须是联通的，每一个区设置相应的权限域名服务器用来保存该区中所有的主机的域名到IP地址的映射</p><h3 id="域名服务器类型"><a href="#域名服务器类型" class="headerlink" title="域名服务器类型"></a>域名服务器类型</h3><p><strong>根域名服务器</strong></p><p>​最重要的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址,不管是哪一个本地域名服务器，在无法解析的时候，就首先求助于根域名服务器</p><p>  在因特网上有13个不同IP地址的根域名服务器，从a到m</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231129195554528.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231129195554528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="根域名服务器分布地址"></p><p><strong>顶级域名服务器</strong>（TLD服务器）</p><p>​这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答</p><p><strong>权限域名服务器</strong></p><p>​负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器</p><p><strong>本地域名服务器</strong></p><p>​每一个因特网服务器提供者ISP，或一个大学，都可以拥有一个本地域名服务器</p><p>为了提高域名服务器的可靠性，一般把数据复制到几个域名服务器来保存</p><p>域名解析这个过程是在多个域名服务器上的多个域名服务程序共同完成的</p><p>大概过程如下</p><p>某一个应用程序请求某域名的IP  –》 生成DNS请求报文，发送给本地的域名服务器  –》如果本地可以查到的话，则返回回答报文，查不到的话就向其他域名服务器请求直到找到为止</p><p>解析过程</p><p>主机向本地域名服务器查询采用递归查询 </p><p>本地服务器向根域名服务器查询采用迭代查询</p><p>名字的高速缓存，存放最近用到的</p><p>记录集合</p><p>mx记录</p><p>ns记录</p><p>ptr记录</p><h1 id="2-文件传送协议"><a href="#2-文件传送协议" class="headerlink" title="2 文件传送协议"></a>2 文件传送协议</h1><h2 id="2-1-FTP-文件传输协议"><a href="#2-1-FTP-文件传输协议" class="headerlink" title="2.1 FTP 文件传输协议"></a>2.1 FTP 文件传输协议</h2><p>FTP是使用最广的文件传输协议</p><p>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存取权限</p><p>匿名访问通过anonymous实现</p><p>文件的传送并非很简单，原因是不同计算机厂商研制出的文件系统多达数百种，差别很大。主要体现在 </p><p>1 计算机存储数据的格式不同</p><p>2 文件目录结构和文件命名规定不同</p><p>3 存取功能的命令不同</p><p>4 访问控制方法不同</p><p>所以我们的FTP核心就是要减少或消除在不同操作系统下处理文件的不兼容性</p><p>FTP使用客户服务器方式</p><p>FTP使用两个TCP连接，一个用于控制（21端口），一个用于数据传送（20端口），因而需要两个端口号，所以数据连接和控制连接不会乱</p><p>使用两个端口的另外好处是</p><p>1 使协议更加简单和实现</p><p>2 在传输文件时还可以利用控制连接</p><h2 id="2-2-NFS-协议"><a href="#2-2-NFS-协议" class="headerlink" title="2.2 NFS 协议"></a>2.2 NFS 协议</h2><p>NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定位置开始读写数据</p><p>NFS可以使用户只复制一个大文件中的很小的片段</p><p>端口2049</p><h2 id="2-3-简单文件传送协议-TFTP"><a href="#2-3-简单文件传送协议-TFTP" class="headerlink" title="2.3 简单文件传送协议 TFTP"></a>2.3 简单文件传送协议 TFTP</h2><p>特点</p><p>1 很小易于实现</p><p>2 由于很小所以TFTP只支持文件传输而不支持交互， TFTP没有一个庞大的命令集合</p><p>3 每次传输的数据有512字节，组成一个文件块，对块进行编号，从1开始，支持ASCLL码或二进制传送，可对文件进行读或写，使用很简单的首部</p><p>工作</p><p>1 很像停止等待协议，每发送完一个文件块就等待对方确认，收不到确认就重复发送PDU</p><p>2  TFTP端口号是69</p><p>三种协议比较</p><table><thead><tr><th>协议</th><th>特点</th></tr></thead><tbody><tr><td>FTP</td><td>交互式，存取权限，建立副本</td></tr><tr><td>NFS</td><td>交互式，存取权限，无副本</td></tr><tr><td>FTFP</td><td>没有交互式，不进行身份验证</td></tr></tbody></table><p>远程终端协议TRLNET</p><h1 id="3-万维网WWW"><a href="#3-万维网WWW" class="headerlink" title="3 万维网WWW"></a>3 万维网WWW</h1><p>万维网是一个分布式的超媒体系统，它是超文本系统的扩充</p><p>万维网将大量的信息分布在整个互联网</p><p>要核心解决几个问题</p><p>1 怎样标志分别分布在整个互联网的万维网文档——用URL</p><p>2 用什么样的协议实现万维网上的各种连接——用HTTP</p><p>3 怎样使得不同作者创作不同风格的万维网文档，都能在互联网上各种主机显示 使用HTML</p><p>4 怎么样使得用户能够方便找到需要的资源——用搜索工具</p><p>接下来分别探讨下面的问题</p><h2 id="3-1-统一资源定位符URL"><a href="#3-1-统一资源定位符URL" class="headerlink" title="3.1 统一资源定位符URL"></a>3.1 统一资源定位符URL</h2><p>统一资源定位符是用来表示互联网资源的位置和获得的方法</p><p>一般组成如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议:// 主机名:端口/路径</span><br></pre></td></tr></table></figure><p>协议就是通过何种方式获得该万维网文档</p><p>主机名就是存放文档主机的域名</p><p>其中端口往往被省略，因为对于特定协议，有些端口都是默认的，比如HTTP协议默认端口号为80</p><p>所以往往是如下的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议://主机名/路径</span><br></pre></td></tr></table></figure><p>很多时候都把前面的协议省去了，只保留了主机名</p><p>比如  baidu.com</p><p>完整应该是 <a href="http://baidu.com/">http://baidu.com</a></p><h2 id="3-2-超文本传送协议HTTP"><a href="#3-2-超文本传送协议HTTP" class="headerlink" title="3.2 超文本传送协议HTTP"></a>3.2 超文本传送协议HTTP</h2><p>定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传输给浏览器</p><p>HTTP协议是无连接，无记忆状态的协议</p><p>无连接即不会提前建立连接</p><p>无状态协议，这意味着每个HTTP请求都是独立的，服务器不会在多次请求之间保留任何关于客户端的状态信息。每个HTTP请求都被视为一个独立的交互，服务器不会记住之前的请求或会话信息。</p><h3 id="3-2-1-HTTP工作流程"><a href="#3-2-1-HTTP工作流程" class="headerlink" title="3.2.1 HTTP工作流程"></a>3.2.1 HTTP工作流程</h3><p>如下</p><p>1 每个万维网网点都有一个服务器进程，它不断监听TCP端口80，以便发现是否有浏览器向它发送链接建立请求</p><p>2 监听到后，建立连接，浏览器向万维网服务器发出请求，服务器返回请求页面做相应。完成任务后，TCP就被释放了</p><p>对于早期的HTTP协议 HTTP&#x2F;1.0，请求一个万维网文档耗费时间是文档传输时间加上两倍往返时间RTT（一个RTT用于建立TCP连接，另一个RTT用于请求和接收万维网文档）</p><p>这是它的一个缺点</p><p>因而HTTP&#x2F;1.1 很好解决了这个问题，它使用了持续连接的方法，就是说万维网服务器在相应之后的一段时间依然保持这个连接</p><p>后来又提出升级版本 HTTP&#x2F;2，将服务器的相应也变成了并行的，同时可以复用TCP连接的请求，</p><p>为了加快请求相应速度，往往会用到代理服务器，即将最近的一些请求和相应放到本地磁盘中 </p><h3 id="3-2-2-HTTP报文结构"><a href="#3-2-2-HTTP报文结构" class="headerlink" title="3.2.2 HTTP报文结构"></a>3.2.2 HTTP报文结构</h3><p>HTTP两类报文</p><p>1 请求报文——从客户到服务器发送请求报文</p><p>2 相应报文——从服务器到客户的回答</p><p>HTTP请求报文由客户端发送给服务器，用于请求特定资源或执行特定操作。它通常包括以下部分：</p><ul><li><p><strong>请求行（Request Line）：</strong> 包含了HTTP方法、请求的URI和HTTP协议版本。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure><p>以下是一些常见的HTTP请求方法：</p><ol><li><strong>GET</strong>：用于请求服务器发送指定资源的内容。GET请求通常用于获取数据，不应该对服务器端数据产生影响。GET请求的参数通常附在URL的查询字符串中。</li><li><strong>POST</strong>：用于向服务器提交数据，通常用于创建新资源。POST请求将数据包含在请求体中，而不是URL中。</li><li><strong>PUT</strong>：用于请求服务器更新或替换指定的资源，通常用于更新已存在的资源。PUT请求将数据包含在请求体中，并且通常会覆盖原始资源。</li><li><strong>DELETE</strong>：用于请求服务器删除指定的资源。DELETE请求用于删除服务器上的资源。</li><li><strong>PATCH</strong>：用于对资源进行部分更新。与PUT不同，PATCH只更新资源的一部分，而不是整个资源。</li><li><strong>HEAD</strong>：类似于GET请求，但服务器只返回响应头部信息，而不返回实际内容。通常用于获取资源的元数据或检查资源是否存在。</li><li><strong>OPTIONS</strong>：用于获取服务器支持的HTTP方法和资源的信息。客户端可以使用OPTIONS请求来了解服务器允许哪些方法和资源访问。</li><li><strong>TRACE</strong>：用于测试与服务器之间的连接，客户端发送一个TRACE请求，服务器返回请求的内容，以便客户端可以查看请求在传输过程中是否被修改。</li><li><strong>CONNECT</strong>：通常用于创建与服务器的网络连接，通常用于代理服务器。</li></ol></li><li><p><strong>请求头部（Request Headers）：</strong> 包含了一系列的键值对，用于传递关于请求的信息，如User-Agent、Host、Accept等。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept: text/html</span><br></pre></td></tr></table></figure></li><li><p><strong>空行（Blank Line）：</strong> 请求行和请求头之间有一个空行，用于分隔请求头部和请求体。</p></li><li><p><strong>请求体（Request Body）：</strong> 可选的部分，通常用于POST请求等情况，包含了要发送给服务器的数据。</p></li></ul><ol><li><strong>HTTP响应报文结构：</strong></li></ol><p>HTTP响应报文由服务器发送给客户端，用于回复客户端的请求。它通常包括以下部分：</p><ul><li><p><strong>状态行（Status Line）：</strong> 包含了HTTP协议版本、状态码和状态描述。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><ol><li>HTTP状态码根据其首位数字分为五大类，每个类别都表示了不同的意义。这五大类是：<ol><li><strong>1xx（Informational，信息性状态码）</strong>：这些状态码表示请求已被接收，正在处理或者需要进一步的操作。这些状态码通常不会在实际应用中经常见到，而更多用于HTTP协议的通信过程中。</li><li><strong>2xx（Successful，成功状态码）</strong>：这些状态码表示请求已成功被服务器接受、理解并处理。最常见的是200 OK，表示成功处理了请求。</li><li><strong>3xx（Redirection，重定向状态码）</strong>：这些状态码表示客户端需要采取额外的操作来完成请求。通常用于重定向到其他URL以获取请求的资源。</li><li><strong>4xx（Client Error，客户端错误状态码）</strong>：这些状态码表示客户端发送的请求有错误，无法被服务器理解或处理。最常见的是404 Not Found，表示请求的资源不存在。</li><li><strong>5xx（Server Error，服务器错误状态码）</strong>：这些状态码表示服务器在处理请求时发生了错误。最常见的是500 Internal Server Error，表示服务器内部发生了错误。</li></ol></li></ol></li><li><p><strong>响应头部（Response Headers）：</strong> 类似于请求头部，包含了一系列的键值对，用于传递关于响应的信息，如Server、Content-Type、Content-Length等。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1234</span><br></pre></td></tr></table></figure></li><li><p><strong>空行（Blank Line）：</strong> 状态行和响应头之间有一个空行，用于分隔响应头部和响应体。</p></li><li><p><strong>响应体（Response Body）：</strong> 包含了服务器返回的实际数据，例如HTML页面、JSON数据等。</p></li></ul><h3 id="3-2-3-HTTP服务器存放用户信息"><a href="#3-2-3-HTTP服务器存放用户信息" class="headerlink" title="3.2.3 HTTP服务器存放用户信息"></a>3.2.3 HTTP服务器存放用户信息</h3><p>之前讲到HTTP是无状态的，即不会保留客户端信息，但有些时候，服务器需要记住用户的信息，比如一个顾客要购买多件物品放入购物车，以便集中结账</p><p>这时候需要用到Cookie</p><p>工作流程如下：</p><ol><li><p><strong>创建Cookie：</strong> 服务器在HTTP响应中通过<code>Set-Cookie</code>头部字段创建Cookie，并将其发送到客户端浏览器。Cookie包含一个键值对，通常是一个名称和一个值，以及一些其他属性，如过期时间、域名、路径等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: username=johndoe; expires=Sat, 31 Dec 2023 23:59:59 GMT; path=/; domain=example.com; secure; HttpOnly</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，服务器创建了一个名为<code>username</code>的Cookie，它的值是<code>johndoe</code>，并设置了过期时间、路径、域名等属性。</p></li><li><p><strong>存储Cookie：</strong> 一旦浏览器接收到Cookie，它会将Cookie存储在本地的Cookie存储中。这个存储通常是浏览器的内存或磁盘中的一个文件。</p></li><li><p><strong>发送Cookie：</strong> 当浏览器向同一服务器发出后续HTTP请求时，它会将与该服务器相关的Cookie附加到请求的<code>Cookie</code>头部字段中。这使得服务器能够识别用户并访问之前存储的信息。</p></li><li><p><strong>服务器读取Cookie：</strong> 服务器在收到HTTP请求时，会检查请求的<code>Cookie</code>头部字段以获取相关的Cookie信息。这允许服务器识别用户，并根据需要执行特定的操作，如验证用户身份、提供个性化内容等。</p></li><li><p><strong>更新Cookie：</strong> 服务器可以在HTTP响应中更新或修改Cookie的内容，以便在客户端的下一次请求中反映这些更改。例如，服务器可以更新Cookie的过期时间或值。</p></li></ol><h2 id="3-3-超文本标记语言HTML"><a href="#3-3-超文本标记语言HTML" class="headerlink" title="3.3 超文本标记语言HTML"></a>3.3 超文本标记语言HTML</h2><p>他不是协议，只是一种语言</p><p>HTML的基本概述：</p><ol><li><strong>标记语言：</strong> HTML是一种标记语言，它使用一系列的标签（标记）来描述文档的结构和内容。标签通常由尖括号<code>&lt; &gt;</code>包围，如<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>等。</li><li><strong>超文本：</strong> HTML的全名是”Hypertext Markup Language”，其中的”Hypertext”表示超文本。HTML允许文档中的内容之间建立超链接，用户可以通过点击链接来导航到其他页面或资源。</li><li><strong>结构：</strong> HTML文档通常由多个部分组成，包括<code>&lt;!DOCTYPE&gt;</code>声明、<code>&lt;html&gt;</code>元素、<code>&lt;head&gt;</code>元素（包含文档的元数据信息）、<code>&lt;title&gt;</code>元素（指定页面标题）、<code>&lt;body&gt;</code>元素（包含页面的主要内容）等。</li><li><strong>元素和属性：</strong> HTML由各种不同类型的元素组成，每个元素有其特定的含义和用途。元素可以包含其他元素，形成嵌套结构。元素通常具有属性，用于提供有关元素的额外信息。例如，<code>&lt;a&gt;</code>元素用于创建超链接，它可以包含<code>href</code>属性，指定链接的目标URL。</li><li><strong>文本内容：</strong> HTML用于定义文本内容，包括标题、段落、列表、表格、图像等。通过HTML标签，可以将文本格式化、分段、组织和呈现。</li><li><strong>样式和布局：</strong> HTML通过标签定义文档的结构和内容，但通常需要使用CSS（Cascading Style Sheets）来定义页面的样式和布局。CSS允许开发人员控制文本和元素的外观，包括颜色、字体、大小、间距等。</li><li><strong>交互性：</strong> HTML也可以与JavaScript一起使用，以实现页面的交互性和动态行为。JavaScript可以通过DOM（Document Object Model）访问和操作HTML元素，使用户能够与页面交互。</li></ol><h2 id="3-4-搜索工具"><a href="#3-4-搜索工具" class="headerlink" title="3.4 搜索工具"></a>3.4 搜索工具</h2><p>搜索引擎是一种用于查找和检索互联网上的信息的计算机程序或工具。它们允许用户输入关键词或查询，并返回与这些关键词相关的网页、文档、图片、视频和其他多媒体内容的搜索结果列表。搜索引擎在互联网上广泛使用，是人们获取信息、解决问题和进行研究的重要工具。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（八）运输层下</title>
      <link href="/2023/11/22/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/22/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="3-运输层主要协议-TCP-概述"><a href="#3-运输层主要协议-TCP-概述" class="headerlink" title="3 运输层主要协议 TCP 概述"></a>3 运输层主要协议 TCP 概述</h1><h2 id="3-1-TCP概述-特点"><a href="#3-1-TCP概述-特点" class="headerlink" title="3.1 TCP概述 特点"></a>3.1 TCP概述 特点</h2><p>TCP是面向连接的运输协议</p><ul><li>每一条TCP只能有两个端点，点对点</li><li>提供可靠的全双工交付</li><li>面向字节流，但占用很多资源</li><li>不提供广播和多播服务</li></ul><p>所以从某种意义来说</p><p>UDP是一种更加有效的工作方式</p><p>TCP面向流的概念</p><p>把字节写入发送缓冲，加上TCP首部构成TCP报文段，从接收缓存读取字节，到接收方</p><h2 id="3-2-TCP连接"><a href="#3-2-TCP连接" class="headerlink" title="3.2 TCP连接"></a>3.2 TCP连接</h2><p>TCP的连接端点叫做套接字（端口号拼接到IP地址构成了套接字）</p><p>套接字socket&#x3D;（IP地址：端口号） 如(192.268.2.2:80)</p><p>对于要实现传送，可靠传送，拥塞控制等，某些状态信息是必要的。从发送方主机和接收方主机上预留的资源，中间系统不必为主机预留资源</p><h2 id="RSVP资源预留协议"><a href="#RSVP资源预留协议" class="headerlink" title="RSVP资源预留协议"></a>RSVP资源预留协议</h2><p>是在终端和路由器之间进行业务质量参数协商的信令协议</p><p>商量预留带宽和缓冲区的大小</p><p>双向资源预留</p><p>TCP可靠传输明白数据分组中的序号代表发送的起始位置，确认号</p><h1 id="4-TCP可靠传输"><a href="#4-TCP可靠传输" class="headerlink" title="4 TCP可靠传输"></a>4 TCP可靠传输</h1><h2 id="4-1-可靠传输工作原理"><a href="#4-1-可靠传输工作原理" class="headerlink" title="4.1 可靠传输工作原理"></a>4.1 可靠传输工作原理</h2><h3 id="4-1-1-停止等待协议"><a href="#4-1-1-停止等待协议" class="headerlink" title="4.1.1 停止等待协议"></a>4.1.1 停止等待协议</h3><p>就是每发送完一个分组就停止发送，等待对方确认，在收到确认之后再发送下一个分组</p><p>全双工通信的双方既是发送方也是接收方</p><p>假设我们发送方是A，接收方是B</p><p>发送消息$M_0,M_1……$</p><p><strong>无差错情况</strong></p><p>即A发送，B确认后正常返回确认信息</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142255828.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142255828.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图示"></p><p><strong>出现差错</strong></p><p>出现差错有两种情况</p><p>情况一：发送信息没有到达接收方B，接收方B自然不会向发送方A传输确认信息</p><p>情况二：接收方B检测出了错误，直接丢弃，也不会给发送方A传输确认信息</p><p>那么A怎么判断是否出现差错呢？就是通过<strong>超时重传</strong>（设置一个超时计时器） 等一段时间如果没有收到确认信息，则认为传输差错，重传</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142847341.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142847341.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图示"></p><p><strong>确认丢失和确认迟到</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220143104496.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220143104496.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图示"></p><p>这种情况发生在接收方向发送方发送确认信息的时候，确认信息丢失</p><p>导致A以为B没有正确收到，就会导致重复发送M信息，然后B收到重复的M之后，处理是</p><p>第一步 丢弃重复的M </p><p>第二步 向A再发送确认信息</p><p>停止等待协议优点是简单</p><p>缺点是信道利用率太低</p><p>采用了流水线式的传输</p><h3 id="4-1-2-连续ARQ协议"><a href="#4-1-2-连续ARQ协议" class="headerlink" title="4.1.2 连续ARQ协议"></a>4.1.2 连续ARQ协议</h3><p>连续ARQ协议会设置一个滑动窗口，窗口内部的是可以进行发送的，发送方每收到一个确认，就把发送窗口向前移动一个分组的位置。</p><p>接收方一般都采用累积确认方法，也就是说不必逐个发送确认，而是收到几个分组之后，对按序到达的最后一个分组发送确认（这就表示到目前为止所有分组发送都正确的）</p><p>优点是：容易实现</p><p>缺点是：不能向发送方及时反映接收方收到的消息</p><h2 id="4-2-TCP可靠通信的具体实现"><a href="#4-2-TCP可靠通信的具体实现" class="headerlink" title="4.2 TCP可靠通信的具体实现"></a>4.2 TCP可靠通信的具体实现</h2><p>具体实现方式之前，先了解TCP报文段首部格式</p><p>TCP面向字节流，但是传输单元是报文段</p><p>一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中各字段的作用。</p><p>TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项</p><h3 id="4-2-1-以字节为单位的滑动窗口"><a href="#4-2-1-以字节为单位的滑动窗口" class="headerlink" title="4.2.1 以字节为单位的滑动窗口"></a>4.2.1 以字节为单位的滑动窗口</h3><p>首先对于发送方有一个发送窗口，接收方有一个接收窗口</p><p>发送方根据接收方传来的确认号与自己的发送窗口大小构建窗口或者移动窗口</p><p>接收方不断确认，然后按序交付给高层</p><h3 id="4-2-2-超时重传时间的选择"><a href="#4-2-2-超时重传时间的选择" class="headerlink" title="4.2.2 超时重传时间的选择"></a>4.2.2 超时重传时间的选择</h3><p>$RTO&#x3D;(1-\alpha)RTO+\alpha RTT$</p><p>前面我们讲到TCP发送方在规定时间没有收到则要进行重传</p><p>重传时间的选择是非常复杂的</p><p>TCP采用了一种自适应的算法</p><p>它记录一个报文段发送出去的时间，以及收到相应的确认的时间。这两个时间之差就是**报文段往返时间$RTT$**，为了结果更加平滑，引入了加权平均往返时间$RTT_s$</p><p>每测量一个新的RTT样本，进行一次重新的计算</p><p>$新RTT_S&#x3D;(1-a)×(旧的RTT_S)+a×(新的RTT样本)$</p><p>a是一个常数，一般选择0.125</p><p>最后我们的超时重传时间RTO应略大于上面得出的加权平均往返时间$RTT_S$</p><p>实际计算</p><p>$RTO&#x3D;RTT_S+RTT_D$</p><p>$RTT_D$是RTT的偏差加权平均值</p><h3 id="4-2-3-选择确认SACK"><a href="#4-2-3-选择确认SACK" class="headerlink" title="4.2.3 选择确认SACK"></a>4.2.3 选择确认SACK</h3><p>还有一个问题，就是如果收到的报文没有差错，只是未按序号，中间还缺少一些</p><p>那么能否只传输缺少的数据，而不传输已经正确到达的</p><p>是可以的，选择确认就是一种可行的处理方法SACK</p><p>这个SACK是可以选择的，双方通信可以约定好，如果使用的话会造成更大开销</p><h1 id="5-TCP的流量控制"><a href="#5-TCP的流量控制" class="headerlink" title="5 TCP的流量控制"></a>5 TCP的流量控制</h1><p>一般来说，我们总是希望数据传输的快一些，但是如果发送方数据传输过快，那么接收方就来不及接收而造成数据丢失，所以需要流量控制——让发送方的发送速率不要太快，让接收方来得及接收</p><h2 id="5-1-滑动窗口实现"><a href="#5-1-滑动窗口实现" class="headerlink" title="5.1 滑动窗口实现"></a>5.1 滑动窗口实现</h2><p>实际就是通过如果发送方发现发过去会导致丢失，那么则减小滑动窗口的大小</p><ol><li><strong>糊涂窗口综合征</strong>：当发送方和接收方对滑动窗口的大小以及如何控制它的方式存在一些不一致或不清晰的理解时，就会出现糊涂窗口综合征。这可能导致以下问题：<ul><li><strong>窗口过小</strong>：如果接收方认为滑动窗口太小，无法有效利用可用的带宽，可能会导致数据传输速度变慢，从而浪费了网络资源。</li><li><strong>窗口过大</strong>：如果发送方认为滑动窗口可以更大，但接收方不能及时处理或确认所有数据包，就会导致拥塞和丢包问题。</li><li><strong>滑动窗口不同步</strong>：如果发送方和接收方之间的窗口大小或滑动窗口控制逻辑不一致，可能会导致数据包的重传和混淆，从而使网络性能下降。</li></ul></li><li><strong>解决方法</strong>：要解决糊涂窗口综合征，需要确保发送方和接收方之间对于窗口大小和滑动窗口控制的方式达成一致。这可以通过更好地协调和调整滑动窗口参数，以及在网络中实施拥塞控制策略来实现。</li></ol><p>$最大吞吐量&#x3D;\frac{窗口大小}{RTT}$</p><p>注意需要统一单位 最大吞吐量是bit&#x2F;s </p><p>所以窗口大小&#x3D;字节数*8   RTT要转换为s</p><h1 id="6-TCP拥塞控制"><a href="#6-TCP拥塞控制" class="headerlink" title="6 TCP拥塞控制"></a>6 TCP拥塞控制</h1><h2 id="6-1-拥塞控制一般原理"><a href="#6-1-拥塞控制一般原理" class="headerlink" title="6.1 拥塞控制一般原理"></a>6.1 拥塞控制一般原理</h2><p>当对网络中的某一资源的需求大于网络能够提供的资源时，则会产生拥塞，导致网络性能变坏，因而要进行拥塞控制</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231107164703168.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231107164703168.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="拥塞控制所起的作用图示"></p><h2 id="6-2-拥塞控制的方法"><a href="#6-2-拥塞控制的方法" class="headerlink" title="6.2 拥塞控制的方法"></a>6.2 拥塞控制的方法</h2><h3 id="1-慢开始"><a href="#1-慢开始" class="headerlink" title="1 慢开始"></a>1 慢开始</h3><p>拥塞窗口用来反映当前网络的这个拥塞情况，越大说明越拥塞</p><p>​用来确定网络的负载能力，核心由小到大逐渐增大拥塞窗口数值</p><p>​初始拥塞窗口cwnd的设置：</p><p>​旧规定，先把初始拥塞窗口cwnd设置为1到2个发送方最大报文段SMSS的数值</p><p>​新的RFC 5681 把初始拥塞窗口cwnd设置为不超过2到4个SMSS数值</p><p>慢开始门限</p><p>拥塞窗口控制方法：</p><p>​在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值</p><p>使用慢开始算法后，没经过一个传输轮次，拥塞窗口cwnd就加倍</p><p>一个传输轮次所经历的时间就是往返时间RTT。传输轮次更加强调：把拥塞窗口cwnd所允许发送的报文段都连续</p><p>设置一个慢开始门限ssthresh，</p><p>当cwnd&lt;ssthresh 使用慢开始算法</p><p>当cwnd&gt;ssthresh 改为使用拥塞避免算法</p><h3 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2 拥塞避免"></a>2 拥塞避免</h3><p>​让拥塞窗口缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口+1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长</p><p>因此，在拥塞避免阶段就有点“加法增大”特点</p><p>当出现拥塞的时候，减少分组数</p><h3 id="3-快重传"><a href="#3-快重传" class="headerlink" title="3 快重传"></a>3 快重传</h3><p>让对方尽早知道发生了个别报文段的丢失</p><p>快重传算法首先要求接收方不要等待自己发送数据才进行捎带确认，而不是立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</p><p>当发送方一连收到三个重复确认，就知道接收方确实没有收到报文段，因而立即进行重传</p><h3 id="4-快恢复"><a href="#4-快恢复" class="headerlink" title="4 快恢复"></a>4 快恢复</h3><p>当发送方一连收到三个重复确认，不认为此时发生了拥堵</p><p>因而不执行慢开始算法，而是执行快恢复算法</p><h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>就是不要等到路由器的队列长度已经达到最大值的时候才不得不丢弃后面到达的分组，这样就太被动了</p><p>应当在队列长度到达某个值得警惕的数值时，就主动丢弃到达的分组</p><h1 id="7-TCP运输连接管理"><a href="#7-TCP运输连接管理" class="headerlink" title="7 TCP运输连接管理"></a>7 TCP运输连接管理</h1><h2 id="7-1-TCP的建立"><a href="#7-1-TCP的建立" class="headerlink" title="7.1 TCP的建立"></a>7.1 TCP的建立</h2><p>​TCP建立的过程叫做握手</p><p>​握手需要再客户和服务器之间交换三个TCP报文段，称之为三报文段握手</p><p>​采用三报文段握手主要为了防止已失效的连接请求报文段突然又传送到了，因而产生错误</p><h2 id="7-2-TCP的连接释放"><a href="#7-2-TCP的连接释放" class="headerlink" title="7.2 TCP的连接释放"></a>7.2 TCP的连接释放</h2><p>​四次握手</p><p>​为什么四次，核心原因就是因为全双工的原因！</p><p>TCP的有限状态机</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（七）运输层上</title>
      <link href="/2023/11/21/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2023/11/21/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运输层概述"><a href="#1-运输层概述" class="headerlink" title="1 运输层概述"></a>1 运输层概述</h1><h2 id="1-1-运输层存在的意义"><a href="#1-1-运输层存在的意义" class="headerlink" title="1.1 运输层存在的意义"></a>1.1 运输层存在的意义</h2><p>之前我们讲网络层的时候，已经可以将信息从一个主机传递到另一个主机了。</p><p>那么为什么我们还需要运输层呢？</p><p>是因为我们两个主机通信的时候，大多数情况是两个主机不同的进程在通信，比如我们浏览器访问需要一个进程，发邮件又需要一个进程。很多时候这些进程都是并行通信的。那么网络层是无法区分的，实际的区分通信的不同进程就交给了运输层，这也是运输层的重要作用——复用和分用</p><p>当然除了复用和分用，运输层还提供一些其他的功能如差错检测等</p><p>应用层不同进程的报文通过不同的端口向下交付到运输层</p><p>运输层提供应用进程的逻辑通信——逻辑通信的意思是：运输层之间的通信好像是沿着水平方向传送数据，但事实上这两个运输层之间并没有一条水平方向的物理连接</p><p>所以总结来看</p><p>网络层和运输层的区别</p><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信</p><h2 id="1-2-运输层协议概述"><a href="#1-2-运输层协议概述" class="headerlink" title="1.2 运输层协议概述"></a>1.2 运输层协议概述</h2><p>运输层主要有两个不同的运输协议</p><p> TCP和UDP</p><p>他们各自的PDU（运输协议单元如下）</p><p>UDP：它的PDU是TCP报文段</p><p>TCP：它的PDU是UDP报文段或用户数据报</p><p>那么实际中运输层如何区分不同的进程呢？通过抽象了端口号这种方式</p><p>由此可见，两个计算机中的进程需要对方的IP地址，还要知道对方的端口号（为了找到对方计算机中的应用程序）</p><p>不同端口号代表不同进程。</p><p>设计者们对端口号做了如下一些规定</p><h2 id="1-3-主要端口号"><a href="#1-3-主要端口号" class="headerlink" title="1.3 主要端口号"></a>1.3 主要端口号</h2><p>两大类端口</p><p>（1）服务端使用的端口号</p><p>又分为两大类</p><p><strong>熟知端口</strong>，数值一般为0~1023</p><p>​熟知端口号用来指派给TCP&#x2F;IP最重要的一些程序，如下图所示</p><p><strong>登记端口</strong>，数值为1024~49151</p><p>​没有数值端口使用的，使用的话必须登记</p><p>（2）客户端使用的端口号</p><p><strong>短暂端口号</strong>，数值49152~65535</p><p>​仅在客户端进程运行时动态选择，因此又叫做短暂端口号</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106172846757.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106172846757.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="常用熟知端口"><br>下面分别讨论UDP和TCP</p><p>其中UDP比较简单</p><h1 id="2-运输层主要协议-UDP"><a href="#2-运输层主要协议-UDP" class="headerlink" title="2 运输层主要协议 UDP"></a>2 运输层主要协议 UDP</h1><p>UDP只在IP数据报上增加了很少一点的功能，即端口功能和差错检测的功能</p><h2 id="2-1-UDP的特点"><a href="#2-1-UDP的特点" class="headerlink" title="2.1 UDP的特点"></a>2.1 UDP的特点</h2><ol><li>UDP是一种无连接协议</li></ol><ul><li>提供无连接服务  传送数据前不需要先建立连接</li><li>不提供可靠交付   对方的运输层在收到UDP报文后，不需要给出任何确认</li></ul><ol start="2"><li>尽最大努力交付</li><li>没有拥塞控制</li><li>UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>对于应用层的报文，不合并不拆分，多长就都发送</li><li>UDP首部开销较小</li></ol><h2 id="2-2-UDP首部格式"><a href="#2-2-UDP首部格式" class="headerlink" title="2.2 UDP首部格式"></a>2.2 UDP首部格式</h2><p>UDP首部很简单就八个字节，由四个字段组成，每个字段长度都是2字节</p><ol><li>源端口  </li><li>目的端口</li><li>长度   数据报长度，最小值是8</li><li>检验和    检测传输中是否有错</li></ol><h2 id="2-3-UDP工作流"><a href="#2-3-UDP工作流" class="headerlink" title="2.3 UDP工作流"></a>2.3 UDP工作流</h2><p>如果接收方UDP发现报文端口号不正确，就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</p><p>对于UDP的差错检测，和IP数据报检测方法类似</p><ol><li><p>首先，将UDP首部中的检验和字段置为0，以便进行计算。</p></li><li><p>将UDP伪首部添加到UDP数据包前面。伪首部包含了一些IP层的信息，用于计算检验和。伪首部的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Source IP Address (32 bits)</span><br><span class="line">Destination IP Address (32 bits)</span><br><span class="line">Reserved (8 bits, 值为0)</span><br><span class="line">Protocol (8 bits, UDP的协议值为17)</span><br><span class="line">UDP Length (16 bits, UDP首部+UDP数据的总长度)</span><br></pre></td></tr></table></figure><p>伪首部中的字段分别是源IP地址、目标IP地址、保留字段、协议字段（UDP的协议值为17）和UDP长度字段。这些字段一起构成了伪首部。</p></li><li><p>将UDP伪首部的各字段以及UDP首部和UDP数据中的所有16位字（如果数据不是16位的倍数，需要填充0使其满足16位字的条件）进行按位求和。这意味着将它们视为16位整数，将它们相加，如果结果溢出，则将溢出部分加到总和的末尾。</p></li><li><p>取总和的反码（将所有位取反，1变为0，0变为1），并将结果存储在UDP首部的检验和字段中。</p></li><li><p>发送方将带有计算后的检验和字段的UDP数据包发送到目标主机。</p></li><li><p>接收方在收到UDP数据包后，重复以上步骤，计算接收方的检验和。</p></li><li><p>接收方将计算得到的检验和与UDP首部中的检验和字段进行比较。如果它们匹配，说明数据包未损坏；如果不匹配，说明数据包可能已损坏或被篡改，接收方可以选择丢弃这个数据包。</p></li></ol><p>总之，UDP检验和用于检测UDP数据包在传输过程中的完整性，但它不提供数据包的可靠传输和重传机制。如果检验和不匹配，接收方可以选择忽略数据包或向上层报告错误，但UDP本身不会进行重传。这是与TCP不同的地方，TCP提供了可靠的数据传输和重传机制。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（六）网络层下</title>
      <link href="/2023/11/20/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/20/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="5-IPv6"><a href="#5-IPv6" class="headerlink" title="5 IPv6"></a>5 IPv6</h1><p>由于IPv4不够用了，所以后面用了范围更大的IPv6</p><p>主要变化如下</p><p>1 将地址从IPbv4的32位变到了128位</p><p>2 扩展的地址层次结构</p><p>3 更加灵活的首部格式</p><h2 id="5-1-组成"><a href="#5-1-组成" class="headerlink" title="5.1 组成"></a>5.1 组成</h2><p>由两大部分组成，即基本首部和后面的有效载荷（有效载荷允许有多个扩展首部）</p><h2 id="5-2-IPv6地址"><a href="#5-2-IPv6地址" class="headerlink" title="5.2 IPv6地址"></a>5.2 IPv6地址</h2><p>由于IPv6很大很大，所以原本的点分十进制也不够方便了</p><p>所以现在IPb6使用冒号十六进制法</p><p>比如如下：</p><p>68E6:8C64:0000:0000:0:1180:960A:FFFF</p><p>对于连续的零可以进行压缩表示，用双冒号替代</p><p>FF05:0:0:0:0:0:0:B3</p><p>如上面可以压缩为FF05::B3</p><p>为了不发生歧义，一个地址规定只能使用一次零压缩</p><p>本地链接单播地址 由fe90打头</p><p>本地连接单播地址就是二层地址，不能跨路由器通信</p><h2 id="5-3-从IPv4向IPv6过渡"><a href="#5-3-从IPv4向IPv6过渡" class="headerlink" title="5.3 从IPv4向IPv6过渡"></a>5.3 从IPv4向IPv6过渡</h2><p>介绍两种过渡方法</p><h3 id="5-3-1-双协议栈"><a href="#5-3-1-双协议栈" class="headerlink" title="5.3.1 双协议栈"></a>5.3.1 双协议栈</h3><p>双协议栈是指完全过渡到IPv6之前，一部分主机或路由器同时装有IPv4和IPv6这两种协议栈</p><p>在和IPv4主机通信的时候采用IPv4，在和IPv6主机通信的时候采用IPv6</p><p>但是这种过渡方式代价太大，需要安装两套协议，所以提出下面的隧道技术</p><h3 id="5-3-2-隧道技术"><a href="#5-3-2-隧道技术" class="headerlink" title="5.3.2 隧道技术"></a>5.3.2 隧道技术</h3><p>隧道技术核心就是在IPv6进入网络前 进行封装为IPv4帧传输，这样接收方接收到IPv6数据报后再解析IPv6数据报</p><p>隧道技术实际上也会用到双协议栈，只不过只在入网和出网的时候安装两个就行，中途的主机都不需要安装</p><h1 id="6-因特网的路由选择协议"><a href="#6-因特网的路由选择协议" class="headerlink" title="6 因特网的路由选择协议"></a>6 因特网的路由选择协议</h1><p>路由选择核心就是讨论转发表中的路由是怎么得出来的</p><p>理想的路由算法要尽可能</p><p>正确完整，简单，稳定且公平</p><p>对于路由选择协议，按照是否自适应调整可以划分为静态路由选择策略和动态路由选择策略</p><p>其中</p><ul><li>静态路由选择策略——即非自适应路由选择，简单开销小，人工配置每一条路由</li><li>动态路由选择策略——即自适应路由选择，开销大，实现较为复杂，但是可以很好适应网络状态变化</li></ul><p>我们可以把互联网划分为许多较小的自治系统AS，自治系统内部可以使用自己的路由选择协议，然后整体又可以连接到整个互联网上</p><p>那么在自治系统内部的使用的协议又叫做内部网关协议IGP，如RIP，OSPF</p><p>源主机和目的主机不在同一个自治系统叫做外部网关协议EGP，如BGP-4</p><h2 id="6-1-内部网关协议RIP"><a href="#6-1-内部网关协议RIP" class="headerlink" title="6.1 内部网关协议RIP"></a>6.1 内部网关协议RIP</h2><p>了解路由选择协议，核心要解决三个问题——和哪些路由器交换信息？交换什么信息？在什么时候交换信息？</p><p>对于RIP而言</p><p>1 交换的对象是：只和相邻的路由器交换信息</p><p>2 交换的信息是：自己现在的路由表</p><p>3 交换的时间是：按照固定时间间隔交换信息，每隔30s</p><p>路由表更新的原则是 距离向量算法</p><p>看下面的例子</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082452887.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082452887.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算更新例题" style="zoom:33%;" /><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082513161.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082513161.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="路由表更新" style="zoom:33%;" />总结来看<p>首先是否是新信息</p><p>再看下一跳是否相同，这两种情况直接更新</p><p>如果下一跳不同的话比较距离</p><p>优点 开销较小，实现简单 </p><p>缺点 限制了网络规模，使用最大距离为15。同时好消息传递的快，坏消息传递的慢！！网络出故障后的传播时间很慢</p><h2 id="6-2-内部网关协议-OSPF"><a href="#6-2-内部网关协议-OSPF" class="headerlink" title="6.2 内部网关协议 OSPF"></a>6.2 内部网关协议 OSPF</h2><p>上述的RIP缺点是不能适用于较大规模的自治系统</p><p>所以使用OSPF，通过复合度量选择路由</p><p>同样回答三个问题——和哪些路由器交换信息？交换什么信息？在什么时候交换信息？</p><p>对于RIP而言</p><p>1 交换的对象是：和所有该区域的路由器交换</p><p>2 交换的信息是：自己现在的路由表</p><p>3 交换的时间是：按照固定时间间隔交换信息，每隔30s</p><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><p>1 带宽是主要考虑的因素</p><p>2 使用的是洪泛法，就是路由器通过输出端口向所有路由器发送信息</p><p>3 所有路由器最终建立链路状态数据库，全网范围内一致，因而克服了RIP的缺点（RIP只知道相邻的）保证了更新过程中收敛的快</p><p>同时为了能让他应用于更大规模的网络</p><p>进行了区域的划分</p><p>每次只需要对该（主干）区域做洪泛即可，因而也只需要知道主干区域的完整拓扑结构即可</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025084129538.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025084129538.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IP数据报" style="zoom:33%;" /><p>ＯＳＰＦ有五种类型</p><p>​1 问候分组 确定是否可达</p><p>​2 数据库描述分组  达到数据库的同步</p><p>​3 链路状态请求  新情况下的同步</p><p>​4 链路状态更新</p><p>​5 链路状态确认</p><h2 id="6-3-外部网关协议-BGP"><a href="#6-3-外部网关协议-BGP" class="headerlink" title="6.3 外部网关协议 BGP"></a>6.3 外部网关协议 BGP</h2><p>使得前面的自治系统连为一个整体！！！</p><p>力求寻找较好的路由，不要兜圈子即可，不用最短的</p><p>内部的路由器建立iBGP连接，而内部和外部直接建立eBGP连接</p><p>BGP发言人，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人</p><h3 id="6-3-1-路由选择"><a href="#6-3-1-路由选择" class="headerlink" title="6.3.1 路由选择"></a>6.3.1 路由选择</h3><p>1本地偏好值最高的路由优先选择</p><p>2 使用具有AS跳数最少的选择</p><p>3 使用热土豆路由算法</p><p>BGP-4使用四种报文</p><p>​1 打开</p><p>​2 更新</p><p>​3 保活</p><p>​4 <em>通知</em></p><h2 id="6-4-路由器组成"><a href="#6-4-路由器组成" class="headerlink" title="6.4 路由器组成"></a>6.4 路由器组成</h2><h3 id="6-4-1-基本了解"><a href="#6-4-1-基本了解" class="headerlink" title="6.4.1 基本了解"></a>6.4.1 基本了解</h3><p>讲完了路由选择，接下来讲解路由器</p><p>路由器是一种典型的网络层设备，具有多个输入端口和多个输出端口的专用计算机~</p><p>路由器是互联网中的关键设备</p><p>路由器的<strong>主要任务</strong>是：</p><p>​转发分组</p><p>路由器的<strong>主要作用</strong>是：</p><p>​联通不同的网络（如不同VLAN，不同的IP子网，不同的局域网和广域网）</p><p>​选择信息传送的线路（即通过选路来转发分组）</p><p>​选择通畅快捷的近路，能大大提高通信速度，减轻网络系统负荷</p><p>一个2端口的路由器，冲突域和广播域的个数分别是：2，1</p><h3 id="6-4-2-结构"><a href="#6-4-2-结构" class="headerlink" title="6.4.2 结构"></a>6.4.2 结构</h3><p>控制平面和数据平面</p><p>控制平面</p><p>​控制平面是数据网络中做出转发决定的元素，比如路由协议，选路策略和网络设备上运行这些协议的软硬件资源等</p><p>​控制平面做出的决定包括：该把数据包发往哪条路径转发、是否要用多条路径转发同一个数据流</p><p>数据平面</p><p>​数据平面是执行控制平面决定的部分，包括数据封装协议，网络协议的高速转发芯片等</p><p>控制平面和数据平面分离</p><p>SDN采用控制平面和数据平面分离，实现灵活部署</p><p>典型路由器结构分为</p><p>路由选择部分</p><p>分组转发部分</p><p>交换结构</p><p>路由器关键部件，常用的交换方式 </p><p>通过存储线，通过总线，通过纵横结构</p><h1 id="7-IP多播"><a href="#7-IP多播" class="headerlink" title="7 IP多播"></a>7 IP多播</h1><p>目的：更好支持一对多通信，可以大大节约网络资源</p><p>一对多通信：一个源点发送到许多个终点。例如，实时信息的交付（如新闻，股市行情等）</p><p>核心就是把多次的单播变成可复制的多播</p><p>IP多播可以分为两种</p><p>1 只在本局域网上进行硬件多播</p><p>2 在互联网的范围进行多播</p><p>前一种硬件多播，比较简单但也比较重要，先讲这个</p><h2 id="7-1-硬件多播"><a href="#7-1-硬件多播" class="headerlink" title="7.1 硬件多播"></a>7.1 硬件多播</h2><p>在48位的多播地址中，前25位都固定不变，后23位可以用作多播</p><h2 id="7-2-IP多播需要三种协议"><a href="#7-2-IP多播需要三种协议" class="headerlink" title="7.2  IP多播需要三种协议"></a>7.2  IP多播需要三种协议</h2><h3 id="7-2-1-IGMP协议"><a href="#7-2-1-IGMP协议" class="headerlink" title="7.2.1 IGMP协议"></a>7.2.1 IGMP协议</h3><p>使得路由器知道多播组成员信息</p><p>IGPM是本地使用的一个范围</p><p>IGMP使用IP数据报传输报文</p><p><strong>主要两个功能</strong></p><p>​让主机加入多播组</p><p>​IGMP 报告和查询 维护 多播组转发表</p><p>IGMP工作可以分为<strong>两个阶段</strong></p><p>  第一：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP报文，申明自己是该组的成员</p><p>本地的多播路由器收到IGMP报文后，将组员关系转发给因特网上的其他多播路由器</p><p>第二：因为组员关系是动态的，因此本地多播路由器要周期性探寻本地局域网上的主机，以便知道这些主机继续是组的成员</p><p>只知道 有哪些多播组成员还是不够的</p><p>还要知道怎么到达对应的成员，这就涉及到多播路由选择协议</p><h3 id="7-2-2-多播路由选择协议"><a href="#7-2-2-多播路由选择协议" class="headerlink" title="7.2.2 多播路由选择协议"></a>7.2.2 多播路由选择协议</h3><p><strong>转发多播数据报使用的方法</strong></p><p>1 洪泛与剪除</p><p>​这种方法适用于较小的多播组，直接广播（洪泛）</p><p>​如果发现某个路由器的下游树枝没有该多播组成员，那么则直接剪除</p><p>2 隧道技术</p><p>​这种方法适合于多播组在地理上很分散的情况</p><p>3 基于核心的发现技术</p><p>​这种方法的多播组使用范围比较广</p><p>​对每一个多播组指定一个核心路由器，给出它的单播地址</p><h1 id="8-虚拟专用网络VPN"><a href="#8-虚拟专用网络VPN" class="headerlink" title="8 虚拟专用网络VPN"></a>8 虚拟专用网络VPN</h1><p>有些时候内部网络的某些主机并不需要连到互联网中，只需要和内部网络的其他网络通信即可，这时候便没必要再给他们全球独一无二的地址了</p><p>那么网络设计者们便在IP地址中划分了一部分作为本地地址（不和全球地址产生冲突）</p><p>本地地址或者叫专用地址</p><p>最经典的是192.168打头的</p><p>还有一种类型的VPN，就是远程接入VPN，核心是建立VPN隧道</p><h2 id="8-1-网络地址转换方法NAT"><a href="#8-1-网络地址转换方法NAT" class="headerlink" title="8.1 网络地址转换方法NAT"></a>8.1 网络地址转换方法NAT</h2><p>如果某些分配了本地IP地址的计算机忽然想连上互联网</p><p>一个可行分办法就是用网络地址转换NAT方式</p><p>至少有一个有效的外部全球IP地址</p><h3 id="NAT的工作原理："><a href="#NAT的工作原理：" class="headerlink" title="NAT的工作原理："></a>NAT的工作原理：</h3><p>NAT的基本原理是将内部设备的私有IP地址和端口号映射到单个或多个公共IP地址的一组唯一端口上。这样，当内部设备发送请求时，路由器会将请求从内部IP地址和端口号转换为公共IP地址和不同的端口号，以确保响应的数据包能够正确返回到请求的设备。</p><p>NAT有几种不同的方式来实现这种映射：</p><ol><li><strong>静态NAT</strong>：在静态NAT中，管理员手动配置内部IP地址和端口号与外部IP地址的映射。这些映射是固定的，通常用于服务器或特定应用程序的端口转发。</li><li><strong>动态NAT</strong>：在动态NAT中，NAT路由器动态地将内部设备的，私有IP地址映射到可用的公共IP地址，通常从一个IP地址池中选择。这种方式允许多个设备共享几个公共IP地址。</li><li><strong>PAT（端口地址转换）</strong>：PAT是一种特殊的NAT形式，它使用单个公共IP地址，但使用不同的端口号来区分内部设备。这是最常见的NAT形式，通常用于家庭网络和小型企业。</li></ol><h3 id="NAT的优点"><a href="#NAT的优点" class="headerlink" title="NAT的优点"></a>NAT的优点</h3><ul><li><strong>安全性提高</strong>：NAT可以隐藏内部网络结构，因为外部网络只能看到NAT设备的公共IP地址。这增加了网络的安全性，因为攻击者难以确定内部设备的真实IP地址。</li><li><strong>IPv4地址节省</strong>：由于IPv4地址短缺，NAT允许多个设备使用同一个公共IP地址，从而节省了IPv4地址资源。</li><li><strong>简化管理</strong>：NAT允许多个设备通过一个公共IP地址访问互联网，简化了网络管理。</li></ul><h1 id="9-MPLS多协议标签交换"><a href="#9-MPLS多协议标签交换" class="headerlink" title="9 MPLS多协议标签交换"></a>9 MPLS多协议标签交换</h1><p>为了增加IP数据报的转发速度，引入了MPLS</p><p>MPLS并没有取代IP</p><p>多协议标签交换（Multiprotocol Label Switching，MPLS）是一种在计算机网络中用于数据传输的高效且灵活的技术。MPLS通过在数据包头部添加标签（Label）来对数据进行标记和转发，从而改善了数据包的路由、流量工程和服务质量。以下是MPLS的主要特点和工作原理的介绍：</p><h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol><li><strong>标签交换</strong>：MPLS通过在数据包头部添加一个短的标签来标识数据包，而不是基于传统的IP路由表来进行转发。这个标签可以在网络中的路由器之间快速交换，从而提高了数据包的转发速度。</li><li><strong>流量工程</strong>：MPLS允许网络管理员根据网络流量的需求来管理路由和优化网络性能。管理员可以为不同的流量流分配不同的标签，以实现更好的流量控制和负载均衡。</li><li><strong>服务质量（QoS）支持</strong>：MPLS可以根据标签来实现不同类别的服务质量（如低延迟、高带宽等），这对于应对多种网络应用的需求非常重要，如实时音视频通信。</li><li><strong>简化路由表</strong>：MPLS可以减小路由器的路由表，因为它只需要考虑标签而不是完整的IP地址。这有助于减小路由器的存储和处理负担，提高了网络的扩展性。</li><li><strong>隧道和虚拟专用网络（VPN）支持</strong>：MPLS可以用于创建虚拟专用网络，使不同的企业或组织可以在共享的基础设施上构建私有网络，同时保持数据的隔离性和安全性。</li></ol><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>MPLS的工作原理包括以下步骤：</p><ol><li><strong>标签分配</strong>：在MPLS网络中，每个路由器都分配一个唯一的标签给数据包。这个标签通常是20位长，包含了一些信息，如数据包的下一个路由器（下一跳）。</li><li><strong>标签交换</strong>：当数据包到达一个MPLS路由器时，该路由器会查看数据包的标签，然后根据标签表将数据包转发到下一个路由器。标签表包含了标签与出口接口的映射关系。</li><li><strong>标签压栈和弹栈</strong>：在数据包通过MPLS网络的过程中，标签可以被压栈（添加新的标签）或弹栈（移除标签）。这允许数据包在网络中多次标记和转发。</li><li><strong>最终目的地</strong>：当数据包到达目的地时，最后一个MPLS路由器会弹出标签并将数据包交付给上层协议（通常是IP），然后根据目的IP地址将数据包传送到目标设备。</li></ol><p>MPLS技术的灵活性和效率使其成为了广泛应用于企业网络、服务提供商网络和数据中心网络的一种重要技术。它有助于改进网络性能、提高服务质量，并简化了网络管理。</p><p>物理层使用的中间设备叫做转发器</p><p>数据链路层使用的中间设备叫做网桥或交换机</p><p>网络层使用的中间设备叫做路由器</p><p>网络层以上使用的中间设备较网关</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（五）网络层上</title>
      <link href="/2023/11/19/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/11/19/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>以前人们想借鉴电信网（电话网络）成功的经验，尝试采用虚电路服务，让网络层负责可靠交付，通信之前先建立虚电路。但是互联网的先驱者们提出让网络层尽可能简单，即用网络层提供简单灵活的，无连接的，尽最大努力交付的数据报服务，这是因为考虑到互联网的终端都是有智能的计算机而不是简单的电话，所以终端有着很强的数据处理能力，那么也就不需要网络层来进行这部分的可靠交付了。</p><p>后来多年的实践证明，先驱者们的选择多么正确</p><p>（1）网络层简单使得网络中的路由器可以做得比较简单,价格低廉，因而易于拓展，便于大规模发展</p><p>（2）运行方式灵活，能够适应多种应用</p><h1 id="1-网络层的两个层面"><a href="#1-网络层的两个层面" class="headerlink" title="1 网络层的两个层面"></a>1 网络层的两个层面</h1><p>两个主机通信的时候，需要经过若干个路由器转发信息。</p><p>转发的信息实际就两大类：一是传送的数据（数据层面），二是路由信息（控制层面）</p><ul><li>数据层面的信息转发：只需要查找本路由器的路由表，把收到的分组从对应的接口发送出去，数据部分直接硬件转发，速度极快，为纳秒数量级</li><li>控制层面的信息转发：路由器必须得经常和相邻的路由器交互路由信息更新自己的路由表，所以更为复杂，，软件介入转发，速度会慢了很多，为秒数量级</li></ul><h1 id="2-网络协议IP"><a href="#2-网络协议IP" class="headerlink" title="2 网络协议IP"></a>2 网络协议IP</h1><p>IP是TCP&#x2F;IP体系中最重要的两个协议之一</p><p>与IP协议配套使用的还有</p><p>地址解析协议ARP</p><p>网际控制报文协议ICMP</p><p>网际组管理协议 IGMP</p><p>如下图所示</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231213174142698.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231213174142698.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="整体结构示意图"></p><p>我们会发现ICMP，IGMP协议在IP的上方，是因为这两个协议经常需要调用IP协议</p><p>而ARP协议在IP的下方，是因为IP协议需要经常调用ARP协议</p><p>在讨论网际协议IP前，必须先了解什么是虚拟互联网络</p><h2 id="2-1-虚拟互联网络"><a href="#2-1-虚拟互联网络" class="headerlink" title="2.1 虚拟互联网络"></a>2.1 虚拟互联网络</h2><p>我们知道网络是要将全世界五花八门的计算机互联在一起，这就需要解决很多问题，最首要的一个就是异构，差异性</p><p>比如：不同的寻址方案，不同的组大分组长度，比如不同的差错控制方案等等一大堆。</p><p>那么该怎么办呢？</p><p>先驱者们提出在网络层，通过IP协议来进行统一，就是不管你其他层的协议是什么，我的网络层大家都用IP协议，这样仿佛在网络层看起来是一个统一的网络，也就叫做我们的虚拟互联网络。</p><p>所以大家可以感受到IP协议的重要性了吧！！！之前我们讲的一些协议可能通用性并没有那么强，但IP是互联网每一个用户都得遵守的boss rules</p><p>一个在互联网上的设备必须有IP地址才能与其他设备进行通信，接下来我们来了解IP地址</p><h2 id="2-2-IP地址"><a href="#2-2-IP地址" class="headerlink" title="2.2 IP地址"></a>2.2 IP地址</h2><p>整个因特网看成是一个单一的，抽象的网络</p><p>IP地址就是给每一个连接在因特网上的主机分配一个在全世界范围是唯一的32位的标识符</p><h3 id="2-2-1-固定分类编址方式"><a href="#2-2-1-固定分类编址方式" class="headerlink" title="2.2.1 固定分类编址方式"></a>2.2.1 固定分类编址方式</h3><p>IP地址由网络号和主机号组成，又叫做两级IP——网络号+主机号</p><p>​网络号表示着主机所连接到的网络，主机号表示该主机（对路由器的话是路由器）</p><p>最开始的时候采用固定分类的IP地址，即网络号的位数是固定的（8位A类,16位B类和24位C类）</p><p>如何区分不同类别的地址呢？通过网络号的前缀，如下图</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231214222727712.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231214222727712.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="固定分类编址"></p><p>对于A类地址，是网络号为8位的</p><p>​总地址空间$2^{31}$个 接近43亿</p><p>​网络号个数：由于A类地址网络号有7位，所以A类地址可以分配的网络号个数$2^7-2&#x3D;126个$，这里为什么要减去2呢，因为0000 000的网络号有特殊含义代表“本网络”，0111 1111的网络号代表环回测试</p><p>​主机号个数：$2^{24}-2$ 为什么这里还要减2呢，因为全0是本网络，全1是所有的广播</p><p>对于B类地址，是网络号为16位的</p><p>​总地址空间$2^{30}$个</p><p>​网络号个数：$2^{14}$</p><p>​主机号个数：$2^{16}-2$</p><p>对于C类地址，是网络号为24位的</p><p>​总地址空间$2^{29}$个</p><p>​网络号个数：$2^{21}$</p><p>​主机号个数：$2^{8}-2$</p><p>以上A,B,C类都是单播地址，而D类地址是多播地址</p><p>这样的好处是简单，看前缀就知道什么类型的地址了</p><p>缺点是：使用不灵活的问题</p><h3 id="2-2-2-无分类编制CIDR"><a href="#2-2-2-无分类编制CIDR" class="headerlink" title="2.2.2 无分类编制CIDR"></a>2.2.2 无分类编制CIDR</h3><p>于是采用更为灵活的CIDR</p><p>上一个网络号位数是由类别决定的，每一个类别网络号位数是固定的，而CIDR的网络号位数是由掩码决定的，是可变的</p><p>之前的网络号在CIDR里更名为网络前缀</p><p>网络前缀可以通过斜线+数字表示，如&#x2F;20</p><p>比如IP 128.14.32.7&#x2F;20  我们可以知道 网络前缀20位，那么主机号30-20&#x3D;12位！</p><p>人为可以看斜线数字，计算机怎么知道有多少位网络前缀呢？</p><p>通过子网掩码</p><p>如上述IP 128.14.32.7&#x2F;20，有20个并列的1,12个并列的0组成掩码</p><p>其中1的个数代表网络号个数，0的个数代表主机号个数</p><p>我们将IP地址和子网掩码按位与，可以得到网络地址</p><p>有三个比较特殊的地址块</p><p>1 前缀n&#x3D;32，用于主机路由</p><p>2 前缀n&#x3D;31，用于点对点路由</p><p>3 前缀n&#x3D;0，且所有主机号为0，用于默认路由</p><p>这些用途后面讲到</p><p>路由聚合——用较大的CIDR块替代较小的CIDR块，减少查找转发表的时间</p><h3 id="2-2-3-MAC地址和IP地址区别"><a href="#2-2-3-MAC地址和IP地址区别" class="headerlink" title="2.2.3 MAC地址和IP地址区别"></a>2.2.3 MAC地址和IP地址区别</h3><p>MAC地址是物理地址，硬件实现，在数据链路层，MAC帧首部</p><p>IP地址是逻辑地址，软件实现，在网络层，IP数据报首部</p><p>假设从A1，到B1，途径R1，R2两个路由器</p><p>IP数据报都不变，即IP首地址和源地址都是A1,B1</p><p>但MAC帧的首地址尾地址会发生变化，一开始A1，R1，然后R1，R2……</p><p>特殊IP地址</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231010165242389.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231010165242389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="特殊IP地址"></p><p>点分十进制记法</p><p>IP编址可以解决世界各地网络硬件地址差异大，转换工作复杂的问题</p><p>网络地址转换过程</p><p>​离开专用网的时候，替换源地址，将内部地址替换为全球地址</p><p>​进入专用网的时候，替换目的地址，将全球地址替换为内部地址</p><p>现在有一个问题，就是我们已经知道IP了，那么计算机怎么知道对应的MAC地址呢</p><p>这就涉及到地址解析协议ARP</p><h2 id="2-3-地址解析协议ARP"><a href="#2-3-地址解析协议ARP" class="headerlink" title="2.3 地址解析协议ARP"></a>2.3 地址解析协议ARP</h2><p>已经知道了一个机器（主机或路由器）的IP地址，如何找出其响应的硬件地址</p><p>地址解析协议ARP就是用来解决这个问题的</p><p>方法：每一个主机都设有一个ARP高速缓存（ARP cache，作用存放最近获得的IP地址绑定的MAC地址，减少ARP广播数量）这里面存有所在局域网上的各个主机和路由器IP地址到硬件地址的映射表</p><p>&lt;IP address; MAC address; TTL&gt; TTL:地址映射有效时间</p><p>我们可以查看自己的电脑的ARP高速缓存，命令</p><p>arp -a|more</p><h3 id="2-3-1-解析过程"><a href="#2-3-1-解析过程" class="headerlink" title="2.3.1 解析过程"></a>2.3.1 解析过程</h3><p>先在ARP高速缓存中查看有无主机B的IP地址</p><p>​如果有，就可查出对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该硬件地址写入MAC帧，然后通过局域网发往硬件地址</p><p>​如果没有，ARP进程在本局域网上广播发送一个ARP请求分组，收到ARP响应分组后，将得到的IP地址到硬件地址的映射写入ARP高速缓存</p><p>​不在同一个局域网的话，则交给一个路由器</p><p>​解析是自动进行的</p><h2 id="2-4-IP数据报格式"><a href="#2-4-IP数据报格式" class="headerlink" title="2.4 IP数据报格式"></a>2.4 IP数据报格式</h2><p>首部和数据部组成，首部是固定长度，共20字节，是所有IP数据报必须拥有的</p><p>首部的固定部分的后面是一些可选字段，其长度是可以变的</p><p>固定字段的常见内容如下</p><p>版本，首部长度，区分服务，总长度，标识，标志</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111222137020.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111222137020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="固定字段及其可变部分"></p><p>分组头的长度是可变的</p><p>版本字段表示IP版本，值为4表示IPv4</p><p>协议字段表示上层协议</p><p>生存时间表示 一个分组最多条数</p><h1 id="3-IP层转发分组流程"><a href="#3-IP层转发分组流程" class="headerlink" title="3 IP层转发分组流程"></a>3 IP层转发分组流程</h1><p>显示本机路由表 route print -4</p><p>IP层后转发分组都只找网络前缀了（这样就可以找到目的网络）因为直接如果找到主机号的地步，会需要大量的内容，主机数目实在太大了，查找过程就会非常缓慢……</p><p>所以就找前缀相同，看看是不是本网络如果不是的话则通过端口转发。如果有多个匹配的前缀，那么则选取最长的前缀</p><p>核心算法（默认前缀按长到短排序）</p><p>1 从数据报首部提取目的主机的IP地址D，得出目的网络的地址N</p><p>2 若网络N与此路由器直接相连，则把数据报直接交付目的主机D，否则是间接交付。执行3</p><p>3 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中下一跳的路由器，否则执行4 </p><p>4 若路由表中有目的网络地址N的路由，则把数据报传送给路由表中下一跳的路由器，否则执行4 </p><p>5 若路由表中有一个默认路由，则把数据报传送给路由表中指明的默认路由器，否则执行6</p><p>6 报告转发分组出错</p><p>特殊的路由</p><p>​主机路由和默认路由</p><p>而为了加快查找表的查找过程，又可以使用二叉线索查找转发表</p><p>为了更有效地转发IP数据报并且提高交付机会，使用ICMP协议</p><p>使用ICMP后，就可以运行主机或者路由器报告差错情况和提供有关异常情况的报告</p><h1 id="4-国际控制报文协议ICMP"><a href="#4-国际控制报文协议ICMP" class="headerlink" title="4 国际控制报文协议ICMP"></a>4 国际控制报文协议ICMP</h1><p>提高IP数据报的交付成功机会，允许主机或路由器报告差错情况和提供有关异常情况的报告，但是不是高层协议，ICMP报文是装到IP数据报的数据部分中的</p><p>是IP层协议</p><h2 id="4-1-ICMP格式结构"><a href="#4-1-ICMP格式结构" class="headerlink" title="4.1 ICMP格式结构"></a>4.1 ICMP格式结构</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231024162522252.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231024162522252.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IP数据报格式示意图"></p><p>ICMP报文的前四个字节是统一的格式，共有3个字段，即类型、代码、检验和</p><p>ICMP的应用举例</p><p>Ping</p><p>traceroute</p><h2 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h2><h3 id="4-2-1-差错报告报文"><a href="#4-2-1-差错报告报文" class="headerlink" title="4.2.1 差错报告报文"></a>4.2.1 差错报告报文</h3><p>在如下情况发送ICMP报文</p><p>​终点不可达</p><p>​源点抑制</p><p>​时间超过</p><p>​参数问题</p><p>​改变路由（重定向）</p><h3 id="4-2-2-询问报文"><a href="#4-2-2-询问报文" class="headerlink" title="4.2.2 询问报文"></a>4.2.2 询问报文</h3><p>ICMP报文的</p><h2 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h2><p>用ping命令测两个主机的连通性，其中ping是应用层直接使用网络层ICMP的一个例子</p><p>另一个例子是LInux的traceroute ，Windows下是tracert，可以知道到目的主机所经过路由器的IP地址</p><p>计算题</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（四）数据链路层</title>
      <link href="/2023/11/18/Computer_system/Net/3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/11/18/Computer_system/Net/3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>内容笔记来源于谢希任老师《计算机网络》</p><p>重点</p><p>理解MAC地址</p><p>理解交换机</p><p>理解VLAN</p><p>理解高速以太网</p><p>数据链路是计算机网络的底层</p><h1 id="1-数据链路基本概念和问题"><a href="#1-数据链路基本概念和问题" class="headerlink" title="1 数据链路基本概念和问题"></a>1 数据链路基本概念和问题</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p><strong>链路</strong>   或者叫物理链路  是一段点到点的物理线段（有线或者无线）中间没有任何其他交换结点</p><p>一条链路只是一条<strong>通路</strong>的组成部分</p><p><strong>数据链路</strong>  或者叫数据链路   在链路的基础上加上控制协议和实现协议的软件和硬件!<br><a href="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001094833719.png"></a></p><p>​现在最常用的是使用适配器（网卡）来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层的功能</p><p>​数据链路使用的信道主要有以下两种类型</p><ol><li>点对点信道，使用PPP协议</li><li>广播信道，使用CSMA&#x2F;CD协议</li></ol><h2 id="1-2-基本问题"><a href="#1-2-基本问题" class="headerlink" title="1.2 基本问题"></a>1.2 基本问题</h2><p>对于数据链路层而言，以下三个问题很重要</p><h3 id="（1）封装成帧"><a href="#（1）封装成帧" class="headerlink" title="（1）封装成帧"></a>（1）封装成帧</h3><p>我们知道，互联网上传输数据都以分组（即IP数据报）为传输单位进行传输，所以到了底层数据链路层也得保证不混淆不同的IP报</p><p>所以封装成帧就是在网络层的IP数据报上加上首部和尾部，构成帧</p><p>那么首部和尾部有什么作用呢？</p><p>最重要的</p><ul><li>我们首部和尾部的重要作用就是进行帧定界，通俗来讲就是  区分一个帧和另一个帧（核心目的就是为了不让IP数据报混淆）</li><li>首部和尾部包含一些控制信息</li></ul><p>所以综合来看，一个帧包括的内容有，我们要传输的数据，和首部尾部</p><p>那么为了提高传输效率，要尽可能使得传输数据部分长度大于首部尾部的长度，但每一种数据链路协议都规定了数据部分的长度上限——称为最大传输单元MTU</p><p>数据链路层传送的是<strong>帧</strong>  帧是传输数据的单位</p><p><strong>解决方式</strong>  用控制字符进行</p><h3 id="（2）透明传输"><a href="#（2）透明传输" class="headerlink" title="（2）透明传输"></a>（2）透明传输</h3><p>传播的数据部分出现控制字段，如开始和结束</p><p>如果不做处理的话，会导致接收方误以为提前结束，这个数据部分的EOS应该不被接收方看见</p><p>即应该被认为是透明的，所以叫他为透明传输</p><p>实现的方式是怎样的呢？</p><p><strong>解决方式</strong>  通过字节填充解决.数据中出现控制字符的时候，前面加入一个转义字符“ESC” 十六进制编码1B</p><p><strong>可能问题</strong></p><p>就是IP层交付的数据和DL数据链路层实际传输的数据不一样</p><h3 id="（3）差错控制"><a href="#（3）差错控制" class="headerlink" title="（3）差错控制"></a>（3）差错控制</h3><p>在传输过程中不可能一点都不出错，如0变成1,1变成0，这就叫做<strong>比特差错</strong>。对于差错我们的解决方式是</p><p>目前采用较多的是循环冗余检测方法CRC</p><p><strong>发送端</strong></p><p>原始数据M，进行n位冗余码，商定一个除数P（位数n+1），</p><p>1 原始数据M后面加n个零做被除数D</p><p>2 D除以P得到的余数（该余数又叫帧检验序列FCS）加在M后面</p><p><strong>接收端</strong></p><p>得到的信息除以除数P，余数为0，接受，否则丢弃</p><p>注意我们上面讲到的是比特差错，CRC仅能排查比特差错</p><p>实际上除了比特差错，还有其他差错，就是帧丢失，帧重复和帧失序</p><p>其中我们要注意的是仅仅排除比特差错是不够的，实现了无比特差错的传输叫做<strong>无差错传输</strong></p><p>但是只有排除了所有错误，如帧丢失，帧重复和帧失序之后才能叫做<strong>可靠传输</strong>，即发送什么就收到什么</p><p>这些排除错误的方法（帧编号，确认和重传机制）是往往是更高层来实现的</p><h1 id="2-数据链路层协议"><a href="#2-数据链路层协议" class="headerlink" title="2.数据链路层协议"></a>2.数据链路层协议</h1><h2 id="2-1-点对点-PPP协议"><a href="#2-1-点对点-PPP协议" class="headerlink" title="2.1 点对点 PPP协议"></a>2.1 点对点 PPP协议</h2><p>使用最多的是点对点协议PPP</p><p>我们前面反复提到互联网用户如果想要连入互联网，必须连接到某个ISP，其中我们的PPP协议广泛应用于本地计算机和ISP的数据链路层的通信</p><h3 id="2-1-1-需要实现的"><a href="#2-1-1-需要实现的" class="headerlink" title="2.1.1 需要实现的"></a>2.1.1 需要实现的</h3><p>PPP协议需要实现的一些功能</p><p>那么除了我们刚才讲到的 封装成帧，透明传输，差错检测这些基本问题，还实现了简单高效，支持多种网络层协议，支持多种类型链路，检测连接状态，数据压缩算法的协商</p><h3 id="2-1-2-PPP组成"><a href="#2-1-2-PPP组成" class="headerlink" title="2.1.2 PPP组成"></a>2.1.2 PPP组成</h3><p>一个将IP数据报封装到串行链路的方法，是同步还是异步</p><p>一个链路控制协议LCP（建立，配置，和测试数据链路的连接</p><p>一套网络控制协议NCP（支持多种网络层协议）</p><h3 id="2-1-3-帧格式"><a href="#2-1-3-帧格式" class="headerlink" title="2.1.3 帧格式"></a>2.1.3 帧格式</h3><p><strong>开始结束字段</strong>  F&#x3D;0x7E   1字节</p><p><strong>地址字段</strong>   A&#x3D;0xFF   因为是点对点，所以设置就维持不变  1字节</p><p><strong>控制字段</strong>   C&#x3D;0x03   1字节</p><p>开始结束和地址字段，控制字段实际上没有携带什么信息。他是最初设计的时候考虑之后可能会用到，但目前为止也没有用到</p><p><strong>协议字段</strong>  不同值代表不同协议  2字节</p><p>如0x0021时，是IP数据报，若为0xC021 ，则为LCP数据报</p><p><strong>信息字段</strong> 要传输的IP数据报或，链路控制数据，网络控制数据等</p><p><strong>检验字段</strong>  FCS</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001101538660.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001101538660.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>对于<strong>透明传输</strong>问题</p><p>异步传输方法是——<strong>字节填充法</strong></p><p>​当信息字段中出现和标志字段一样的比特（0x7E）组合时，在前面添加转义字符0x7D，同时把0x7E变为0x5E传输。整体变为（0x7D，0x5E）传输</p><p>​当信息字段出现转义符（0x7D）的时候，在前面再添加一个转义字符0x7D，同时把0x7D变为0x5D传输。整体变为（0x7D，0x5D）传输</p><p>​当信息中出现ASCLL控制码时候，也同理</p><p>同步传输方法是——<strong>零比特填充法</strong></p><p>发送端，先扫描整个信息字段（往往硬件实现）只要发现有5个连续的1，则立即填入一个0，因此经过这种比特的填充后，信息字段就不会出现6个1 的情况</p><p>接收端，首先找到标志字段F确定边界，然后用硬件对内部比特流扫描去掉0</p><h3 id="2-1-4-工作流程"><a href="#2-1-4-工作流程" class="headerlink" title="2.1.4 工作流程"></a>2.1.4 工作流程</h3><p>建立工作状态</p><ol><li>用户拨号接入ISP后，建立了一条从用户个人电脑到ISP的物理连接</li><li>用户个人电脑向ISP发送一系列的链路控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了一些将要选择的PPP参数</li><li>进行网络层配置，NCP给新接入的用户分配一个临时IP，正式接入互联网</li></ol><p>通信完毕</p><ol><li>NCP释放网络层连接，收回去分配出去的IP</li><li>LCP释放数据链路层连接</li><li>释放物理层连接</li></ol><h2 id="2-2-广播-CSMA-CD协议"><a href="#2-2-广播-CSMA-CD协议" class="headerlink" title="2.2 广播 CSMA&#x2F;CD协议"></a>2.2 广播 CSMA&#x2F;CD协议</h2><p>接下来重点讨论局域网部分的一对多通信，其中以太网可以看成是一种实现局域网通信的技术标准（目前逐渐大家把它当作局域网的同义词。以太网的拓扑结构有环形的，星形的等等。局域网主要用双绞线，速率更高</p><p>开始之前，先探讨一个问题——我们本地的计算机是怎么连到局域网的？</p><p>其中一个关键部件是适配器（网卡）</p><p>适配器是什么</p><p><strong>适配器</strong></p><p>网络接口板子又称作通信适配器或者网卡</p><p>他的核心作用如下</p><p><strong>适配器的功能</strong></p><p>​进行串行并行转换</p><p>​对数据进行缓存</p><p>​在计算机的操作系统安装设备驱动程序</p><p>​实现以太网协议</p><p>计算机通过适配器和局域网进行通信</p><p>好的，我们已经了解了连接到局域网的关键设备，适配器</p><p>接下来一个重要问题就是，多用户如何共享信道资源，一般两种方式</p><ol><li><p>静态划分信道 FDMA，TDMA，WDMA，CDMA——频分复用，时分复用，码分复用等代价价高，  不适合于这个局域网</p></li><li><p>动态媒体接入控制 ——又称为多点接入，信道并非在用户通信时固定分配给用户，这里又分为两类</p></li></ol><ul><li><p>随机接入CSMA&#x2F;CD：即所有用户可以随机地发送信息，如果恰巧有两个用户在同一时刻发送信息，那么在共享媒体上就要发生碰撞，使得用户的发送都失败。因此，必须有解决碰撞的网络协议</p></li><li><p>受控接入：用户不能随机的发送信息，而必须服从一定的控制，这类的典型代表有分散控制令牌环局域网和集中控制的多点线路探询，或轮询</p></li></ul><p>由于局域网信道质量比较高（距离短），所以设计的时候要尽可能的简单</p><p>为此，局域网采取了如下的措施</p><ol><li><p>以太网提供的是<strong>无连接</strong>（不必先建立连接就可以直接发送数据）的<strong>不可靠</strong>（对发送的数据帧不进行编号，不要求确认）服务，以太网采用CSMA&#x2F;CD协议，意味着载波监听多点接入\碰撞检测</p></li><li><p>以太网的数据采用<strong>曼彻斯特编码</strong></p></li></ol><h3 id="2-2-1-协议要点"><a href="#2-2-1-协议要点" class="headerlink" title="2.2.1 协议要点"></a>2.2.1 协议要点</h3><p>半双工通信</p><p><strong>多点接入</strong>  表示计算机以多点的方式连接在一根总线上</p><p><strong>载波监听</strong>  每一个站点在发送数据前先检测一下总线上有没有其他计算机在发送数据</p><p>载波监听的问题</p><p>监听到空闲的其实并不一定是空闲的哦！所以需要碰撞检测</p><p>以太网端到端往返时延的两倍2t称为争用期或碰撞窗口，如果这段时间还没有检测到碰撞，这次发送就不会碰撞，当发送碰撞后，还会发送强化碰撞，即人为发送干扰信息，保证所有用户都知道已经发生了碰撞</p><p><strong>碰撞检测</strong>  检测到碰撞后立即停止发送，继续发送人为干扰信号（以便让所有用户知道发生了碰撞）等待一段随机时间后发送。</p><p>那么这个随机时间如何计算呢？ <strong>随机时间计算</strong></p><p>1 基本退避时间为争用期2t (以太网取51.2us为争用期)</p><p>2 从整数集合$[0,1,2,…,(2^k-1)]$中随机取出一个数记为r，k&#x3D;min[重传次数，10]</p><p>3 重传时延就是r倍的基本退避时间</p><p>4 如果重传16次依然不能成功时丢弃帧，向高层报告</p><p>由于以太网取51.2us为争用期，对于10Mbit&#x2F;s的网络而言，这期间可以发送512比特（64字节），如果发生冲突一定是在64节内，这会导致检测到冲突停止发送从而数据小于64节所以64字节为<strong>最短有效帧长</strong></p><p>还有<strong>帧间最小间隔</strong>即96帧，方便刚刚收到数据帧的站接收缓存清理，做好接受下一帧的准备</p><p>总结来看</p><p>该协议的要点：</p><p>1 准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部组成以太网帧。放入适配器的缓存中，发送之前检测信道</p><p>2 检测信道：若检测信道忙，则不停检测，一直等待信道转为空闲，且超过96帧后，发送过程中继续监测信道，如果超过争用期后还是未检测到碰撞，就认为发送成功，否则立刻停止发送，然后利用指数退避算法再次发送</p><p>接下来我们探讨一下局域网的信道利用率</p><p><strong>参数a</strong></p><p>$T_0&#x3D;L&#x2F;C$   L是帧长  C是数据发送速率，T0是帧发送时间</p><p>$a&#x3D;t&#x2F;T_0$   参数a等于以太网单端时延与帧的发送时间T_0的比</p><p>a接近0的时候，表示一发生碰撞就会被检测出来，信道利用率很高</p><p>a越大，争用期所占比例增大，发生一次碰撞就浪费许多资源</p><p>当数据率一定时候，以太网的连线长度受到限制，否则t数值就会太大，以太网帧长不能太短，否则会导致T0值太小，a太大</p><p>理想信道利用率</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144501740.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144501740.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="理想信道利用率" style="zoom:33%;" /><p>上面式子告诉我们$a$要远小于1，才能提高这个利用率</p><h2 id="2-3-集线器，交换器"><a href="#2-3-集线器，交换器" class="headerlink" title="2.3 集线器，交换器"></a>2.3 集线器，交换器</h2><p>使用接线器比起刚刚的无源的总线结构更靠谱一些</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>星形拓扑结构，中心叫集线器，目前使用双绞线或光纤</p><p>一个集线器有许多个端口</p><p>集线器工作在物理层，仅仅简单地做转发，不进行碰撞检测</p><p>前面我们讲到适配器，那么局域网的各个电脑如何区分要发送的目的地呢</p><p>就是通过适配器的MAC地址，他是固化在适配的ROM中，全球唯一</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址又叫做硬件地址，物理地址</p><p>通常表示为48位， 6字节</p><p>表示的时候用12个16进制数，每2个16进制数之间用冒号隔开，如08：00：20：0A：8C：6D</p><p>地址段前三个字节由IEEE的注册管理机构RA向厂家分配，后三个字节由厂家自行分配</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144759678.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144759678.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MAC地址格式"></p><p>IEEE规定地址字段的第一字节的最低位为I&#x2F;G位</p><p>I&#x2F;G&#x3D;0时候，地址字段表示一个单站地址</p><p>I&#x2F;G&#x3D;1时候，地址字段表示一个组地址，用来广播</p><p>当48位都为1时候，为广播地址，只能作为目的地址</p><p>IEEE规定地址字段的第一字节的最低第二位为G&#x2F;L位</p><p>G&#x2F;L位&#x3D;0时候，是全球管理</p><p>IG&#x2F;L位&#x3D;1时候，是本地管理</p><p>当48位都为1时候，为广播地址，只能作为目的地址</p><h3 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h3><p>常用以太网V2格式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001145624341.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001145624341.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MAC帧"></p><p><strong>源地址目标地址</strong> 上面讲到的MAC地址</p><p><strong>类型</strong> 上一层使用的什么协议</p><p><strong>数据字段</strong></p><p>​最小长度&#x3D;64-18字节的头尾&#x3D;46</p><p>​最长1500</p><p>检测字段<strong>FCS</strong></p><p><strong>前同步码</strong>  8个字节，前7个实现MAC帧同步，第8个帧开始定界符</p><p><strong>帧间最小间隔</strong>  9.6us</p><p><strong>总结：</strong></p><p>互联网&#x3D;通过<a href="https://www.zhihu.com/search?q=%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2565012876%7D">路由协议</a>联通的N个局域网。</p><p>局域网&#x3D;以太网+TCP&#x2F;IP协议。</p><p>以太网&#x3D;基于广播(MAC寻址)和碰撞检测机制 CSMA&#x2F;CD 的网络。</p><p>（  以太网是一种计算机局域网技术</p><h1 id="3-扩展以太网"><a href="#3-扩展以太网" class="headerlink" title="3 扩展以太网"></a>3 扩展以太网</h1><p>我们知道，以太网的两台主机距离不能太远，但是往往比如校园内，一些主机的距离可能蛮远的</p><p>要实现这样距离较远的通信，我们就需要扩展以太网</p><p>所以我们要搞清楚拓展的核心目的</p><p>那么拓展主要有两种方式，物理层上扩展，和数据链路层扩展</p><h2 id="3-1-物理层扩展方式"><a href="#3-1-物理层扩展方式" class="headerlink" title="3.1 物理层扩展方式"></a>3.1 物理层扩展方式</h2><ol><li><p>很早之前拓展是通过接转发器</p></li><li><p>而现在拓展的简单方法就是使用光纤，用到光纤调制解调器，能够到达几公里的范围</p></li><li><p>还有一种方式就是多个集线器，连接成覆盖更大范围的多级星型结构</p><p>比如一个学校有三个学院，每个学院配备一个集线器，最后再通过一个主干集线器连接在一起</p><p>多级集线器的优点是，可以跨院通信，同时扩大了范围，缺点是碰撞域变大了（三个独立的碰撞域合成了一个），同时没有缓存功能，不同学院必须使用相同的以太网技术</p></li></ol><p>​比如10Mb&#x2F;s的以太网，则十个用户端口，则每个用户端口变为1Mb&#x2F;s</p><p>​通过集线器连接，构成一个广播域，也是一个冲突域</p><h2 id="3-2-数据链路层扩展方式"><a href="#3-2-数据链路层扩展方式" class="headerlink" title="3.2 数据链路层扩展方式"></a>3.2 数据链路层扩展方式</h2><p>扩展方式主要通过交换机，交换机工作在数据链路层</p><p>特点 </p><ol><li>交换机实质是一个多端口的网桥，通常有十几个或者更多个端口，全双工工作方式</li><li>具有存储器，能够进行帧缓存</li><li>即插即用，避免人为配置，通过内部帧交换表实现，要了解交换机更新交换表的自学算法</li><li>用户独占信道，增大了交换机总容量</li><li>有多种速率端口</li></ol><p>比如10Mb&#x2F;s的以太网，则十个用户端口，则每个用户端口变为10Mb&#x2F;s</p><p>通过交换机连接，构成一个广播域，但不是一个冲突域</p><p>交换方式有</p><p>​存储转发方式</p><p>​先把整个数据帧先缓存再进行处理</p><p>​直通方式</p><p>​接收数据帧的同时就按照目的地址决定转发接，缺点是不查错</p><h3 id="3-2-1-交换机的自学功能"><a href="#3-2-1-交换机的自学功能" class="headerlink" title="3.2.1 交换机的自学功能"></a>3.2.1 交换机的自学功能</h3><p>交换表组成： MAC地址，端口，写入时间</p><p>如果交换表内没有自己要发送的对方的地址，则进行广播通知每一个主机，其他主机收到后看看是否是要发送给自己，不是的话则过滤掉，是的话则接收，同时将对应的信息加入交换表。如果有的话则直接一对一发送</p><h2 id="3-3-虚拟局域网"><a href="#3-3-虚拟局域网" class="headerlink" title="3.3 虚拟局域网"></a>3.3 虚拟局域网</h2><p>当前面的扩展方式进行很多的扩展的时候，就会遇到一些问题</p><p>首先一整个以太网是一个广播域，那么以太网上经常就会出现大量广播帧，浪费资源</p><p>其次，不利于信息的安全</p><p>所以提出虚拟局域网，核心思想是把一个较大的局域网分割为很多较小的局域网，每一个局域网是一个广播域</p><p>实现方式是在MAC帧的基础上嵌入了VLAN标签，一个虚拟局域网可以跨越多个交换机</p><h1 id="4-高速以太网"><a href="#4-高速以太网" class="headerlink" title="4 高速以太网"></a>4 高速以太网</h1><h2 id="4-1-100BASE-T"><a href="#4-1-100BASE-T" class="headerlink" title="4.1 100BASE-T"></a>4.1 100BASE-T</h2><p>是在双绞线上传输100Mbit&#x2F;s的系带信号的星形拓扑结构，比之前的100Mbit&#x2F;s快了很多</p><h2 id="4-2-吉比特以太网"><a href="#4-2-吉比特以太网" class="headerlink" title="4.2 吉比特以太网"></a>4.2 吉比特以太网</h2><p>即传输速率是1Gbit&#x2F;s</p><p>之前我们讲到大多通过电话线等方式接入互联网</p><p>但实际现在更多的是通过以太网进行宽带接入，比如我们现在只要登录校园网就可以访问外网了</p><p><strong>拓展</strong></p><p>了解一下网速单位</p><p>Mbps是Mb&#x2F;s 而不是MB&#x2F;S”。</p><p>运营商说的1M宽带的M是指Mb&#x2F;s，也就是Mbps，运营商为什么喜欢说这个呢？数据传输大多是以“位”（bit，又名“比特”）为单位的，数据的传输以及运营商在流量收费的时候都是按照比特来计算的</p><p>所以比如运营商说1M带宽，那么也就意味着是1Mb&#x2F;s，也就是0.125MB&#x2F;s</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231210103345528.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231210103345528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="速率示意图"></p><p>我自己实际测试了网速</p><p>如图是300M-500M带宽</p><p>那么也就意味着是37.5MB&#x2F;s到62.5MB&#x2F;s</p><p> 路由器：（Router）是连接因特网中各局域网、广域网的设备。在路由器中记录着路由表，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。发生在网络层。<br>  交换机：（Switch）是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路，把传输的信息送到符合要求的相应路由上。发生在数据链路层。<br>  集线器：（Hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备。发生在物理层。</p><h4 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h4><table><thead><tr><th></th><th>路由器</th><th>交换机</th></tr></thead><tbody><tr><td>工作层次</td><td>网络层</td><td>数据链路层</td></tr><tr><td>转发依据</td><td>IP地址</td><td>Mac地址</td></tr><tr><td>功能</td><td>连接不同的网络</td><td>连接局域网中的电脑</td></tr><tr><td>宽带影响</td><td>共享宽带</td><td>独享宽带</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（三）物理层下</title>
      <link href="/2023/11/17/Computer_system/Net/2-1%20%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/17/Computer_system/Net/2-1%20%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="3-物理层下面的传输媒介"><a href="#3-物理层下面的传输媒介" class="headerlink" title="3. 物理层下面的传输媒介"></a>3. 物理层下面的传输媒介</h1><p>传输媒介是发送器和接收器之间的物理通路</p><p>可以分为引导型传输媒介，非导引型传输媒介</p><h2 id="3-1-导引型传输媒介"><a href="#3-1-导引型传输媒介" class="headerlink" title="3.1 导引型传输媒介"></a>3.1 导引型传输媒介</h2><p>啥叫引导型</p><p>就是电磁波被引导着在固体传播</p><p>可以理解为我们常常称作的有线传输</p><p>常见的有</p><p><strong>1 双绞线</strong></p><p>将铜导线相互绞合，减少电磁干扰</p><p>又可以分为</p><ul><li><p>屏蔽双绞线</p></li><li><p>无屏蔽双绞线</p></li></ul><p>之前常常用作电话线，目前也用于一些计算机网络数据传输</p><p>计算机网络中常用的是5类双绞线，模拟电话中常用的是3类双绞线</p><p>5类双绞线的接头是RJ-45，它是4对8芯</p><p>3类双绞线的接头是RJ-11，它是2对4芯</p><p><strong>2 同轴电缆</strong></p><p>由最内层铜导体+绝缘层+屏蔽层组成</p><p>他的减少电磁干扰方式和双绞线不同是通过外层保护实现的</p><p>局域网初期使用，目前都用双绞线替代了，有看到的是有限电视网居民小区中</p><p><strong>3 光缆</strong></p><p>内部由光纤组成</p><p>由于光频率非常高，所以带宽很高，传播速率也块</p><p>​不同入射角 不同的模式，</p><p>​多模光纤  多条光线，多个入射角</p><p>​单模光纤  单条光线，只有一个入射角</p><p>单模光纤比多模光纤带宽高，速率也高</p><p>目前光纤越来越便宜，用到的也越来越多</p><h2 id="3-2-非导引型传输媒介"><a href="#3-2-非导引型传输媒介" class="headerlink" title="3.2 非导引型传输媒介"></a>3.2 非导引型传输媒介</h2><p>可以理解为无线</p><p>1 <strong>无线电微波通信</strong></p><p>​频率范围300MHz到300GHz</p><p>​直线传播，所以传播距离有限，一般只有50Km，如果使用100m高的天线塔，则传播距离可以增大到100km</p><p>​应用比较广，实际中，往往需要微波接力，即涉及多个中继站，一点一点将信号传输过去</p><p>2 <strong>短波通信</strong> </p><p>​主要靠电离层的反射，但电离层反射不稳定，以及多径效应，使得短波通信质量较差</p><p>3 <strong>卫星通信</strong></p><p>​卫星通信频带宽，容量大，但是传播时延较大</p><p>无线局域网使用的ISM频段</p><h1 id="4-信道复用技术"><a href="#4-信道复用技术" class="headerlink" title="4 信道复用技术"></a>4 信道复用技术</h1><p>我们可以想象，如果信道只能一人占有，那么我们每个人通信前都需要建立一个独有信道，该多么麻烦，可能建立起来黄花菜也凉了，所以信道服用技术非常关键</p><p><strong>信道复用</strong></p><p>用于将多个信号或数据流合并到一个共享传输介质上，以便通过同一通信通道传输它们。复用技术允许多个信号共享有限的通信资源，从而提高了通信系统的效率和资源利用率</p><p>复用方式有以下三种</p><ol><li><p><strong>频分复用（Frequency Division Multiplexing，FDM）</strong>：</p><ul><li>原理：在FDM中，不同信号或数据流通过在不同的频率带宽范围内传输来进行复用。</li><li>实现方式：每个信号分配一个特定的频率范围，因此它们可以在同一传输介质上并行传输。</li><li>应用：电视广播和有线电视系统是FDM的常见示例，其中不同频道在不同频率上传输。</li></ul><p>对于光而言，实际上叫做波分复用WDM</p><p>有稀疏波分复用和密集波分复用</p><p>​稀疏波分复用CWDM：信道间隔为20nm（16个波长）</p><p>​密集波分复用DWDM：信道间隔为0.2nm到1.2nm</p></li><li><p><strong>时分复用（Time Division Multiplexing，TDM）</strong>：</p><ul><li>原理：TDM将不同信号或数据流分配到不同的时间段上进行复用。</li><li>实现方式：在每个时间段内，只有一个信号进行传输。</li><li>应用：音频电话网络中的TDM是一个典型的应用，其中每个电话通话被分配到独立的时间槽。</li></ul><p>以上两种方式，比较成熟应用较多</p><p>我们发现，如果对于频分复用而言，越多用户，每个用户分到的带宽就越少，而对于时分复用，越多用户不会影响他的带宽</p></li><li><p><strong>码分复用（Code Division Multiplexing，CDM或者CDMA）</strong>：</p><ul><li>原理：CDM使用不同的编码序列对信号进行复用，使它们能够在同一时间和频率上传输。</li><li>实现方式：每一个接收方被指派一个m个bit的序列，根据正交等运算实现，比较抽象，看下面的例子</li><li>应用：CDMA（Code Division Multiple Access）手机通信就是一个使用CDM的例子。</li></ul><p>例：</p><p>假设S站向T站发送信号</p><p>S站的分配到的序列（0，0,0,1，1,0,1,1）》转换为 （-1，-1，-1,1，，1，-1,1,1）</p><p>T站如何知道S站是否有发送信息给自己</p><p>可以将收到的总信号（是很多发送方的叠加）点乘S站的序列号除以8即可以得到</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930194457636.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930194457636.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算举例" style="zoom:50%;" /></li></ol><h1 id="5-数字传输系统"><a href="#5-数字传输系统" class="headerlink" title="5 数字传输系统"></a>5 数字传输系统</h1><h2 id="5-1-旧的数字系统"><a href="#5-1-旧的数字系统" class="headerlink" title="5.1 旧的数字系统"></a>5.1 旧的数字系统</h2><p>最早  频分复用FDM</p><p>较早前  时分复用PCM ，PDH（异步时分复用）准同步数字序列</p><p><strong>缺点</strong></p><p>​速率不统一，不是同步传输</p><p>中国&#x2F;欧洲的基群速率是E1，大约2Mbps</p><p>日本&#x2F;北美的基群速率是T1,大约是1.5Mbps</p><h2 id="5-2-新数字系统"><a href="#5-2-新数字系统" class="headerlink" title="5.2 新数字系统"></a>5.2 新数字系统</h2><p>​基于光缆的同步数字序列SDH（同步时分复用），和WDM，波分复用</p><h1 id="6-带宽接入技术"><a href="#6-带宽接入技术" class="headerlink" title="6 带宽接入技术"></a>6 带宽接入技术</h1><p>用户要连接到互联网，必须先连接到某个ISP（互联网服务提供商），以便获得上网所需要的IP</p><p>最开始的时候，通过使用电话的用户线通过调制解调连接到ISP的，为了提高上网速率，提出了多种带宽接入技术</p><p>大体分为两类，无线接入和有线接入</p><p>这里重点讲有线接入</p><h2 id="6-1-DSL（数字用户线）"><a href="#6-1-DSL（数字用户线）" class="headerlink" title="6.1 DSL（数字用户线）"></a>6.1 DSL（数字用户线）</h2><p>有线宽带接入技术</p><p>DSL利用标准的电话线路来传输数字数据，同时允许用户在不影响电话通信的情况下同时使用互联网</p><p><strong>分为多种类型</strong>：DSL有多个变种，包括以下几种：</p><ul><li><p><strong>ADSL（Asymmetric DSL）</strong>：ADSL提供不对称的上行和下行速度（上行指用户到ISP，下行指ISP到用户，下行更快），通常下载速度较快，适用于普通家庭用户。ADSL的传输距离取决于数据率和用户线路径</p><p>对于ADSL的调制解调，我国采用离散多音调<strong>DMT技术</strong></p><p>​<strong>DMT技术</strong></p><p>频分复用，上行信道少，下行信道多</p><p>最高传输速率取决于信噪比，传输距离</p><p>对于ADSL接入</p><p>关键设备是ADSL猫</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930195644009.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930195644009.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ADSL猫示意图"></p></li><li><p><strong>SDSL（Symmetric DSL）</strong>：SDSL提供对称的上行和下行速度，适用于需要对等上传和下载速度的业务用户，如一些企业</p></li><li><p><strong>VDSL（Very High Bitrate DSL）</strong>：VDSL提供更高的传输速度，适用于需要更高带宽的用途，如高清视频流和在线游戏。</p> <img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111215307056.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111215307056.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="例题" style="zoom:33%;" /></li></ul><h2 id="6-2HFC-光纤同轴混合网"><a href="#6-2HFC-光纤同轴混合网" class="headerlink" title="6.2HFC  光纤同轴混合网"></a>6.2HFC  光纤同轴混合网</h2><p>HFC是在有线电视网基础上开发的一种居民接入技术</p><p>它结合了光纤和同轴电缆两种不同的传输媒介。</p><p>频分复用，双向传输</p><h3 id="6-2-1-接入"><a href="#6-2-1-接入" class="headerlink" title="6.2.1 接入"></a>6.2.1 接入</h3><p>每个家庭要安装一个用户接口盒UIB</p><p>UIB提供三种连接，分别用于不同的应用场合</p><p>1 同轴电缆连接到机顶盒（因为要使得模拟电视机接收数字信号，所以用机顶盒），然后再连接到用户电视机</p><p>2 使用双绞线连接到用户的电话机</p><p>3 使用电缆调制解调器（一般在机顶盒内部集成）连接到用户的计算机</p><h2 id="6-3-FTTx技术"><a href="#6-3-FTTx技术" class="headerlink" title="6.3 FTTx技术"></a>6.3 FTTx技术</h2><p>FTTx是一种广泛用于提供高速互联网连接的技术，它利用光纤到户</p><p> “x” 代表不同的变种，包括FTTH（光纤到家）、FTTC（光纤到路边）和FTTB（光纤到大楼）。</p><p>对于普通居民而言，就是FTTH啦</p><p>FTTH是一种光纤接入技术，其中光纤被延伸到用户家庭的终端。这意味着数据通过光纤传输到用户家庭内部，提供了高速、稳定的互联网连接。FTTH通常提供对称的上行和下行速度，适用于需要大带宽的应用，如高清视频流、在线游戏和远程工作。</p><p>而我们知道，一个用户无法用完一条光纤的资源，所以设置了光配线网（ODN）目前常常使用的是下图的无源光配线网络PON，使得数十个家庭用户能够共享一个干线</p><p>其中注意一点，无源是指PON不用电源</p><p><strong>无源光网络PON</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201109120.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201109120.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="无源光网络PON"></p><p>观察上图可知 </p><p><strong>PON组成</strong></p><p>1 局端   中心控制站</p><p>2 用户端   光网络单元ONU（又叫做光猫）</p><p>3 光配线网</p><p>而AON是有源，维护难度大</p><p><strong>PON接入</strong></p><p>光猫</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201735085.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201735085.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="光猫"></p><p><strong>家庭主流接入方式</strong></p><p>可以看到从ONU出来后</p><p>有线部分可以接计算机</p><p>无线部分可以连手机WIFI之类的</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201851760.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201851760.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="家庭主流接入方式"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（二）物理层上</title>
      <link href="/2023/11/16/Computer_system/Net/2%20%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2023/11/16/Computer_system/Net/2%20%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>内容笔记来源于谢希任老师《计算机网络》 </p><p>物理层重点</p><p>1 复用的概念</p><p>2 宽带接入技术，家庭和公司如何接入Internet？PON接入，画接入Internet的拓扑图</p><h1 id="1-物理层基本概念"><a href="#1-物理层基本概念" class="headerlink" title="1 物理层基本概念"></a>1 物理层基本概念</h1><p>物理层考虑的是怎样在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。怎么理解呢？因为我们的物理传输媒介千差万别，有可能通过光缆，有可能无线空气传输等等，那么物理层就要想办法消除这些差别，让物理层之上的数据链路层不必考虑具体的传输媒介，只需要关注本层的一些协议就好</p><p>用于物理层的协议也叫作物理层的<strong>规程</strong></p><p>可以将物理层的任务描述为确定与传输媒体的接口有关的一些特性，即</p><p><strong>机械特性</strong>  指明接口所用的接线器的形状和尺寸，引线数目和排列</p><p><strong>电气特性</strong>  指明在接口电缆的各条线上出现的电压范围</p><p><strong>功能特性</strong>  指明某一电平的电压表示何种意义</p><p><strong>过程特性</strong>  指明对于不同功能的各种事件出现顺序</p><p>学习之前，需要先了解一些通信的基础知识</p><h1 id="2-数据通信基础知识"><a href="#2-数据通信基础知识" class="headerlink" title="2.数据通信基础知识"></a>2.数据通信基础知识</h1><h2 id="2-1-数据通信基本概念"><a href="#2-1-数据通信基本概念" class="headerlink" title="2.1 数据通信基本概念"></a>2.1 数据通信基本概念</h2><p>我们通信的目的是<strong>传递消息</strong>，比如我打电话想告诉妈妈今天晚上想吃油闷大虾。</p><p>将这个消息使用特定方式表示之后，就可以得到<strong>数据</strong>，数据是运送这个消息的实体，</p><p>而信号是<strong>数据</strong>的电气和电磁的表现，同一个数据，用不同的方式传递，有不同的电气电磁表现。</p><p>那么数据又分为</p><p><strong>模拟的</strong> 代表信息的参数取值是连续的</p><p><strong>数字的</strong> 代表信息的参数取值是离散的</p><p>​<strong>码元：</strong> 时域的波形表示数字信号时，代表不同离散数值的基本波形</p><h2 id="2-2-信道基本概念"><a href="#2-2-信道基本概念" class="headerlink" title="2.2 信道基本概念"></a>2.2 信道基本概念</h2><p>了解 </p><p><strong>单工</strong>  单向通信，只能有一个方向交互，如广播电视，只能它向我们发送</p><p><strong>半双工</strong> 双向交替通信 ，如对讲机，只能一次一个人讲话</p><p><strong>全双工</strong> 双向通信，如打电话</p><p><strong>基带信号</strong></p><p>​即基本频带信号，来自数据发送方的信号，像计算机输出的各种文字或者图像文件的数据信号都属于基带信号</p><p>可以分为：</p><p>​模拟基带信号：如人说话产生的声波</p><p>​数字基带信号：如计算机产生数据的方波</p><p>而这种基带信号往往含有很多的直流或者低频成分，许多信道都不支持，在信道中直流和丰富低频成分的基带信号衰减的比较厉害，特别是直流不是被电容隔离就是被电感旁路，所以需要进行<strong>调制</strong>（通过变化去除这些成分）</p><p>调制有两种方式</p><p>方式一 <strong>基带调制</strong> 又称编码，对输入信号的波形进行变换， 输入为数字基带信号，仍为数字基带信号，如曼彻斯特编码</p><p>方式二 <strong>带通调制</strong> 使用载波调制，把基带信号频率范围搬移到较高的频段，并转换为模拟信号，如调幅调制</p><p>首先介绍方式一</p><h3 id="2-2-1-基带调制（编码）方式"><a href="#2-2-1-基带调制（编码）方式" class="headerlink" title="2.2.1 基带调制（编码）方式"></a>2.2.1 基带调制（编码）方式</h3><p>1 不归零制</p><p>2 归零制</p><p>3 曼彻斯特编码 ，方便同步比特个数</p><p>​数据位的中心点用来判断信号的取值。如果信号从低电平到高电平（或相反）变化，表示数据位为0；如果信号从高电平到低电平（或相反）变化，表示数据位为1。</p><p>4 差分曼彻斯特编码</p><p>​差分曼彻斯特编码的关键是信号的变化方式。在一个周期内，如果信号发生了变化，表示数据位为1；如果信号没有变化，表示数据位为0。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212007504.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212007504.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="不同编码方式"></p><p>再介绍方式二</p><h3 id="2-2-2-带通调制方式"><a href="#2-2-2-带通调制方式" class="headerlink" title="2.2.2 带通调制方式"></a>2.2.2 带通调制方式</h3><p>调制 对基带信号的几种调制方式</p><p>1 调相</p><p>2 调幅</p><p>3 调频</p><p>4 正交振幅调制</p><h2 id="2-3-信道的极限速率影响因素"><a href="#2-3-信道的极限速率影响因素" class="headerlink" title="2.3 信道的极限速率影响因素"></a>2.3 信道的极限速率影响因素</h2><p>那么我们通信核心一个议题就是想要传输的更快</p><p>但是研究表明，传输速率受到两个因素影响</p><h3 id="2-3-1-频率范围"><a href="#2-3-1-频率范围" class="headerlink" title="2.3.1 频率范围"></a>2.3.1 <strong>频率范围</strong></h3><p>当速度增大时候，码元之间的界限就会模糊，导致最后相互干扰，出现“码间串扰现象”，接收方就无法分辨，为了避免码间串扰，香农给出奈式准则，在无噪声的情况下，最高码原传递速率等于两倍的带宽（带宽反应频率范围）</p><p>知道带宽的情况下，就可以知道最大传输速率了，比如带宽W&#x3D;4000Hz，那么最大码元传输速率8000码元&#x2F;秒</p><p>即公式为 $最大码元传输速率&#x3D;2W （码元&#x2F;s）$</p><p>这里有一个问题，就是一个码元是多少bit，如果码元有4种，则需要两bit，如果是8种，则需要3bit，如果是16种则4bit，所以一个码元的bit数取决于码元的种类，等于$log_2V$</p><p>则理想状态下的极限传输速率为</p><p>$2Wlog_2V(bit &#x2F;s)$</p><p>注意这里的最大码元速率，和最大传输速率的区别！！！单位也不同，含义也不同</p><p>例题</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212346615.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212346615.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="例题1" style="zoom:33%;" />但实际传输过程中，不能没有噪声，而噪声也对传输速率有影响，因而引入一个关键定义信噪比，也是影响速率的第二个因素<h3 id="2-3-2-信噪比"><a href="#2-3-2-信噪比" class="headerlink" title="2.3.2 信噪比"></a>2.3.2 <strong>信噪比</strong></h3><p>信噪比就是信号的平均功率和噪声的平均功率之比，常常记作S&#x2F;N，以分贝为单位</p><p>$信噪比&#x3D;10log_{10}(S&#x2F;N) （dB）$</p><p>当S&#x2F;N&#x3D;10的时候，信噪比为10dB，当S&#x2F;N&#x3D;1000时，信噪比为30dB</p><p>基于信噪比，香农提出了香农公式</p><p>噪声情况下，$极限信息传输速率C&#x3D;Wlog_2(1+S&#x2F;N) (bit&#x2F;s)$</p><p>W还是带宽</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111213107071.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111213107071.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="例题2" style="zoom:33%;" />注意这里需要注意一下哈，列不等式]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）概述</title>
      <link href="/2023/11/15/Computer_system/Net/1%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/15/Computer_system/Net/1%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>内容笔记来源于谢希任老师《计算机网络》</p><p>计算机网络可以说是现代生活最重要的一部分了</p><p>互联网（或因特网）之所以能够向用户提供服务，是因为互联网具有两个重要基本特点 连通性 和 共享</p><p>网络把许多计算机连在一起</p><p>互联网则把许多网络通过路由器连在一起</p><p>与网络相连的计算机叫做主机</p><p>互联网发展的三个阶段</p><p>1 单个网络ARPANET向互联网发展</p><p>2 建成三级结构因特网 主干网 地区网 校园网</p><p>3 出现多层次ISP 因特网服务提供者</p><h1 id="1-互联网组成"><a href="#1-互联网组成" class="headerlink" title="1. 互联网组成"></a>1. 互联网组成</h1><h2 id="1-1-四元素组成"><a href="#1-1-四元素组成" class="headerlink" title="1.1 四元素组成"></a>1.1 四元素组成</h2><p>用户设备</p><p>网络设备</p><p>传输介质</p><p>网络协议</p><h2 id="1-2-二元素组成"><a href="#1-2-二元素组成" class="headerlink" title="1.2 二元素组成"></a>1.2 二元素组成</h2><p><strong>边缘部分</strong></p><p>​所有连接在因特网的主机组成，用来进行数据资源共享，也称资源子网</p><p>​这部分直接用户使用的，</p><p><strong>核心部分</strong></p><p>​由大量网络和连接这些网络的路由器组成，提供了连通性和交换，也称为通信子网，为边缘部分提供服务</p><h3 id="1-2-1-边缘部分"><a href="#1-2-1-边缘部分" class="headerlink" title="1.2.1 边缘部分"></a>1.2.1 边缘部分</h3><p>如个人电脑，乃至一个很小的网络摄像头等</p><p>边缘部分利用核心部分所提供的服务</p><p>在网络边缘部分的端系统通信往往可以分为两种</p><p>1 客户服务器方式</p><p>​最为常见，比如我们在网络上搜索资料，或者收发邮件都是这样的</p><p>​主要特征是 客户是服务的请求方，服务器是服务的提供方</p><p>2 对等方式P2P</p><p>​对等连接方式可以支持大量对等用户工作，如QQ微信</p><h3 id="1-2-2-核心部分"><a href="#1-2-2-核心部分" class="headerlink" title="1.2.2  核心部分"></a>1.2.2  核心部分</h3><p>核心部分起特殊作用的是路由器</p><p>路由器实现的<strong>分组交换</strong></p><p>之前用电路交换，现在更多用分组交换</p><p>为什么要用分组交换</p><p>​计算机数据突发性强，使用分组交换承载计算机数据成本低</p><p><strong>区分分组交换和电路交换</strong></p><p>分组交换和电路交换都是计算机网络中常见的数据传输方式，但它们的实现方式和特点有所不同。</p><p>分组交换是一种将数据分成小块（即分组）进行传输的方式。在分组交换中，发送方将数据分成若干个大小相等的数据块，每个数据块被赋予一个地址，并通过网络独立传输。数据到达接收方后，接收方将数据块重新组装成原始数据。分组交换的优点是能够动态地分配网络带宽，提高网络利用率。常见的分组交换协议包括IP协议、TCP协议等。</p><p>电路交换是一种在通信开始前建立网络电路（即物理路径）的方式，并在通信过程中保持该电路。在电路交换中，发送方和接收方之间建立一个可靠的物理连接，并在通信过程中独占该连接。电路交换的优点是通信过程中具有稳定的带宽和延迟，适用于需要实时传输的应用，例如电话通信。常见的电路交换协议包括PSTN、ISDN等。</p><p>可以通过这样一个<strong>比喻来理解</strong></p><p>假设你要从一个城市到另一个城市旅行。如果你选择搭乘公共汽车，那么你需要在汽车站等待，直到一辆符合你行程的公共汽车出现，然后支付车费、上车，到达目的地后下车，这个过程就是电路交换的过程。</p><p>而如果你选择自驾游，那么你可以根据自己的行程和时间，制定出一张路线图，根据路线上的标志和地图，沿途行驶，在需要休息或加油时停车，到达目的地后停车。这个过程就是分组交换的过程。</p><p>可以看到，分组交换和电路交换的区别在于，电路交换是一种预先占用资源的方式，需要建立一个独占的物理连接（买票后别人就不能占用你的位置），而分组交换则是一种动态分配资源的方式（自己的车离开后别人就可以使用），可以根据需要在网络中分配资源。</p><p>这就涉及到一个问题</p><p><strong>分组如何实现？</strong></p><p>（1）发送端，把较长的报文划分成较短的，固定长度的数据段</p><p>（2）每一个数据段前添上首部，每一个数据段可以看做一个分组</p><p>首部含有的信息有地址（转发到下一个结点的交换机）</p><p>（3）以“分组”为数据单元传输，依次把分组传到接收端</p><p>（4）接收端收到分组后就剥去首部 还原成报文</p><p><strong>分组交换优点</strong></p><p>高效 灵活 迅速 可靠</p><p><strong>可能带来的问题</strong></p><p>可能需要排队，产生时延</p><p>首部的控制信息有开销</p><h1 id="2-计算机网路的功能"><a href="#2-计算机网路的功能" class="headerlink" title="2.计算机网路的功能"></a>2.计算机网路的功能</h1><p><strong>数据通信</strong></p><p>而最基本的功能是数据通信</p><p><strong>资源共享</strong></p><p>计算机网络的资源主要指</p><p>​计算机硬件、软件与数据</p><h1 id="3-计算机网络类别"><a href="#3-计算机网络类别" class="headerlink" title="3. 计算机网络类别"></a>3. 计算机网络类别</h1><h2 id="3-1-按照网络作用范围进行分类"><a href="#3-1-按照网络作用范围进行分类" class="headerlink" title="3.1 按照网络作用范围进行分类"></a>3.1 按照网络作用范围进行分类</h2><p>广域网WAN</p><p>​作用范围通常几十公里到几千公里</p><p>城域网MAN</p><p>​作用距离5-50公里</p><p>局域网LAN</p><p>​作用距离 1公里左右</p><p>个人区域网PAN</p><p>​10米左右</p><p>无线个域网</p><p>​如蓝牙，ZIGBee</p><h2 id="3-2-按照网络的使用者进行分类"><a href="#3-2-按照网络的使用者进行分类" class="headerlink" title="3.2 按照网络的使用者进行分类"></a>3.2 按照网络的使用者进行分类</h2><p>（1）公用网</p><p>指电信公司出资建造的大型网络，缴费的人即可使用</p><p>（2）专用网</p><p>某个部分为满足本单位的特殊业务工作的需要而建造的网络</p><h1 id="4-计算机网络性能指标"><a href="#4-计算机网络性能指标" class="headerlink" title="4 计算机网络性能指标"></a>4 计算机网络性能指标</h1><p><strong>1 速率</strong></p><p>指单位时间内传输的数据量，通常以(b&#x2F;s)bps、Kbps、Mbps等单位来表示。传输速率与带宽密切相关，但不同于带宽，它还考虑了传输数据的效率、误码率等因素。bps  Bit Per Second的缩写</p><p>以高清视频为例，它需要的传输速率大概在5-10 Mbps之间。因此，如果你的网络带宽是10 Mbps，就足以支持高清视频的流畅播放。如果网络带宽只有1 Mbps，则观看高清视频时可能会出现卡顿、缓冲等问题。</p><p><strong>2 带宽</strong></p><p>指网络中能够传输的最大数据量，通常以每秒传输的比特数（bps）来衡量。带宽越高，网络传输速度越快，数据传输能力越强。</p><p><strong>速率和带宽的区别</strong></p><p>速率指单位时间内传输的数据量，通常以bps、Kbps、Mbps等单位来表示。速率与数据传输的效率、误码率等因素有关。</p><p>带宽指网络中能够传输的最大数据量，通常也以bps、Kbps、Mbps等单位来表示。带宽是网络的物理特性，与网络的传输效率、误码率等因素无关。</p><p>可以通过一个比喻来理解速率和带宽的区别。假设你要从一桶水中抽取一定量的水，速率就表示你每秒钟能够抽取的水的数量，而带宽则是指这个水桶的容量大小。</p><p>网络界单位换算是1000</p><p>而存储界 单位换算是$2^{10}$</p><p><strong>3 吞吐量</strong></p><p>指单位时间内通过网络的数据量，通常以bps、Kbps、Mbps等单位来表示。吞吐量与传输速率类似，但还考虑了网络中拥塞的情况。</p><p><strong>4 时延</strong></p><p>指数据从发送方到接收方所需的总时间。时延包括</p><p>发送时延 数据从结点进入到传输媒体所需要的时间</p><p>​$发送时延&#x3D;\frac{数据帧长度b}{发送速率b&#x2F;s}$</p><p>传播时延（数据从发送方到接收方所需时间）</p><p>​$传播时延&#x3D;\frac{信道长度（米）}{信号在信道上传播速率m&#x2F;s}$</p><p>处理时延（路由器或交换机对数据进行处理所需时间）</p><p>排队时延（等待路由器或交换机处理数据的时间）四个部分。</p><p>注意，电路交换提前建立好了路径，所以中间节点是没有发送时延的，只有最开始有发送时延，而分组交换没有提前建立路径，所以对于k个链路，有k-1个节点，产生K-1个发生时延</p><p>容易产生错误的概念</p><p>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是在比特链路上的传播速率</p><p><strong>5 时延带宽积</strong></p><p>是指在一个网络中，数据从发送端到接收端所需要的时间与网络带宽的乘积。它的单位通常是比特（bits）可以用来评估网络的传输性能，也是确定网络传输最大吞吐量的一个重要参数。</p><p><strong>6 往返时间RTT</strong></p><p>是指数据从发送端发送到接收端并返回的时间，通常使用毫秒（ms）作为单位。</p><p>7 <strong>利用率</strong></p><p>利用率（Utilization）是指网络资源在一段时间内被使用的程度，是衡量网络资源利用效率的一个重要指标。利用率通常使用百分比（%）或小数表示，例如50%或0.5</p><p>时延与网络利用率关系</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923224301410.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923224301410.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="时延与网络利用率关系" style="zoom: 33%;" /><p>8 <strong>数据传输效率</strong></p><h1 id="5-计算机网络体系结构"><a href="#5-计算机网络体系结构" class="headerlink" title="5 计算机网络体系结构"></a>5 计算机网络体系结构</h1><p>计算机网络学习的过程中，一个非常显著的特点就是会发现他是分层的，为何要这样做呢？</p><p>实际上，是因为看似网络传输这样一个简单问题，涉及到很多细节内容，如传输对方是否可以接收，如果可以出现差错怎么办，如果文件格式不匹配怎么来转换？等等一系列问题。所以计算机网络的设计者们就提出采用分层的方式来将庞杂的问题化大为小，各点突破！</p><p>常见的网络体系结构有OSI参考模型和TCP&#x2F;IP参考模型两种，OSI提出的要比TCP&#x2F;IP早，但是因为一些原因一直没有得到广泛商用，所以也就意味着当下商用的模型都主要是TCP&#x2F;IP模型，也是我们学习的重点</p><ol><li>OSI参考模型</li></ol><p>OSI参考模型是由国际标准化组织（ISO）制定的一个网络体系结构标准。它共分为七层，包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层都有自己的特定功能和任务，不同层之间通过接口进行通信，从而实现数据传输和处理。</p><ol><li>TCP&#x2F;IP参考模型</li></ol><p>TCP&#x2F;IP参考模型是由美国国防部高级研究计划局（ARPA）制定的一个网络体系结构标准。它共分为四层，包括链路层、网络层、传输层和应用层。与OSI参考模型不同，TCP&#x2F;IP参考模型将会话层、表示层和应用层合并为一个应用层，简化了网络结构，提高了网络的可靠性和效率。在学习过程中还会引入物理层（为了便于讲述原理等）。</p><p>所以我们实际学习的是五层</p><p>而每一层有很多协议，协议我们就可以理解为约定。</p><p>比如我们往往可以在谍战片里看到两个人接头暗号，就是一种协议，知道对方是要做什么，怎么做等等</p><p>因而计算机网络协议是我们要学习的重点</p><h1 id="6-计算机网络协议"><a href="#6-计算机网络协议" class="headerlink" title="6 计算机网络协议"></a>6 计算机网络协议</h1><h2 id="6-1-计算机网络协议与组成"><a href="#6-1-计算机网络协议与组成" class="headerlink" title="6.1 计算机网络协议与组成"></a>6.1 计算机网络协议与组成</h2><p>网络协议是计算机网络中数据传输和通信的规则集合。一个完整的网络协议通常包括以下几个要素：</p><ol><li>语法：定义了数据传输的格式和规范，即数据在网络中的组织方式和编码方式。</li><li>语义：定义了数据传输的含义和解释方式，即数据在网络中的意义和作用。</li><li>同步：定义了数据传输的时间顺序和流程，即数据在网络中的传输顺序和时序关系。</li></ol><h2 id="6-2-PDU"><a href="#6-2-PDU" class="headerlink" title="6.2  PDU"></a>6.2  PDU</h2><p>PDU：协议数据单元</p><p>什么是协议数据单元呢？</p><p>首先我们知道我们传输的都是数据，数据会从发送方的顶层出发，一层一层向下传输到物理层，然后通过物理介质传输到接收方，接收方再一层一层向上到顶层</p><p>其中每到一层，都会根据当层协议去给数据加信息</p><p>所以PDU定义如下</p><p>在计算机网络通信中，PDU 是指在不同网络层之间传输的数据单元。每个网络层将数据辅助添加到 PDU 中，然后将其传递给下一层，直到数据到达目标。</p><p>PDU&#x3D;首部+载荷+尾部</p><p>各层PDU名称</p><p>各层PDU名称如下：</p><ol><li><p>物理层：比特流（Bit Stream）</p></li><li><p>数据链路层：帧（Frame）</p></li><li><p>网络层：包（Packet）</p></li><li><p>传输层：TCP的PDU： 报文段</p><p>​              UDP的PDU  ：用户数据报</p></li><li><p>应用层： 报文</p></li></ol><p>再来了解几个概念</p><p><strong>实体</strong></p><p>实体表示任何可发送或接收信息的硬件或软件进程</p><p><strong>协议</strong></p><p>协议是控制两个对等实体进行通信规则的集合</p><p>协议是水平的，即协议是控制对等实体之间的通信规则</p><p><strong>服务</strong></p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</p><p>服务是垂直的，即服务是由下层向上层通过层间接口提供的</p><p>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点SAP</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）设备管理</title>
      <link href="/2023/10/20/Computer_system/Os/6%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/20/Computer_system/Os/6%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210604795.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210604795.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="总览图"></p><h1 id="1-设备管理概述"><a href="#1-设备管理概述" class="headerlink" title="1 设备管理概述"></a>1 设备管理概述</h1><h2 id="1-1-系统总线结构"><a href="#1-1-系统总线结构" class="headerlink" title="1.1 系统总线结构"></a>1.1 系统总线结构</h2><p>系统总线上传输的信息有——数据 地址 其他控制状态定时信号</p><p>系统总线其实有几类</p><p>如下图 CPU总线 存储器总线 和I&#x2F;O总线</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118173505779.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118173505779.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="CPU总线 存储总线 I/O总线"></p><p>其中北桥芯片组把处理器和存储器分成了两个总线</p><p>南桥芯片连接在I&#x2F;O总线上</p><p>I&#x2F;O总线上连着众多的I&#x2F;O设备</p><p>当然I&#x2F;O总线和I&#x2F;O设备之间通过设备管理器进行连接控制</p><p>那么设备管理器的结构是怎样的呢？</p><h2 id="1-2-设备控制器通用结构"><a href="#1-2-设备控制器通用结构" class="headerlink" title="1.2 设备控制器通用结构"></a>1.2 设备控制器通用结构</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183119930.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183119930.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设备控制器结构"></p><p>控制不同的外设需要不同的设备控制器，将系统总线和设备侧的接口连在一起</p><h2 id="1-3-I-O设备的模型"><a href="#1-3-I-O设备的模型" class="headerlink" title="1.3 I&#x2F;O设备的模型"></a>1.3 I&#x2F;O设备的模型</h2><p>对于外部设备而言，他们的设备如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183147173.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183147173.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="外部设备通用模型"></p><h1 id="2-I-O端口"><a href="#2-I-O端口" class="headerlink" title="2 I&#x2F;O端口"></a>2 I&#x2F;O端口</h1><p>I&#x2F;O设备中非常重要的一部分就是外设寄存器（也叫做I&#x2F;O端口，下文我们都叫做I&#x2F;O端口了）（存储着设备状态，数据等）</p><p>控制需要了解外设寄存器值，读取数据也是从相应的寄存器值读取</p><p>I&#x2F;O端口通常包括：控制寄存器、状态寄存器和数据寄存器三大类</p><p>所以这里就牵扯出一个问题，CPU下达指令读或写某个I&#x2F;O端口（寄存器），需要知道那个寄存器在哪里，也就是说寄存器的地址是什么，这就涉及到I&#x2F;O端口的编址以及寻址</p><h2 id="2-1-寻址方式"><a href="#2-1-寻址方式" class="headerlink" title="2.1 寻址方式"></a>2.1 寻址方式</h2><p><strong>统一编址方式（内存映射方式）</strong></p><p>与主存空间统一编址，主存单元和I&#x2F;O端口在同一个地址空间</p><p>外设与内存统一的编址方式，优点是编程简单，因为可以像访问内存一样去访问外设。缺点是IO也占用CPU的寻址空间。</p><p><strong>独立编址方式（特殊I&#x2F;O指令方式）</strong></p><p>单独编号，不和主存单元一起编，使成为一个独立的I&#x2F;O地址空间，例如Intel处理器</p><p>而独立编址的方式，优点是不占用CPU的寻址空间，但是CPU的构造比较复杂。(因为额外的CPU指令需要对CPU进行额外的设计处理)。</p><h1 id="3-驱动程序"><a href="#3-驱动程序" class="headerlink" title="3 驱动程序"></a>3 驱动程序</h1><p>控制外设进行输入输出的底层I&#x2F;O软件是驱动程序，由设备生产商制作，包括 设备控制器中有哪些用户可以访问的寄存器、控制状态寄存器的每一位的含义，通信协议等等</p><p>驱动程序通过访问 I&#x2F;O端口控制外设进行I&#x2F;O</p><p>​比如 读取控制命令送到控制寄存器来启动外设工作</p><p>​读取状态寄存器了解外设和设备控制器的状态</p><p>​访问数据缓冲寄存器进行数据的输入和输出</p><p>实现这种访问操作是通过I&#x2F;O操作完成的，他是一种特权指令</p><h1 id="4-基本I-O控制方式"><a href="#4-基本I-O控制方式" class="headerlink" title="4 基本I&#x2F;O控制方式"></a>4 基本I&#x2F;O控制方式</h1><p>有如下四种</p><h2 id="4-1-程序直接控制"><a href="#4-1-程序直接控制" class="headerlink" title="4.1 程序直接控制"></a>4.1 程序直接控制</h2><p>​程序查询I&#x2F;O方式</p><p><strong>原理</strong> 由CPU负责直接控制I&#x2F;O操作，不涉及中断或DMA（Direct Memory Access）。</p><p><strong>方法</strong></p><p>计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字， CPU 需要对外设状态进行循环检查，直到确定该字已经在I&#x2F;0 控制器的数据寄存器中</p><p><strong>优点</strong> 简单、易于实现。</p><p><strong>缺点</strong></p><p>在程序直接控制方式中，由于CPU 的高速性和I&#x2F;0设备的低速性，致使CPU 的绝大部分时间都处于等待I&#x2F;0 设备完成数据I&#x2F;0 的循环测试中，造成了<strong>CPU 资源的极大浪费</strong>。在该方式中， CPU 之所以要不断地测试I&#x2F;0 设备的状态，就是因为在CPU 中未采用中断机构，使I&#x2F;0 设备无法向CPU报告它已完成了一个字符的输入操作。</p><h2 id="4-2-中断I-O方式"><a href="#4-2-中断I-O方式" class="headerlink" title="4.2 中断I&#x2F;O方式"></a>4.2 中断I&#x2F;O方式</h2><p>​中断I&#x2F;O方式</p><p><strong>原理</strong> 设备在完成操作后发出中断信号，通知CPU进行数据传输。</p><p><strong>方法</strong></p><p>中断驱动方式的思想是，允许I&#x2F;0 设备主动打断CPU 的运行并请求服务，从而“解放”CPU, 使得其向I&#x2F;0 控制器发送读命令后可以继续做其他有用的工作。</p><p><strong>优点：</strong> 提高CPU利用率，减少了对CPU的占用。</p><p><strong>缺点</strong></p><p>中断方式在一些情况下可以提高CPU利用率，但在一些情况下，字符式设备，其中断频率太高，来回切换的话也会耗费处理机较多时间</p><p>核心是因为什么？</p><p>是因为上面两种方式都需要经过CPU处理？</p><p>什么叫经过CPU处理</p><p>是外设输入数据流大概是这样的： 【外围设备-&gt;I&#x2F;O控制器的数据寄存器-&gt;CPU寄存器-&gt;存储器】，这就叫经过CPU，或者说传输数据的过程需要CPU的干预</p><p>于是引出了下面的DMA(直接在I&#x2F;O设备和内存之间建立数据通路)</p><h2 id="4-3-DMA方式"><a href="#4-3-DMA方式" class="headerlink" title="4.3 DMA方式"></a>4.3 DMA方式</h2><p>磁盘等高速外设设备所用的方式</p><p><strong>原理</strong></p><p>​基本思想 在高速外设和主存间直接传送数据</p><p>​由专门硬件<strong>（即DMA控制器）</strong>控制总线进行传输，注意这里不是CPU了</p><p><strong>方式</strong></p><ol><li>基本单位是数据块（前面是一个字）。</li><li>所传送的数据，是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU 干预，整块数据的传送是在DMA控制器的控制下完成的。</li></ol><p><strong>优点</strong> 大大减轻了CPU的负担，提高了数据传输速率。</p><p><strong>缺点</strong> 需要额外的硬件支持，复杂度较高。</p><p>如何进一步提高资源利用率呢？当然是请更牛逼的通道，将苦逼的CPU尽可能的从累活中解放出来。</p><h2 id="4-4-I-O通道控制方式"><a href="#4-4-I-O通道控制方式" class="headerlink" title="4.4 I&#x2F;O通道控制方式"></a>4.4 I&#x2F;O通道控制方式</h2><p><strong>原理</strong> 使用专门的I&#x2F;O通道控制器，它独立于CPU和主存储器，负责管理多个设备的I&#x2F;O操作</p><p><strong>方式</strong></p><p>I&#x2F;0 通道是指专门负责输入／输出的处理机。I&#x2F;O通道方式是DMA方式的发展，它可以进一步 减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I&#x2F;0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p><p><strong>优点：</strong> 高度并行化的数据传输，减少了对CPU的占用。</p><p><strong>缺点：</strong> 需要更复杂的硬件支持，成本较高。</p><h1 id="5-I-O管理中的重要思想"><a href="#5-I-O管理中的重要思想" class="headerlink" title="5 I&#x2F;O管理中的重要思想"></a>5 I&#x2F;O管理中的重要思想</h1><h2 id="5-1-设备独立性"><a href="#5-1-设备独立性" class="headerlink" title="5.1 设备独立性"></a>5.1 设备独立性</h2><p>该思想旨在使应用程序与具体的I&#x2F;O设备解耦，从而提高系统的灵活性、可移植性和可维护性。</p><h2 id="5-2-SPOOLing技术"><a href="#5-2-SPOOLing技术" class="headerlink" title="5.2 SPOOLing技术"></a>5.2 SPOOLing技术</h2><p>​即外围设备同时联机操作，又称作假脱机操作</p><p>什么是<strong>脱机I&#x2F;O</strong>？</p><p>​脱机I&#x2F;O  目的是为了解决CPU和I&#x2F;O速度不匹配的问题，输入由一台低挡计算机做中介</p><p>什么是<strong>假脱机</strong>？</p><p>​即模拟实现上面的脱机i&#x2F;O</p><p><strong>实现方法</strong></p><p>​OS利用两个进程分别模拟脱机I&#x2F;O时外围机的功能</p><p>​其中一个进程负责将输入设备的数据传送到磁盘，另一个进程负责将数据从磁盘送到输出设备</p><p><strong>组成</strong></p><p>​1 输入输出井</p><p>​2 预输入进程和缓输出进程</p><h2 id="5-3-I-O软件的多层模型"><a href="#5-3-I-O软件的多层模型" class="headerlink" title="5.3 I&#x2F;O软件的多层模型"></a>5.3 I&#x2F;O软件的多层模型</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118190157639.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118190157639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="I/O软件的多层模型"></p><p>1 用户进程层——执行I&#x2F;O系统调用，对I&#x2F;O数据进行格式化(如将十进制数转换为ASCLL码字符串以便输出)</p><p>2 独立于设备的软件——实现设备的命名，分配，数据的缓冲，设备的保护，提供下层的统一接口，检查用户是否有权使用</p><p>3 设备驱动程序，与设备有关的代码，向设备控制器发送命令，检测设备的执行状态</p><p>4 中断处理程序，负责I&#x2F;O完成时，唤醒设备驱动程序的进程，进行中断处理</p><p>5 硬件层 实现物联I&#x2F;O操作</p><h1 id="6-磁盘I-O"><a href="#6-磁盘I-O" class="headerlink" title="6 磁盘I&#x2F;O"></a>6 磁盘I&#x2F;O</h1><p>磁盘一般分为固定结构和移动头磁盘两大类</p><p>固定头磁盘——每个盘面的每条磁道都有一个读写磁头，固定头磁盘各个磁头可并行读写，成本高</p><p>移动头磁道——每个盘面只有一个读写磁头</p><h2 id="6-1-磁盘调度算法"><a href="#6-1-磁盘调度算法" class="headerlink" title="6.1 磁盘调度算法"></a>6.1 磁盘调度算法</h2><p>目标 使得磁盘平均寻道时间最短 </p><h3 id="6-1-1-先来先服务-FCFS"><a href="#6-1-1-先来先服务-FCFS" class="headerlink" title="6.1.1 先来先服务 FCFS"></a>6.1.1 先来先服务 FCFS</h3><p>按请求访问磁盘的先后次序进行调度</p><h3 id="6-1-2-最短寻道时间优先-SSTF"><a href="#6-1-2-最短寻道时间优先-SSTF" class="headerlink" title="6.1.2 最短寻道时间优先 SSTF"></a>6.1.2 最短寻道时间优先 SSTF</h3><p>选择处理与当前磁头距离最近的磁道请求，以减少寻道时间</p><h3 id="6-1-3-扫描算法-电梯调度算法-SCAN"><a href="#6-1-3-扫描算法-电梯调度算法-SCAN" class="headerlink" title="6.1.3 扫描算法 电梯调度算法 SCAN"></a>6.1.3 扫描算法 电梯调度算法 SCAN</h3><p>要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到最后一个磁道，再反方向</p><p>（可以联想电梯哦！！）</p><h3 id="6-1-3-循环扫描-C-SCAN"><a href="#6-1-3-循环扫描-C-SCAN" class="headerlink" title="6.1.3  循环扫描 C-SCAN"></a>6.1.3  循环扫描 C-SCAN</h3><p>要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到最后一个磁道，不反方向直接回到最后一个磁道，开始扫描</p><p>（可以联想循环结构哦！第一次for(i&#x3D;0;i&lt;&#x3D;10;i++) ，i从0开始，到10 下次执行还是从0开始）</p><p>SSFT、SCAN、C-SCAN都存在“饿死现象”</p><p>即当一个或多个进程反复请求某个磁道I&#x2F;O，垄断了整个磁盘，其他磁道得不到访问</p><h3 id="6-1-4-N-Step-SCAN"><a href="#6-1-4-N-Step-SCAN" class="headerlink" title="6.1.4 N-Step-SCAN"></a>6.1.4 N-Step-SCAN</h3><p>将磁盘请求队列分成若干个长度为N的子队列</p><p>每一次SCAN处理一个子队列</p><p>磁盘调度将按FCFS算法依次处理这些子队列，而每处理一个子队列时，又是按照SCAN算法，当一个队列处理完后，再处理其他队列。当正在处理某子队列时，如果又出现新的磁盘I&#x2F;O请求，则将其放入其他队列中（这时候，因为不在同一队列里了，所以就不能老是执行一个进程的请求了！！！）</p><h3 id="6-1-5-FSCAN"><a href="#6-1-5-FSCAN" class="headerlink" title="6.1.5 FSCAN"></a>6.1.5 FSCAN</h3><p>使用2个子队列</p><p>当扫描开始时，所有请求都在一个子队列，另一个子队列为空，扫描过程中，所有新到的请求加入另一个子队列中，使得新请求服务延迟老请求处理完后（这样也可以避免饿死现象）</p><h2 id="6-2-其他磁盘I-O性能的改善"><a href="#6-2-其他磁盘I-O性能的改善" class="headerlink" title="6.2 其他磁盘I&#x2F;O性能的改善"></a>6.2 其他磁盘I&#x2F;O性能的改善</h2><p>高速缓存</p><p>合理分配磁盘空间</p><p>把有可能顺序访问的放到一块</p><p>提前读，延迟写，周期性的成簇写回</p><p><strong>例题</strong></p><p>尝试给出一种能够满足下列要求的I&#x2F;O设备管理设计方案：</p><p>1 应用程序在访问设备时候，不需要关心设备的物理特性</p><p>2 应用程序申请使用某类设备时，不需要指定具体的物理设备</p><p>3 应用程序可以通过文件系统访问设备</p><p>设计方案：</p><p>为满足上述要求，可以设计一个综合管理系统，其设计思路如下：</p><p>1 <strong>采用分层的I&#x2F;O软件模型</strong>  多层处理，如用户层，设备驱动程序等待。进行设备抽象，将不同类型的设备进行抽象，屏蔽设备的具体物理特性。通过设备抽象，应用程序可以以统一的方式访问各种设备，而无需关心设备的底层实现。</p><p> 2 <strong>设备分组</strong>：将相同类型的设备进行分组，并为每个设备组分配一个唯一的标识符。应用程序在申请使用某类设备时，只需指定设备组的标识符，而无需指定具体的物理设备。</p><p>3  <strong>权限控制</strong>：设计合适的权限控制机制，确保应用程序只能访问其被授权的设备组和设备文件，以保护系统的安全性和数据的机密性。</p><p>数据结构</p><p>1 用类和结构定义抽象层，包括设备的通用属性，操作方法，事件等</p><p>2 用哈希表或映射存储设备组的标识符和相应的设备类型</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）文件系统</title>
      <link href="/2023/10/19/Computer_system/Os/5%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/19/Computer_system/Os/5%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126205825390.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126205825390.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="文件系统上总览图"></p><h1 id="1-文件系统概述"><a href="#1-文件系统概述" class="headerlink" title="1 文件系统概述"></a>1 文件系统概述</h1><p><strong>为什么引入文件系统</strong></p><p>​长期保存（大量的）数据</p><p>​方便用户使用</p><p>文件是有名字的记录在外存中的一组有逻辑意义的数据项序列</p><p><strong>什么是文件系统</strong></p><p>文件系统是OS中用来管理文件的那一部分软件</p><p><strong>文件系统功能</strong></p><p>统一管理文件的存储空间，实施存储空间的分配与回收<br>实现文件信息的共享，提供文件的保护和保密措施<br>实现文件的按名访问<br>     访问的透明性：用户不关心文件的物理位置和存储结构<br>向用户提供一个方便使用的接口，提供对文件系统操作的命令<br>提供与I&#x2F;O的统一接口</p><p><strong>文件分类：</strong></p><p>Unix系统将文件分为3类:<br>普通文件(regular)：ASCII或二进制文件<br>目录文件(directory)<br>特殊文件：设备文件，管道，套接字（socket），符号链接等</p><h1 id="2-文件的结构与存取方式"><a href="#2-文件的结构与存取方式" class="headerlink" title="2 文件的结构与存取方式"></a>2 文件的结构与存取方式</h1><p>文件是存在磁盘上的</p><h2 id="2-1-磁盘"><a href="#2-1-磁盘" class="headerlink" title="2.1 磁盘"></a>2.1 磁盘</h2><p>磁盘有扇片  磁道 扇区</p><p>扇区——磁盘最小可寻址单元</p><p>簇——存储块，固定数量的扇区</p><ul><li>平均存取时间</li></ul><p>​T&#x3D;平均寻道时间+平均旋转等待时间+数据传输时间（有时候忽略不计）</p><p>​其中</p><p>​平均寻道时间——磁头寻找到指定磁道所需要的平均时间（大约5ms）</p><p>​平均旋转等待时间——指定扇区旋转到磁头下方所需要的平均时间（约4-6ms）</p><ul><li>磁盘响应时间&#x3D;平均存取时间+排队时间+控制器时间</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106203358743.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106203358743.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算例题"></p><p>注意想明白这里的0.5的来源</p><h2 id="2-2-文件的物理结构"><a href="#2-2-文件的物理结构" class="headerlink" title="2.2 文件的物理结构"></a>2.2 文件的物理结构</h2><h3 id="2-2-1-连续结构"><a href="#2-2-1-连续结构" class="headerlink" title="2.2.1 连续结构"></a>2.2.1 连续结构</h3><p>文件的数据存放在若干连续的物理块中</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162832432.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162832432.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连续结构"></p><p><strong>优点：</strong></p><p>简单，只要记住首块的地址和文件长度即可<br> 支持顺序存取和随机存取<br> 顺序存取速度快<br> 所需的磁盘寻道时间最少</p><p><strong>缺点：</strong></p><p>不利于文件的动态增长<br>    若预留空间：浪费，而且预先不知道文件的最大长度<br>    否则需要重新分配和移动<br>不利于文件内容的插入和删除<br>存在外部碎片问题</p><h3 id="2-2-2-链式结构"><a href="#2-2-2-链式结构" class="headerlink" title="2.2.2 链式结构"></a>2.2.2 链式结构</h3><p> 一个文件的数据存放在若干不连续的物理块中，各块之间通过指针连接，<br> 每个物理块指向下一个物理块</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162903188.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162903188.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="链式结构"></p><p><strong>优点</strong></p><p>提高了磁盘空间利用率<br> 不存在外部碎片问题<br> 有利于文件的插入和删除<br> 有利于文件的动态扩充</p><p><strong>缺点：</strong><br>随机存取相当缓慢<br>需要更多的寻道时间<br>链接指针占用一定的空间</p><p>改进变形</p><p>FAT表</p><p>文件分配表FAT的一种实现：<br>磁盘的每个分区包含一个FAT，分区中的每个盘块在其中占有1项（以块号为索引），指出文件中下一块的块号。<br>在目录项中包含文件首块的块号。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106204009176.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106204009176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="FAT表图示"></p><h3 id="2-2-3-索引结构"><a href="#2-2-3-索引结构" class="headerlink" title="2.2.3 索引结构"></a>2.2.3 索引结构</h3><p>一个文件的数据存放在若干不连续的物理块中，系统为每个文件建立一个专用数据结构–索引表。<br>索引表存放逻辑块号与物理块号的对应关系<br>一个索引表就是磁盘块地址（块号）数组，其中第i个条目存放的是逻辑块号i对应的物理块号<br>文件目录的目录项中指出索引表的物理地址</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162943439.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162943439.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="索引结构"></p><p><strong>优点</strong>：保持了链接结构的优点，又避免了其缺点<br> 既能顺序存取，又能随机存取<br> 能满足文件动态增长、插入、删除的要求<br> 能充分利用外存空间<br><strong>缺点</strong>：<br>索引表本身带来了系统开销</p><p>UNIX文件系统采用的是多级混合索引结构。<br>每个文件的索引表为13个索引项<br>最前面10项直接登记存放文件数据的物理块号（直接寻址）<br>如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址<br>UNIX中采用了三级索引结构后，文件最大可达16M个物理块</p><p>索引表的组织方式</p><p>如果文件很大，索引表较大，超过了一个物理块，就必须考虑索引表的组织方式，即怎么去存储索引表</p><p>索引表的组织方式:<br>（1）连续方式<br>    索引表占用多个连续的盘块<br>（2）链接方式<br>    索引表按照链式结构组织，占用多个不连续的盘块<br>（3）多级索引（多重索引）<br>  例如，二级索引：将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中<br>  此外，还有三级索引等。</p><p>题目</p><p>设每个盘块4kB，每个盘块号4B，则采用3次间址可表示的文件最大长度为 [4T] B。</p><h2 id="2-3-文件的存取方式"><a href="#2-3-文件的存取方式" class="headerlink" title="2.3 文件的存取方式"></a>2.3 文件的存取方式</h2><p>主要有顺序存取和随机存取两种。<br>1 顺序存取<br>  对文件中的数据按逻辑顺序进行读&#x2F;写的存取方式<br> 2 随机存取<br>  对文件中的数据按任意顺序进行读&#x2F;写的存取方式<br> 3 按键（key）存取：如DBMS</p><p>还与介质有关</p><h1 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3 文件目录"></a>3 文件目录</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>几个基本的概念</p><p><strong>1 文件控制块</strong></p><p>文件控制块是操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有相关信息（文件属性）</p><p>基本信息：文件的名字、地址（起始物理块号）、长度、结构（逻辑结构、物理结构）、类型<br>存取控制信息：文件属主（owner）、存取权限或口令<br>使用信息：共享计数，文件的建立、修改日期等</p><p><strong>2 文件目录</strong></p><p> 把所有的FCB组织在一起，就构成了文件目录<br>  即文件控制块的有序集合</p><p><strong>3  目录项</strong><br>  构成文件目录的项目（目录项就是FCB）</p><p><strong>4 目录文件</strong></p><p>为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，<br> 这个文件就叫目录文件<br> 目录主要是为了系统快速实现“按名访问”而引入的，<br> 查目录是文件系统最频繁的操作，因此目录的合理组织很重要</p><h2 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h2><h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>为所有文件建立一个目录文件（组成一线性表）<br>优点：简单，易实现</p><p>缺点：<br> 限制了用户对文件的命名（容易出现“命名冲突”）<br> 顺序检索文件时，平均检索时间长<br> 不利于对文件的共享</p><h3 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h3><p>对二级目录简单扩充可得三级或三级以上的多级目录结构，<br>即允许每一级目录中的FCB要么指向文件，要么指向下一级子目录。<br>这是当今主流OS普遍采用的目录结构<br>优点：<br>    层次结构清晰，便于管理和保护；有利于文件分类；<br>    能较好地避免重名问题；提高了文件检索速度；有利于访问权限的控制</p><h2 id="3-3-文件目录检索"><a href="#3-3-文件目录检索" class="headerlink" title="3.3 文件目录检索"></a>3.3 文件目录检索</h2><p>访问文件时，必须首先确定<strong>读写文件的地址</strong>，需要下列2步：<br>（1）目录检索：根据文件名，查目录，确定文件的起始地址。<br>（2）文件寻址：确定所要访问文件内容的起始位置（地址）。</p><h3 id="3-3-1-目录检索"><a href="#3-3-1-目录检索" class="headerlink" title="3.3.1 目录检索"></a>3.3.1 目录检索</h3><p>文件的“按名存取”是通过查目录实现的，系统按照文件的路径名检索<br>基本的目录检索技术主要有：<br>线性检索法<br>Hash方法<br>为了加快目录检索，许多系统引入当前目录（工作目录）、相对路径名等。</p><h3 id="文件寻址"><a href="#文件寻址" class="headerlink" title="文件寻址"></a>文件寻址</h3><p>根据目录项（FCB）中记录的文件物理地址等信息，<br>求出文件的任意记录或字节在存取介质上的地址<br>文件寻址与文件的物理结构和逻辑结构以及设备的物理特性有关<br>文件的内容是以块为单位存储的。<br>但存取文件时，对于记录式文件，是以逻辑记录为单位提出存取要求的，因此，<br>存储介质上的物理块长度与逻辑记录的长度是否匹配直接影响到对文件的寻址</p><h2 id="3-4-文件目录的实现"><a href="#3-4-文件目录的实现" class="headerlink" title="3.4 文件目录的实现"></a>3.4 文件目录的实现</h2><p>当查找文件时候，需要依次将存放目录的物理块装入内存，逐一比较文件名，直到找到为止</p><p>例如：文件说明占128B，每块512B，则每块可存放4个目录项</p><p>设目录文件占用的盘块数是N个，则要找到一个目录项，<br>平均需要读入多少个盘块？(N+1)&#x2F;2块</p><p>把文件说明信息（FCB）都放在目录项中的缺点：<br>  查找文件缓慢，因为目录项较大<br>  文件目录平常放在外存中，当文件很多时，可能占用大量的外存物理块</p><p>但实际上我们文件检索只需要文件名，不需要那么多其他的信息</p><p>所以我们将文件说明分成两部分   把FCB分成两部分</p><p>1 符号目录项——包括文件名，文件号</p><p>2 基本目录项——除文件名以外的所有信息</p><p>目录项分解法的典型实现</p><p>1 符号文件目录+基本文件目录</p><p>2 目录项 +I 节点</p><p>Unix&#x2F;Linux采用此方法，它把符号目录项称为目录项，而把基本目录项称为I节点（Index node，索引节点），这样，目录项中的文件号就是I节点号。</p><p>举例一个查找过程</p><p>一个文件存在根目录下的wang目录下，若获得这个文件的I结点号，需要读几个磁盘物理块</p><p>注意 I节点只存储当前目录或者文件的信息！！！</p><p>I节点存的物理块号（如果是目录的话，就是目录项的地址，如果是文件的话，则是文件的首地址）！！！</p><p>首先根据根目录的I节点号以及内存中的I节点与物理块号的对应关系，可以知道根目录I节点的地址，去读这个地址的内容（第一次读物理块读取），即是获得了根目录的目录项的地址，去读根目录的目录项（第二次物理块读取）可以知道wang对应的I节点物理地址，读wang的I节点地址内容（第三次读取）可以知道wang的目录项地址，读wang目录项地址就可以获得文件a.c的I节点号（第四次读取）</p><p>如果是索引的话 获得的地址不是物理块地址，而是索引表地址，所以需要每一个获取地址都增加一次，总共六次</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210111722.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210111722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231126210111722"></p><h1 id="4-空闲存储空间的管理"><a href="#4-空闲存储空间的管理" class="headerlink" title="4 空闲存储空间的管理"></a>4 空闲存储空间的管理</h1><h2 id="4-1-空闲区表"><a href="#4-1-空闲区表" class="headerlink" title="4.1 空闲区表"></a>4.1 空闲区表</h2><p>将所有空闲区记录在一个表中。<br>    适合连续文件的外存分配与回收。如今很少用</p><h2 id="4-2-空闲块链"><a href="#4-2-空闲块链" class="headerlink" title="4.2 空闲块链"></a>4.2 空闲块链</h2><p>把所有空闲块链成一个链，适合离散分配</p><p>扩展：<br>①不断地适度增加块大小<br>    从最早的512B 1KB  2KB  4KB  8KB  16KB  32KB  64KB。<br>②成组链接法<br>  链上每个节点记录1组空闲块。适合大型文件系统，分配、释放快，<br>  链占用空间少（除首组外均隐藏在空闲块中）。UNIX用之</p><p>成组连接法</p><h2 id="4-3-位图"><a href="#4-3-位图" class="headerlink" title="4.3 位图"></a>4.3 位图</h2><p>用一串二进制位反映磁盘空间的分配情况，每个物理块对应1位，已分配的物理块为1，否则为0<br>申请物理块时，可以在位图中查找为0的位，返回对应的物理块号<br>归还时，将对应位设置为0<br>描述能力强，适合各种物理结构</p><h1 id="5-文件的使用"><a href="#5-文件的使用" class="headerlink" title="5 文件的使用"></a>5 文件的使用</h1><p>为方便用户使用文件，文件系统提供对文件的各种操作，<br>使用的形式包括系统调用或命令<br> ① 提供设置和修改用户对文件访问权限的操作<br> ② 提供建立、修改、删除目录的操作<br> ③ 提供文件共享、设置访问路径的操作<br> ④ 提供创建、打开、读、写、关闭、删除文件等操作<br>其中，最基本的操作是：打开、关闭、读、写文件等</p><p>为什么要 打开&#x2F;关闭文件呢</p><p>open：把文件说明信息（FCB）装入内存，便于以后的快速访问。<br>（1）根据指定的文件路径名，查目录，找到相应文件的目录项，检查权限；<br>（2）将文件说明信息装入内存；<br>（3）分配一个文件id（整数）。后面通过该id实施对该文件的操作。</p><p>close：<br> （1）释放文件说明信息所占的内存空间；<br> （2）把文件缓冲区中已修改的内容写回文件。<br> 很多系统限制进程打开文件的个数，用户尽可能要关闭不再使用的文件。</p><p>打开文件会在内存建立文件的描述信息，记录文件的当前指针，有助于提高文件的访问速度与灵活性。</p><p>关闭会释放文件缓冲区，将已修改的内容写盘，释放文件描述信息所占的内存空间。若不关闭文件，则内存空间被浪费，甚至可能会使修改的内容丢失。</p><h1 id="6-文件共享"><a href="#6-文件共享" class="headerlink" title="6 文件共享"></a>6 文件共享</h1><p>文件共享：一个文件被多个用户或进程使用<br>共享的目的：<br>节省时间和存储空间，减少用户工作量<br>进程间通过文件交换信息</p><h2 id="6-1-普通的文件共享方法"><a href="#6-1-普通的文件共享方法" class="headerlink" title="6.1 普通的文件共享方法"></a>6.1 普通的文件共享方法</h2><h3 id="6-1-1-按路径名访问共享文件"><a href="#6-1-1-按路径名访问共享文件" class="headerlink" title="6.1.1 按路径名访问共享文件"></a>6.1.1 按路径名访问共享文件</h3><p>  实现简单，不需要建立另外的目录项<br>  但路径名可能长，检索较慢</p><h3 id="6-1-2-链接法"><a href="#6-1-2-链接法" class="headerlink" title="6.1.2 链接法"></a>6.1.2 链接法</h3><p>在相应目录项之间建立链接。即一个目录项中含有指向另一个目录项的指针。<br> 实现方法：<br>  在目录项中设置一个“链接属性”，<br>  表示目录项中的“物理地址”是指向另一目录项的指针。<br>  同时，在共享文件的目录项中包含“用户计数”。</p><h3 id="6-1-3-基本文件目录BFD"><a href="#6-1-3-基本文件目录BFD" class="headerlink" title="6.1.3 基本文件目录BFD"></a>6.1.3 基本文件目录BFD</h3><p>整个文件系统有1个基本文件目录BFD：<br>    每个文件（及目录）有1个目录项，包含系统赋予的唯一标识符ID（整数）<br>    以及其他的文件说明信息<br>每个目录有1个符号文件目录SFD：除了ID &#x3D; 0，1，2外,<br>     每个目录项仅包含文件名和ID<br>系统把ID &#x3D; 0，1，2的目录项分别作为BFD、FFD、MFD的标识符<br>共享方法：<br>     若一个用户想共享另一用户的文件，只需在自己的目录文件中增加一个目录项，填上自己起的文件名和该共享文件的唯一ID即可。如ID &#x3D; 6的文件。  </p><h2 id="6-2-基于I节点的文件共享方法（Unix采用）"><a href="#6-2-基于I节点的文件共享方法（Unix采用）" class="headerlink" title="6.2 基于I节点的文件共享方法（Unix采用）"></a>6.2 基于I节点的文件共享方法（Unix采用）</h2><h3 id="6-2-1-硬链接"><a href="#6-2-1-硬链接" class="headerlink" title="6.2.1 硬链接"></a>6.2.1 硬链接</h3><h3 id="6-2-3-符号链接"><a href="#6-2-3-符号链接" class="headerlink" title="6.2.3 符号链接"></a>6.2.3 符号链接</h3><p>在Windows中叫做 快捷方式</p><h1 id="7-文件保护"><a href="#7-文件保护" class="headerlink" title="7 文件保护"></a>7 文件保护</h1><p>主要涉及文件存取控制</p><ol><li><p>存取控制矩阵<br> 给出每个用户对每个文件的访问权限。<br> 一维是所有用户，另一维是所有文件，<br> 对应的矩阵元素是用户对文件的访问权限。<br> 例如，访问操作分为：<br> 读操作（r）<br> 写操作（w）<br> 执行操作（x）<br> 不能执行任何操作（-）<br> 当用户和文件较多时，很庞大。</p></li><li><p>存取控制表（Access Control List，ACL）<br> 每个文件一张ACL，将用户分类，规定每类用户的访问权限。<br> 例如，Unix&#x2F;Linux将用户分类为：<br> 文件主（owner）<br> 文件主的同组用户（group）<br> 其他用户（other）</p></li><li><p>存取权限表（Capability List，CL）<br> 每个用户一张CL，规定对每个文件的访问权限。</p></li><li><p>口令<br> 用户创建文件时，设置一个口令，放在文件目录中。</p></li><li><p>密码<br> 写入时加密，读出时解密。</p></li></ol><p>假定两个用户共享一个文件系统，用户A有文件a，b，e，f ，用户B有文件c，d，e，f。用户A的b和用户B的d是同一个文件。用户A的e和用户B的e不是同一个文件，用户A的f和用户B的f是同一个文件。拟定一个文件组织方案，使得A，B两个用户能够共享该文件系统而不会造成混乱</p><p>答</p><p>为了确保用户A和用户B能够共享文件系统而不会造成混乱，可以采用以下文件组织方案：</p><ol><li><strong>首先创建两个用户目录</strong>：为每个用户创建一个独立的目录，目录A和目录B。这样，用户A和用户B的文件可以分别存储在各自的目录中，避免混淆，对于用户A的e和用户B的e不是同一个文件，则可以将它们分别存放在各自的目录中，因为它们不需要共享</li><li><strong>共享文件存放目录</strong>：对于文件f，创建一个共享文件存放目录，这确保了用户A和用户B可以共同访问和修改这些共享文件。</li><li><strong>建立符号链接</strong>：对于用户A的b和用户B的d是同一个文件，则可以在用户A的目录中创建一个符号链接，指向用户B的文件d。这样，用户A可以访问和操作这个文件，同时避免重复存储。</li></ol><p>通过以上的文件组织方案，用户A和用户B可以共享文件系统，各自管理自己的文件，并且能够访问和修改共享文件，同时避免重名文件和混淆。这样可以确保文件系统的整体有序性和可维护性。</p><p>已知某文件系统采用多级目录结构，逻辑块和物理块大小均为1KB，目录当做文件，采用目录项+I结点的方式。假定要读取文件&#x2F;a&#x2F;b&#x2F;c.dat的第10600-10900个字节，针对连续结构，基本链式结构，FAT和单级索引结构这四种情况，回答下列问题</p><p>1 给出读盘过程</p><p>2 给出读盘次数（如果有必要，可以对本题未给出的条件做出合理假设）</p><ol><li>读盘过程：</li></ol><ul><li><p>连续结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到其起始逻辑块号。然后根据逻辑块号和文件系统的块映射关系，直接读取对应的物理块</p></li><li><p>基本链式结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，逐级跳转到链式结构中的下一个块，直到找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li><li><p>FAT（文件分配表）结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，根据FAT表的信息，依次读取块链中的物理块，直到找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li><li><p>单级索引结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，根据单级索引指向的块，再根据块内的索引信息找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li></ul><ol start="2"><li>读盘次数：</li></ol><ul><li><p>连续结构：只需进行一次读取，因为连续结构中的数据是连续存储的。</p></li><li><p>基本链式结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要跳转到下一个块。</p></li><li><p>FAT结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要根据FAT表的信息找到下一个块。</p></li><li><p>单级索引结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要根据索引结构中的信息找到下一个块。</p></li></ul><p>需要注意的是，以上的读盘次数可能还会受到文件系统的缓存策略等因素的影响，这里只是基于给出的情况做出的合理估计。</p><p>为某一个应用场景设计一个文件系统，所设计的文件系统不能建立在已有的文件系统的基础上。具体要求如下：</p><p>1 举一个应用场景的例子，说明该场景下对文件系统的具体需求</p><p>2 针对具体需求给出一种文件系统的设计方案</p><p>3 对你的设计方案进行评价</p><ol><li><p>应用场景示例：智慧农业控制嵌入式系统。在智慧农业系统中，用户可以通过手机或者智能音箱等设备来控制农场中的各种设备，如灯光、温度、安防等。在这个场景中，文件系统被用于存储和管理各类设备的配置文件、日志文件等数据。</p></li><li><p>文件系统设计方案：</p></li></ol><p>考虑到智慧农业控制嵌入式系统的特点和需求，可以设计一种轻量级的文件系统，具备以下特点：</p><ul><li><strong>简单快速</strong>: 提供简洁的操作界面和易于理解的文件组织方式，方便用户进行文件的存储、查找和管理。优化文件系统的读写性能，以满足实时控制的需求。采用文件缓存、文件索引等技术来提升文件读写效率。</li><li><strong>可靠性</strong>: 采用数据冗余和文件系统日志等机制来保证数据的完整性和可靠性，防止数据丢失或损坏。</li><li><strong>安全性</strong>: 对于敏感信息，采用加密算法进行数据保护，防止数据泄露和非法访问。</li><li><strong>灵活扩展</strong>: 设计分级的结构设计，以便未来能够支持新的设备类型、新的功能和协议。</li></ul><ol start="3"><li>设计方案评价：</li></ol><p>该设计方案针对智慧农业控制嵌入式系统的需求进行了考虑，并且具备一定的可行性和可实现性。然而，对于一个完整的文件系统来说，还需要更多的细节和技术实现方面的考虑，如并发访问的处理、容错和恢复机制等。此外，还需要考虑与其他系统组件的协同工作，以确保整个智慧农业控制嵌入式系统的稳定运行和良好的用户体验</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）内存管理</title>
      <link href="/2023/10/18/Computer_system/Os/4%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/18/Computer_system/Os/4%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202354730.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202354730.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="内存管理总览图"></p><h1 id="1-内存管理概述"><a href="#1-内存管理概述" class="headerlink" title="1 内存管理概述"></a>1 内存管理概述</h1><p>内存是存储系统的一部分</p><p>存储系统核心目的是存储要运行的程序数据之类的</p><p>存储系统的设计目标可以归纳为3个问题</p><p>容量，速度，和成本之间的矛盾：</p><p>​三个目标不可能同时达到最优，要权衡利弊</p><p>​存取速度越快，每一位价格越高</p><p>​大容量就要降低速度</p><p>​高速度就要降低容量</p><p>解决方案：采用层次化的存储体系</p><p>换句话说 靠近CPU的，我们把他的存取速度加大，同时他的成本就会增加，容量就会减少</p><p>寄存器（CPU内）-》高速缓冲（Cache）-》内存-》磁盘-》磁带</p><p>从左到右，存取速度下降，存取容量增大</p><h2 id="1-1-内存管理目的"><a href="#1-1-内存管理目的" class="headerlink" title="1.1 内存管理目的"></a>1.1 内存管理目的</h2><p>​有效利用内存空间</p><p>​应用程序不必特别考虑内存的大小</p><p>​可以大于内存</p><h2 id="1-2-内存管理功能"><a href="#1-2-内存管理功能" class="headerlink" title="1.2 内存管理功能"></a>1.2 内存管理功能</h2><p>​记录内存的使用情况</p><p>​进程所占内存空间的分配与回收</p><p>​当内存不足时，采取相应措施</p><p>​内存空间的共享与保护</p><h1 id="2-程序的连接和装入"><a href="#2-程序的连接和装入" class="headerlink" title="2 程序的连接和装入"></a>2 程序的连接和装入</h1><h2 id="2-1-程序的连接"><a href="#2-1-程序的连接" class="headerlink" title="2.1 程序的连接"></a>2.1 程序的连接</h2><h3 id="2-1-1程序的连接的功能"><a href="#2-1-1程序的连接的功能" class="headerlink" title="2.1.1程序的连接的功能"></a>2.1.1程序的连接的功能</h3><p>多个目标文件及库文件连接成1个完整的可执行文件。</p><h3 id="2-1-2-程序连接的时机"><a href="#2-1-2-程序连接的时机" class="headerlink" title="2.1.2 程序连接的时机"></a>2.1.2 程序连接的时机</h3><p>静态连接：静态的，只连接1次，多次运行<br> 装入时连接：装入后是静态的<br> 实际运行时连接：调用时动态连接</p><h2 id="2-2-程序的装入"><a href="#2-2-程序的装入" class="headerlink" title="2.2 程序的装入"></a>2.2 程序的装入</h2><p>每个程序运行前，必须装入内存(为什么？这样存取速度才能匹配上CPU的速度)不一定一次性全部装入</p><p>装入方式有</p><h3 id="2-1-1-完全静态装入"><a href="#2-1-1-完全静态装入" class="headerlink" title="2.1.1 完全静态装入"></a>2.1.1 完全静态装入</h3><p>程序装入时不作任何修改。<br>即装入内存的每个字节与其可执行文件完全相同。</p><h3 id="2-1-2-静态重定位装入"><a href="#2-1-2-静态重定位装入" class="headerlink" title="2.1.2 静态重定位装入"></a>2.1.2 静态重定位装入</h3><p>程序装入时进行一次地址重定位，运行时不变。</p><p><strong>重定位</strong>是把汇编中的相对地址转换为内存中的实际地址</p><p><strong>相对地址:</strong><br>用户的程序经过汇编或编译连接后形成可执行代码，代码通常采用相对地址的形式，其首地址为0，指令中的地址都采用相对于首地址的偏移量。<br>机器是不能用相对地址在内存中读取信息的，必须用绝对地址<br><strong>绝对地址:</strong><br>内存中存储单元的实际地址</p><h3 id="2-1-3-动态重定位装入"><a href="#2-1-3-动态重定位装入" class="headerlink" title="2.1.3 动态重定位装入"></a>2.1.3 动态重定位装入</h3><p>真正<strong>执行到一条指令</strong>要访问某个内存地址时，才进行地址重定位。</p><p>一般设置1个重定位寄存器 存放当前进程在内存的起始地址<br> 绝对地址 &#x3D; 相对地址 + 重定位寄存器的值</p><h1 id="3-实存储器管理"><a href="#3-实存储器管理" class="headerlink" title="3 实存储器管理"></a>3 实存储器管理</h1><p>程序的大小不能超过可用内存空间的大小</p><p> 实实在在的 给我装进去哈哈哈</p><h2 id="3-1-连续分配"><a href="#3-1-连续分配" class="headerlink" title="3.1 连续分配"></a>3.1 连续分配</h2><p> 为每个进程分配连续的内存空间</p><h3 id="3-1-1-单一连续分配"><a href="#3-1-1-单一连续分配" class="headerlink" title="3.1.1 单一连续分配"></a>3.1.1 单一连续分配</h3><p>一般将内存划分为2个区：<br>     系统区：存放OS程序和数据<br>     用户区：存放用户程序和数据</p><p>如果是单一连续分配</p><p>内存中只存在1个用户程序。<br>     整个用户区为该程序独占！</p><p><strong>缺点：</strong></p><p>只能用于单用户、单任务OS。所以在现代操作系统肯定是不行的</p><h3 id="3-1-2-固定静态分区"><a href="#3-1-2-固定静态分区" class="headerlink" title="3.1.2 固定静态分区"></a>3.1.2 固定静态分区</h3><p>刚刚讲到的单一连续分配为什么不能多用户，多程序呢？</p><p>因为没有划分区域，不知道哪个用户或哪个程序该用哪一块内存</p><p><strong>改进</strong></p><p>所以固定分区进行划分区域操作</p><p>将内存的用户区预先划分为若干区域（分区）<br>分区个数和每个分区的大小是固定的<br>每个分区存放1个进程</p><p><strong>管理所需要的数据结构</strong></p><p>1个分区使用表（内存分配表），记录分区状态（比如区号id，分区大小，起始地址，状态是否被使用）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223356489.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223356489.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="管理所需的数据结构"></p><p><strong>缺点：</strong></p><p>(1) 当进程大小大于划分区域的时候，无法装入，<br>(2) 当进程大小小于划分区域的时候，存在内部碎片(Internal fragmentation)意味着会有内存资源的浪费<br>(3) 分区数目固定，使活动进程数目受限，比如划分十个区域，那么最多就是十个进程</p><p>所以也是不行的</p><h3 id="3-1-3-可变动态分区"><a href="#3-1-3-可变动态分区" class="headerlink" title="3.1.3 可变动态分区"></a>3.1.3 可变动态分区</h3><p>刚刚讲到的固定静态分区很差劲哦</p><p>原因在于很多东西都是固定的，比如分区数目，比如分区大小。</p><p>那么既然如此，我们就可以让他们“动”起来！</p><p><strong>改进</strong></p><p>动态分区<br>开始时只有1个空闲分区，随着进程的装入和退出，分区的个数和每个分区的大小、位置会动态变化，既然如此我们需要一些数据结构进行记录</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223501062.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223501062.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="动态分区图示"></p><p><strong>需要的记录的数据结构</strong></p><p>1 空闲分区表  记录开始地址，长度，以及状态（是否分配）</p><p>2 已分配分区表   记录开始地址，长度，以及进程号</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223740827.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223740827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据结构"></p><p>动态分区有一个核心就是怎么去分配分区，所以有着一系列的分区分配算法</p><p><strong>分区分配算法</strong></p><p>① 最先适配法（first fit）<br>    空闲分区链（表）按地址递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><p>② 下次适配法（next fit）<br>    从上次分配的分区的下一个开始，选择第1个大小足够的分区</p><p>③ 最佳适配法（best fit）<br>    空闲分区链（表）按大小递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><p>④ 最差适配法（worst fit）<br>    空闲分区链（表）按大小递减的次序排列<br>    从头开始，选择第1个分区（如果足够大）</p><p>后两种方法利用率更高，但是需要排序，开销会更大</p><p>分区给不同 进程分配出去了，当进程执行结束后，还需要将该进程的所在分区释放回收，这时候可能会产生一些碎片（因为没有比这些碎片小的进程放入的时候就会产生这些碎片</p><p>如何解决</p><p>1 内存紧凑（compaction）：集中小碎片为大分区</p><p> 但是涉及到程序在内存中的移动，开销很大</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115224359347.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115224359347.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="紧凑"></p><p>2 根本上是因为 我们上述讨论的一直都是连续分配，所以我们可以从根本上解决，提出离散分配，也就是下一章的重点！</p><h2 id="3-2-离散分配"><a href="#3-2-离散分配" class="headerlink" title="3.2 离散分配"></a>3.2 离散分配</h2><p>刚刚3.1我们讲到连续分配导致很多的碎片，所以我们可以进行离散分配，首先进程可以分为不同部分装入内存的不同分区</p><p>典型的离散分配方式，分页管理，分段管理</p><h3 id="3-2-1-分页管理"><a href="#3-2-1-分页管理" class="headerlink" title="3.2.1 分页管理"></a>3.2.1 分页管理</h3><p>（1）等分内存为物理块（或称页面，页框，page frame）<br>         物理块编号为0，1，2，．．．。<br>（2）进程的逻辑地址空间分为不同的页（page）<br>         页大小 &#x3D; 物理块大小<br>         页编号为0，1，2，．．．。<br>（3）内存分配原则：<br>         进程的1页可装入任一物理块</p><p>这里我们注意一下和固定分区的区别，固定分区一下子只能装入一整个程序（整个程序在内存中是连续的），而分页操作可以使得一个进程不同部分离散的存储在内存的不同位置！</p><p><strong>问题</strong></p><p>进程的最后1页可能装不满，产生“页内碎片”。</p><p><strong>管理的数据结构</strong></p><p>OS为每个进程建立1个页表（Page Table）<br>记录进程的页号和物理块号的对应关系</p><p><img src="/img/OS/image-20231115225502679.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231115225502679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231115225502679"></p><p><strong>地址转换</strong></p><p>逻辑地址 → 物理地址</p><p>我们给程序分页的时候 0，1,2,3 实际上是逻辑地址或者叫相对地址，只知道这个我们肯定不知道程序在内存中的哪里，所以我们还需要通过上图的页表转换为实际的物理地址</p><p>所以对于一个程序而言，我们要找到页表，那么我们怎么找到一个程序的页表呢？</p><p>通过<strong>页表寄存器</strong> 存放当前进程的页表起始地址和长度  每个进程的页表起始地址和长度平时放在其PCB（进程管理模块）中，调度时由OS放入PTR</p><p>注意的几点问题</p><p>（1）在这个过程中，需要选择页的大小</p><p>页小：碎片小，但页表占用空间大（因为页的数量会很多）</p><p>页大：页表小，但页内碎片大<br>通常，页的大小为2的整数次幂</p><p>所以需要对两者进行权衡</p><p>假设我们页大小为1KB&#x3D;1024B（$2^{10}&#x3D;1024$）则需要10位页内地址，假设逻辑地址是16位，第0-9位是页内地址，10-15位是页号</p><p>（2）进程的逻辑地址结构 ——及地址转换<br>   地址的高位部分为页号，低位部分为页内地址</p><p><img src="/img/OS/image-20231115230855467.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231115230855467.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231115230855467"></p><p>物理地址 &#x3D; 块号×页大小 + 页内地址</p><p>（3）引入快表</p><p>快表，又称联想存储器(Associative Memory) ： 具有并行查找能力的特殊高速缓存（cache）。<br>用途：保存当前进程的页表的子集（部分表项），比如最近访问过的页表项。<br> 当切换到新进程时，快表要刷新。</p><p>目的：提高地址转换速度</p><p>思考一个问题，加深我们对于该部分的理解</p><p>1  CPU要存取一个数据时，需要访问内存几次？</p><p>2次。<br> 第1次：访问页表，找到该页号P对应的物理块号，将此块号×页大小 与页内地址拼接形成物理地址；<br> 第2次：访问该物理地址，存取其中的指令或数据。</p><p>假设逻辑地址中，页号占20位，页内地址12位，则总共有$2^{20}$个页1M个页，如果每个页表项4B，光页表就占用4MB的空间</p><p>因而 页表本身可能占用相当大的内存空间，而且是连续的。</p><p>如何解决？</p><p>采用二级页表(只能解决连续，但解决不了占用较大的内存)</p><p>将页表进行分页，页大小 &#x3D; 物理块大小<br>  设置1个一级页表，多个二级页表<br>   一级页表：第i项记录第i号二级页表所在的物理块号<br>  二级页表：第i项记录第i页对应的物理块号<br>  系统设置１个页表寄存器，存放一级页表的起始地址和长度</p><p>二级页表并未减少页表所占的内存空间，但解决了页表的离散分配问题</p><h3 id="3-2-2-分段管理"><a href="#3-2-2-分段管理" class="headerlink" title="3.2.2 分段管理"></a>3.2.2 分段管理</h3><p>静态段式管理</p><p>按程序的逻辑划分为若干个程序段，每一个段连续，且各个段的长度不要求相等</p><p>段号从0开始</p><p>分段类似于可变分区，但不同之处在于：<br>       一个进程可占据多个分区，而且分区之间不要求连续<br>分段无内部碎片，但有外部碎片。</p><p>（2）内存分配原则</p><p>以段为单位，各段不要求相邻</p><p>我们刚刚讲到的分页管理类似于固定分区，现在的分段管理则类似于可变分区，不同之处在于分区之间不要求连续。</p><p><strong>管理需要的数据结构</strong></p><p>OS为每个进程建立1个段表（Segment Table）<br>每个段在段表中有1项，记录该段在内存中的基址和长度</p><p><img src="/img/OS/image-20231116093449579.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231116093449579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231116093449579"></p><p>分段分页比较</p><p>（1）分页对程序员是不可见的；分段通常是可见的，并作为组织程序和数据的手段提供给程序员；<br>（2）页的大小由系统确定，段的大小由用户程序确定；<br>（3）分段更利于多个进程共享程序和数据；<br>（4）分段便于实现动态链接;<br>（5）分页可有效提高内存利用率，分段可更好地满足用户需要。</p><h3 id="3-2-3-分页分段管理"><a href="#3-2-3-分页分段管理" class="headerlink" title="3.2.3 分页分段管理"></a>3.2.3 分页分段管理</h3><p> 动机：结合分段和分页的优点，克服二者的缺点。</p><p>进程分段——同段式管理<br>每段分页，内存分块，内存以块为单位分配——同页式管理</p><p>进程的逻辑地址结构</p><p>由段号、页号和页内地址构成</p><p><strong>管理需要的数据结构</strong></p><p>每个进程有一个段表</p><p>记录每个段对应的页表的起始地址和长度</p><p>每个段有一个页表</p><p>记录该段所有页号与物理块的关系</p><p>CPU要存取一个数据时，需要访问3次内存。</p><p>第1次：访问段表，获得该段的页表地址；<br>第2次：访问页表，取得物理块号，形成物理地址；<br>第3次：访问该物理地址，存取其中的指令或数据。</p><p>实存储管理模式下，怎么提高运行程序的大小</p><p><strong>覆盖</strong></p><p>把程序划分为若干个功能上相对独立的程序段（称为覆盖块），按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域；</p><p>覆盖块存放在磁盘上，当一个程序段执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）</p><p>   (1)  要求程序员划分程序，提供一个明确的覆盖结构；<br>   (2) 增加了编程的复杂度。<br>   (3) 增加执行时间，从外存装入覆盖模块，时间换空间<br>    对用户不透明，增加了用户负担。</p><p>所以更好的方式是虚拟存储管理</p><h1 id="4-虚拟存储管理"><a href="#4-虚拟存储管理" class="headerlink" title="4 虚拟存储管理"></a>4 虚拟存储管理</h1><p>进程的大小可以超过可用物理内存的大小，<br>由OS把当前用到的那部分留在内存，其余的放在外存中。</p><p>几个概念</p><p> 虚拟地址：程序中使用的地址。进程的虚拟地址从0开始。<br> 物理地址：可寻址的内存实际地址<br> 虚拟地址空间：虚拟地址的集合<br> 物理地址空间：实际的内存空间</p><p>交换技术</p><p>将当前要使用的那部分程序或数据装入内存，将暂时不用的放在磁盘上，待需要时再装入。</p><p>交换是虚拟存储器设计的基础，最初的交换是针对整个进程的交换</p><h2 id="4-1-分页-虚拟存储"><a href="#4-1-分页-虚拟存储" class="headerlink" title="4.1 分页+虚拟存储"></a>4.1 分页+虚拟存储</h2><p>在进程开始运行之前，不是装入全部页，而是装入部分或0个页，之后根据进程运行的需要，动态装入其它页；<br>当内存空间已满，而又需要装入新的页时，则根据某种算法淘汰某个页，以便装入新的页。</p><p><img src="/img/OS/image-20231117222116973.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231117222116973.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231117222116973"></p><p>除了页号和物理块号外，需要增加下列字段：</p><p> 有效位（状态）：表示该页是否在内存中<br>1 表示该页位于内存中，该页表项是有效的，可以使用<br>0表示该页当前在外存中，访问该页表项将导致缺页异常</p><p> 修改位M：表示该页在装入内存后是否被修改过<br>在有效位为1的情况下有效的情况下<br>用于回收该物理页面时，据此判断是否要把它的内容写回外存</p><p> 访问位A（访问字段）：记录该页最近是否被访问过<br>用于页面置换算法</p><p>  保护位：表示该页的允许访问方式<br>只读、可读写、可执行等</p><p> 外存地址：该页在磁盘上的地址</p><p>由于访问的页可能不在内存，所以需要</p><p>报告不在内存——缺页中断处理</p><p>将页从外存读入内存——页的换入换出</p><h3 id="4-1-0-缺页中断处理"><a href="#4-1-0-缺页中断处理" class="headerlink" title="4.1.0 缺页中断处理"></a>4.1.0 缺页中断处理</h3><p>1  保护当前进程现场；<br>2  根据页表中给出的外存地址，在外存中找到该页；<br>3  若内存中无空闲物理块，则选择1页换出；<br>4  分配一个空闲物理块，将新调入页装入内存；<br>5  修改页表中相应表项的状态位及相应的物理块号，修改空闲物理块表（链）；<br>6  恢复现场。</p><h3 id="4-1-1-页的换入换出"><a href="#4-1-1-页的换入换出" class="headerlink" title="4.1.1 页的换入换出"></a>4.1.1 页的换入换出</h3><p>页的换入换出涉及到</p><p>如何给进程分配物理块——页的分配策略</p><p>在什么范围内选择淘汰页——页的置换策略</p><p>页该怎么调入——页的调入策略</p><p>该选择哪些页被换出去——页的置换算法</p><p><strong>1）页的分配策略</strong>：为每个进程分配多少个物理块</p><p> 固定分配<br>    为每个进程分配的总物理块数固定，在整个运行期间不变。</p><p>可变分配<br>    先为每个进程分配一定数目的物理块，OS自身维持一个空闲物理块队列。<br>    当发生缺页时，由系统分配一个空闲块，存入调入的页；</p><p><strong>2）页的置换策略</strong>：在什么范围内选择淘汰页<br> 局部置换<br>只从缺页进程自身选择淘汰页<br>全局置换<br>从整个内存中选择淘汰页    当无空闲块时，才会换出。</p><p><strong>3）页的调入策略</strong><br>① 何时调入<br> 请求调页（demand paging）<br>    只有访问的页不在内存中时，才会调入该页。<br> 预调页（prepaging）<br>    一次调入多个连续的页。为什么这样做？<br>② 从何处调入：文件区（可执行文件）、交换区<br> 全部从交换区调入<br>    进程创建时，全部从文件区拷贝到交换区。<br> 首次调入从文件区，以后从交换区</p><p><strong>4）页的置换算法</strong></p><p>选择换出页 减少缺页率</p><ul><li><strong>最优置换算法 OPT</strong></li></ul><p>​淘汰以后永不使用的，或者过最长时间才会被访问的页</p><p>​因为无法预测将来，所以不好实现</p><ul><li><strong>先进先出置换算法 FIFO</strong></li></ul><p>​只需把进程中已调入内存的页，按先后次序链成一个队列即可；链首最长，链尾最短；出现缺页时，选择链首页面进行置换，新页面加到链尾。</p><p>​优点：开销较小，实现简单。<br>​缺点：<br>       ① 它与进程访问内存的动态特性不相适应；有可能调出的页面可能是经常访问的<br>       ② 会产生belady现象。即：当分配给进程的物理块数增加时，有时缺页次数反而增加。</p><ul><li><strong>最近最久未使用算法 LRU</strong></li></ul><p>淘汰最近一次访问距当前时间最长的页。<br>即淘汰未使用时间最长的页<br>关键：如何快速地判断出哪一页是最近最久未使用的。<br>算法较好，但实现代价高。</p><p>实现方法</p><p>方法一：计时器</p><p>​对于每一页增设一个访问时间计时器</p><p>​每当某页被访问时，当时的绝对时钟内容被拷贝到对应的访问时间计时器中，这样系统记录了内存中所有页最后一次被访问的时间。<br>  淘汰时，选取访问时间计时器值最小的页。</p><p>方法二：移位寄存器</p><p>​为内存中的每一页配置一个移位寄存器<br>  当访问某页时，将相应移位寄存器的最高位置1<br>  每隔一定时间，寄存器右移1位<br>  淘汰寄存器值最小的页。</p><p>方法三：栈</p><p>​  每次访问某页时，将其页号移到栈顶。使得栈顶始终是最近被访问的页，<br>  栈底是最近最久未用的。</p><p>以上的最近最久未使用算法核心需要判断最久，开销较大</p><p>所以我们提出一个近似，最近未使用算法NRU</p><ul><li><strong>最近未使用算法 NRU 也叫做CLOCK算法</strong></li></ul><p>实现方法</p><p>页表中设置一个访问位，当访问某页时，将访问位置1<br>将内存中的所有页链成一个循环队列<br>从上次换出页的下一个位置开始扫描<br>在扫描过程中，将访问位&#x3D;1的页清0，直到遇到访问位&#x3D;0的页，淘汰该页，并将指针指向下一页</p><p>改进：</p><p>该算法的提出基于如下考虑：<br>① 对于已修改的页，换出时必须重新写回到磁盘上。因此，优先选择未访问过、未修改过的页换出；<br>② 淘汰一个最近未访问的已修改页要比淘汰一个被频繁访问的“干净”页好。</p><p>所以按照下面的顺序进行淘汰</p><p>第1类：A &#x3D; 0，M &#x3D; 0：未访问，未修改；最佳淘汰页<br>第2类：A &#x3D; 0，M &#x3D; 1：未访问，已修改<br>第3类：A &#x3D; 1，M &#x3D; 0：已访问，未修改；有可能再次访问<br>第4类：A &#x3D; 1，M &#x3D; 1：已访问，已修改</p><p>算法</p><p>① 找第1类页，将遇到的第1个页作为淘汰页；<br>② 若查找1周后未找到第1类页，则寻找第2类页，并将扫描经过的页的访问位清0。将遇到的第1个页作为淘汰页；<br>③ 否则，转①、②，一定能找到淘汰页。</p><ul><li><strong>最少使用算法 LFU</strong></li></ul><p>选择最近访问次数最少得页淘汰</p><p> 通常不直接利用计数器来记录页的访问次数，而是采用移位寄存器R。<br>  类似于LRU算法，每次访问某页时，将其移位寄存器的最高位置1。每隔一定时间将移位寄存器右移1位。</p><p>这样，在最近一段时间内使用次数最少的页就是移位寄存器各位之和最小的页。</p><p>往往配合页缓冲算法，提高LFU的效率</p><p>基本方法 设置两个空闲链表 空闲页链表，已修改页链表</p><p>① 若淘汰页未修改，则直接放入空闲页链表，否则放入已修改页链表；<br>② 当已修改页达到一定数量时，再将其一起写回磁盘，即成簇写回，以减少I&#x2F;O操作的次数。</p><p>缺页率对于虚拟存储来说非常重要</p><p>因为缺页导致的中断处理相对处理时间也比较长</p><p>前面进程没有考虑进程对内存块需求的差异性，有可能给进程多增加一个物理页面，就会导致缺页率大幅度下降</p><p>所以全局置换算法可能效果更好，为进程分配可变数目的物理页面，经典的算法有工作集</p><ul><li>工作集置换算法</li></ul><p>1 基本思想</p><p> 根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页，这些页称为活动页。<br>    如果分配给一个进程的物理块数太少了，使该进程所需的活动页不能全部装入内存，则进程在运行过程中将频繁发生缺页中断。<br>    如果能为进程提供与活动页数相等的物理块数，则可减少缺页中断次数。</p><p> 首先什么是工作集</p><p>一个进程在时刻t、参数为△的工作集W(t, △)，表示该进程在过去的△个时间单位中被访问到的页的集合。△称为工作集的窗口大小。</p><p>工作集大小的三个因素</p><p>   访页序列特性<br>   时刻t<br>   观察该进程的时间窗口大小(△)</p><p>实现方法：</p><p>访存链表：维护窗口内的访存页面链表<br>访存时，换出不在工作集的页面；更新访存链表<br>缺页时，换入页面；更新访存链表</p><h2 id="4-2-分段-虚拟存储"><a href="#4-2-分段-虚拟存储" class="headerlink" title="4.2 分段+虚拟存储"></a>4.2 分段+虚拟存储</h2><p>要比虚拟页式管理复杂一些</p><p>会有缺段中断</p><h2 id="4-3-段页-虚拟存储"><a href="#4-3-段页-虚拟存储" class="headerlink" title="4.3 段页+虚拟存储"></a>4.3 段页+虚拟存储</h2><p>涉及缺段中断、缺页中断。<br>注意的是，对于缺段中断处理，主要是在内存中建立该段的页表，而非调入完整的一段。</p><p>影响缺页次数的因素</p><p>（1）分配给进程的物理块数<br>    一般来说，进程的缺页中断率与进程所占的内存块数成反比。<br>    分配给进程的内存块数太少是导致抖动现象发生的最主要原因。<br>（2）页的大小<br>     缺页中断率与页的大小成反比，但页的大小也不能一味地求大，它一般在0.5KB~4KB之间，是个实验统计值。因为页大时，页表较小，占空间少，查表速度快，缺页中断次数少，但页内碎片较大。页小时，恰恰相反。<br>（3）程序的编写方法<br>    进程的缺页中断率与程序的局部性（包括时间和空间局部性）程度成反比。<br>     用户程序编写的方法不合适可能导致程序运行的时空复杂度高，缺页次数多。<br>（4）页置换算法<br>    算法不合理会引起抖动。</p><p>页式管理</p><p><strong>页</strong></p><p>相对物理块来说，页是逻辑地址空间（<a href="https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">虚拟内存</a>空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB。</p><p>例如：一个 32 位的<strong>操作系统</strong>，页的大小设为 2^12&#x3D;4Kb，那么就有页号从 0 编到 2^20 的那么多页逻辑空间。</p><p>段式管理</p><p>段页式管理</p><p>段页</p><p>虚拟内存</p><p>​让用户感觉像是在分段，但实际上是分页管理</p><p>$命中率h&#x3D;\frac{N_c}{N_c+N_m}$</p><p>其中$N_c$为Cache完成存取的总次数，$Nm$表示主存完成存取的次数</p><p>页框是什么</p><p><strong>高级调度：</strong></p><p>​功能：调度对象是作业。其主要功能是根据某种算法，其选择从就绪队列中选择哪个进程进入内存执行，以便后续的执行。决定从外存中处于后备队列中的哪几个作业调入内存，为创建进程、分配必要的资源。</p><p>​关系：高级调度与中级调度之间的关系是，高级调度将作业从后备队列中选择并将它们加载到内存中，然后中级调度负责将这些作业分配给可运行队列。高级调度与低级调度之间的关系是，它确定了哪些进程将被带入内存，以供后续的执行。</p><p><strong>中级调度：</strong></p><p>又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。</p><p>​功能：中级调度的主要任务是管理内存中的进程。它可以将某些进程从内存中暂时移出，以便为其他进程腾出空间，以减轻内存压力，提高内存利用率和系统吞吐量。</p><p>​关系：中级调度与高级调度之间的关系是，它接受高级调度分配的作业，将它们加载到内存中，并可以在必要时将它们暂时移出内存。中级调度还与低级调度之间有关，因为它可以调整进程的内存分布，以优化系统性能。</p><p><strong>低级调度：</strong></p><p>​功能：低级调度是最频繁的调度级别，其任务是从就绪队列中选择下一个要执行的进程。它控制着CPU的分配，决定哪个进程将在CPU上执行，以确保公平性和性能。</p><p>​关系：低级调度与高级调度之间的关系是，它执行高级调度选择的进程，将其分配给CPU执行。它还与中级调度之间有关，因为中级调度可能会将某些进程暂时移出内存，而低级调度负责在需要时将它们带回内存。</p><p>慢表（Page）：页表、段表存放在主存中，收到虚拟地址后要先访问主存，査询页表、段表，进行虚实<a href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">地址转换</a>。</p><p>快表（TLB）：提高变换速度→用高速缓冲存储器存放常用的页表项（注意不是放在内存的）</p><p>假设某计算机硬件提供了动态重定位寄存器和地址越界检查，现在为计算机涉及一个操作系统的内存管理方案，支持多进程并发执行,且不大于内存空间大小的进程可以装入内存执行</p><p>（1）阐述方案的设计思路</p><p>由于该计算机需要多进程并发执行，所以可以采用可变动态分区的方法进行内存管理，同时计算机只需要装入不大于内存的进程，所以可以采用实存储器管理方案。</p><p>综上所述可以采用 实存储器管理的可变动态分区的方案进行管理</p><p>开始时只有1个空闲分区，随着进程的装入和退出，分区的个数和每个分区的大小、位置会动态变化</p><p>（2）管理所需要的数据结构</p><p>1 空闲分区表  记录开始地址，长度，以及状态（是否分配）</p><p>2 已分配分区表   记录开始地址，长度，以及进程号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">free_list_queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> start_address; <span class="comment">//开始地址</span></span><br><span class="line">        <span class="type">double</span> length; <span class="comment">//长度</span></span><br><span class="line">    <span class="type">double</span>  state; <span class="comment">//状态（是否分配）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">used_list_queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> id;<span class="comment">//进程号</span></span><br><span class="line">    <span class="type">double</span> start_address;<span class="comment">//开始地址</span></span><br><span class="line">    <span class="type">double</span> length;<span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）为了尽可能的避免产生碎片，我决定采用最佳适配法</p><p>最佳适配法（best fit）<br>    空闲分区链（表）按大小递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assignment memory&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">length</span>(free_list_queue)!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">sort</span>(free_list_queue);<span class="comment">//对空闲列表进行排序</span></span><br><span class="line">best=<span class="built_in">check</span>(free_list_queue,process_memory)<span class="comment">//遍历空闲列表，找到第一个足够大小的分区</span></span><br><span class="line"><span class="built_in">fill_memory</span>(best,process)<span class="comment">//将进程放入该分区</span></span><br><span class="line"><span class="keyword">delete</span> free_list_queue[best] <span class="comment">//更新空闲列表</span></span><br><span class="line">        add <span class="built_in">used_list_queue</span>(prcess,best)<span class="comment">//更新已使用的列表</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">    置换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软中断和硬中断区别</p><p>总体而言，硬中断和软中断都是计算机系统中用于处理异步事件的机制，但它们的触发方式和处理方式有所不同。硬中断是由外部硬件设备触发的，而软中断是由软件程序主动发起的。</p><p>看到网上的一个比喻我觉得非常恰当：</p><p>你在屋里打电话，这时候响起了敲门声，你可以去处理敲门声，也可以不理会继续打电话，这是软中断。但是如果电话线断了，你必须停止打电话，这是硬中断</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）进程管理下</title>
      <link href="/2023/10/17/Computer_system/Os/3%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8B/"/>
      <url>/2023/10/17/Computer_system/Os/3%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202016655.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202016655.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="进程管理下总览图"></p><p>进程之间的同步和互斥</p><p>同步，是指一个某一步的执行必须需要等待其他操作完成之后</p><p>互斥，是指一个进程的某一块只能有一个进程访问</p><h1 id="6-经典进程同步问题"><a href="#6-经典进程同步问题" class="headerlink" title="6.经典进程同步问题"></a>6.经典进程同步问题</h1><h2 id="6-1-生产者-消费者问题-既有同步又有互斥"><a href="#6-1-生产者-消费者问题-既有同步又有互斥" class="headerlink" title="6.1 生产者-消费者问题 (既有同步又有互斥)"></a>6.1 生产者-消费者问题 (既有同步又有互斥)</h2><p><strong>问题描述</strong></p><p>生产者往缓冲区写数据，满了的话就不能写了</p><p>消费者从缓冲区取数据，空的话就不能取了</p><p>一次只能有一个生产者或消费者取读数据</p><p><strong>问题分析</strong></p><p>核心解决</p><p>（1）不能向满的缓存区写数据，否则的话必须等待（同步关系）</p><p>（2）不能向空的缓存区取数据，否则的话必须等待（同步关系）</p><p>（3）任何时刻，仅允许一个1个生成者或1个消费者访问</p><p>意味着消费者之间互斥，生成者之间互斥，消费者和生产者之间互斥，总结来说就是任意两个进程之间对缓冲区操作的时候，其他进程不能操作 （互斥关系）</p><p>full：记录缓冲区中非空的槽数，初始值&#x3D;0</p><p>empty：记录缓冲区中空的槽数，初始值&#x3D;N</p><p>mutex：确保进程不同时访问缓冲区，初始值&#x3D;1</p><p>解决（1）（2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void producer(void)&#123;</span><br><span class="line">while (True) &#123;</span><br><span class="line">        produce(); //生产1项</span><br><span class="line">        P(empty); //申请1个空槽</span><br><span class="line">        P(mutex); //请求进入临界区</span><br><span class="line">        append(); //加入缓冲区</span><br><span class="line">        V(mutex); //离开临界区</span><br><span class="line">        V(full); //递增非空槽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer(void)&#123;</span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">        P(full); //申请1个非空槽</span><br><span class="line">        P(mutex); //申请进入临界区</span><br><span class="line">        remove(); //从缓冲区移出1项</span><br><span class="line">        V(mutex); //离开临界区</span><br><span class="line">        V(empty); //递增空槽数</span><br><span class="line">        consume(); //消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2-读者-写者问题"><a href="#6-2-读者-写者问题" class="headerlink" title="6.2 读者-写者问题"></a>6.2 读者-写者问题</h2><p><strong>问题描述</strong></p><p>多个Reader进程，多个Writer进程，共享文件F<br>要求：<br>  允许多个Reader进程同时读文件<br>  不允许任何一个Writer进程与其他进程同时访问（读或写）文件</p><p><strong>问题分析</strong></p><p>​写者之间要互斥</p><p>​读者和写者之间互斥</p><p>​读者之间不互斥</p><p>所以核心是我们要在第一个读者进来的时候，进行判断是否有写者正在写</p><p><strong>标答</strong></p><p>write</p><p>WriteMutex &#x3D; 0  读写操作的互斥访问<br>Rcount &#x3D; 0 正在读操作的读者数目<br>CountMutex &#x3D; 0 读者计数的互斥访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (True) &#123;</span><br><span class="line"><span class="built_in">P</span>(CountMutex);</span><br><span class="line">  <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">P</span>(WriteMutex);</span><br><span class="line">     ++Rcount;</span><br><span class="line"><span class="built_in">V</span>(CountMutex);</span><br><span class="line">     read;</span><br><span class="line"><span class="built_in">P</span>(CountMutex);</span><br><span class="line"> --Rcount;</span><br><span class="line">      <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">V</span>(WriteMutex);</span><br><span class="line"><span class="built_in">V</span>(CountMutex);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (True) &#123;</span><br><span class="line">    <span class="built_in">P</span>(WriteMutex);</span><br><span class="line">        write;</span><br><span class="line">    <span class="built_in">V</span>(WriteMutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-哲学家进餐问题"><a href="#6-3-哲学家进餐问题" class="headerlink" title="6.3 哲学家进餐问题"></a>6.3 哲学家进餐问题</h2><p><strong>问题描述</strong></p><p>有5个哲学家围坐在一张圆桌周围，每个哲学家面前有1碗饭，左右各1把叉子。<br>哲学家有两种活动：思考和吃饭。<br>只有拿到左右两把叉子才能吃饭。<br>吃饭后，放下叉子，继续思考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5个信号量，分别用于对5个叉子互斥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  5 <span class="comment">//哲学家数</span></span></span><br><span class="line">Semaphore_t  fork[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span> <span class="params">(<span class="type">int</span> i)</span> <span class="comment">//i是哲学家编号：0~N-1  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)  &#123;</span><br><span class="line">        <span class="built_in">think</span>(); </span><br><span class="line">        <span class="built_in">P</span>(fork[i]); </span><br><span class="line">        <span class="built_in">P</span>(fork[(i+<span class="number">1</span>) % N]); </span><br><span class="line">        <span class="built_in">eat</span>(); </span><br><span class="line">        <span class="built_in">V</span>(fork[i]); </span><br><span class="line">        <span class="built_in">V</span>(fork[(i+<span class="number">1</span>) % N]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-进程之间通信"><a href="#7-进程之间通信" class="headerlink" title="7.  进程之间通信"></a>7.  进程之间通信</h1><p>P,V操作实现的是进程之间的低级通信，所以P,V操作是低级通讯原语，即不能传递大量的信息</p><p>所以我们引入进程间高级通讯方式</p><h2 id="7-1-共享存储区"><a href="#7-1-共享存储区" class="headerlink" title="7.1 共享存储区"></a>7.1 共享存储区</h2><p>相互通信的进程间设有公共的内存区，每个进程既可向该公共内存中写，也可从公共内存中读，通过这种方式实现进程间的信息交换。<br>      把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p><h2 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h2><p> 源进程发送消息，目的进程接受消息。所谓消息，就是一组数据。</p><p>（1）消息队列（message Queue）或消息缓冲<br>    发送者发消息到一个消息队列中；<br>    接收者从相应的消息队列中取消息。<br>    消息队列所占的空间从系统的公用缓冲区中申请得到。<br>（2）邮箱（mailbox）<br>  发送者发消息到邮箱，接收者从邮箱取消息。<br>  邮箱是一种中间实体，一般用于非实时通信。</p><h2 id="7-3-管道"><a href="#7-3-管道" class="headerlink" title="7.3 管道"></a>7.3 管道</h2><p>首创于Unix。用于连接一个读进程、一个写进程，以实现它们之间通信的共享文件，称为pipe文件。</p><p>管道分为下列2种：<br> 有名管道<br> 无名管道</p><h1 id="8-线程"><a href="#8-线程" class="headerlink" title="8.线程"></a>8.线程</h1><p>为什么引入线程</p><p>线程是进程的１条执行路径。方便进程内部的同步操作，线程之间共享内存</p><p>比如，一个文字输入软件，其内部可以有三个线程，一个用来加载视频、一个用来播放视频，一个用来备份。因为进程之间不共享内存，所以不能用多个进程来实现这时就用多线程可以解决。线程之间共享内存，所以从一个线程切换到另一个线程不需要陷入内核，也不需要切换上下文，线程之间的切换比进程切换快捷。</p><p>　1个进程可以有多个线程，其中至少有1个主线程（primary thread）。</p><p>　1个进程内的多个线程在同一个地址空间内（共享该进程的地址空间）。</p><p>每个线程有自己的线程控制块TCB（Thread Control Block），包含自己的堆栈和状态信息。TCB比PCB小得多。</p><h2 id="8-1-线程的实现机制"><a href="#8-1-线程的实现机制" class="headerlink" title="8.1 线程的实现机制"></a>8.1 线程的实现机制</h2><p>用户级线程</p><p>​由在用户空间执行的线程库来实现，OS对此一无所知。　<br>线程库提供线程创建、撤消、上下文切换、通信、调度等功能。</p><p>​用户级线程是自己实现的线程创建，删除</p><p>​但是这样的话操作系统分配的是进程为单位的，容易阻塞</p><p>​但是性能高，无需陷入内核</p><p>核心级线程</p><p>​用户级线程是自己实现的线程创建，删除</p><p>​但是这样的话操作系统分配的是线程为单位的</p><p>​但是性能低，需要陷入内核</p><h1 id="9-进程调度"><a href="#9-进程调度" class="headerlink" title="9 进程调度"></a>9 进程调度</h1><p>为什么进程调度</p><p>多个进程就绪时候，OS决定先执行哪一个</p><p>我们进程调度要达到的目的</p><p>​CPU利用率高，吞吐量大，周转时间少，等待时间短，公平</p><p>​很多时候都是在权衡！很多时候很难兼顾所有的目的</p><p>什么时候会切换进程呢？</p><p>​硬件中断，进程异常，或者该进程请求IO，这些都会让CPU闲下来，我们就要给CPU找活干了</p><p>一些概念</p><ul><li>周转时间 &#x3D; 作业完成时刻 - 作业到达时刻</li><li>带权周转时间 &#x3D; 周转时间 &#x2F; 服务时间</li><li>平均周转时间 &#x3D; 作业周转总时间 &#x2F; 作业个数</li><li>平均带权周转时间 &#x3D; 带权周转总时间 &#x2F; 作业个数</li></ul><h2 id="9-1-调度方式"><a href="#9-1-调度方式" class="headerlink" title="9.1 调度方式"></a>9.1 调度方式</h2><p>非抢占方式</p><p>​一旦某进程被调度，直到完成或因某事件而阻塞，才会切换到其他进程</p><p>抢占方式</p><p>​允许暂停正在运行的进程，切换到其他进程</p><p>抢占原则：</p><p>​时间片原则：时间片到时抢占</p><p>​优先级原则：优先级高者到时抢占</p><h2 id="9-2-常见算法"><a href="#9-2-常见算法" class="headerlink" title="9.2 常见算法"></a>9.2 常见算法</h2><h3 id="9-2-1-先来先服务-FCFS"><a href="#9-2-1-先来先服务-FCFS" class="headerlink" title="9.2.1 先来先服务  FCFS"></a>9.2.1 先来先服务  FCFS</h3><p><strong>方法</strong></p><p>按照进程就绪的先后次序来调度进程，非抢占式方式</p><p><strong>优点</strong>：实现简单</p><p><strong>缺点</strong>:<br>    （1）平均等待时间波动很大<br>              短进程、长进程到达时间是随机的<br>    （2）有利于CPU繁忙型进程，不利于I&#x2F;O繁忙型进程<br>    （3）有利于长进程，不利于短进程</p><h3 id="9-2-2-短进程优先-SPN"><a href="#9-2-2-短进程优先-SPN" class="headerlink" title="9.2.2 短进程优先 SPN"></a>9.2.2 短进程优先 SPN</h3><p><strong>方法：</strong></p><p>  选择估计运行时间最短的进程运行。<br>短进程优先算法具有最优平均周转时间</p><p><strong>优点</strong>：</p><p>  平均等待时间较短</p><p><strong>缺点</strong></p><p>  对长进程（作业）不利。<br>  极端情况下，会使长进程（作业）得不到调度。</p><p>所以在这个上面的改进提出最高响应比算法</p><h3 id="9-2-3-最高相应比优先算法"><a href="#9-2-3-最高相应比优先算法" class="headerlink" title="9.2.3 最高相应比优先算法"></a>9.2.3 最高相应比优先算法</h3><p><strong>方法</strong></p><p>选择就绪队列中相应比R值最高的进程<br>     R &#x3D; （W + S）&#x2F; S<br>             W: 等待时间（waiting time）<br>             S: 执行时间（service time）</p><p>短进程优先算法：长进程等待的时间而出现饥饿<br>  对于最高响应优先算法，如果等待时间越长，则R会越大，在一定程度上避免了长进程出现饥饿的情况</p><p>但上面的两种方法都得估计进程运行的时间，这个预测未来比较难</p><p>另外计算开销比较大，所以应用比较少</p><h3 id="9-2-4-时间片轮转-RR"><a href="#9-2-4-时间片轮转-RR" class="headerlink" title="9.2.4 时间片轮转 RR"></a>9.2.4 时间片轮转 RR</h3><p><strong>方法</strong></p><p> 将所有的就绪进程按FCFS原则排成一个队列，<br>    规定一个时间片为进程每次使用CPU的最长时间，<br>    每次选择队首进程运行，<br>    当时间片到时，剥夺该进程的运行，将其排在队尾</p><h3 id="9-2-5-基于优先级的调度"><a href="#9-2-5-基于优先级的调度" class="headerlink" title="9.2.5 基于优先级的调度"></a>9.2.5 基于优先级的调度</h3><p><strong>方法</strong></p><p>每个进程一个优先级；<br>总是选择就绪队列中优先级最高的进程投入运行；<br>可以是抢占式，或非抢占式。</p><h3 id="9-2-6-多级反馈队列"><a href="#9-2-6-多级反馈队列" class="headerlink" title="9.2.6 多级反馈队列"></a>9.2.6 多级反馈队列</h3><p><strong>方法</strong></p><p>(1) 按优先级设置n(n&gt;1)个就绪队列，每个队列赋予不同优先级。如第一级队列到最后一级队列，优先级依次降低。<br>(2) 优先级越高队列，分配的时间片越小。<br>(3) 每个队列按照先来先服务原则排队。<br>(4) 一个新进程就绪后进入第一级（或相应优先级）队尾。<br>(5) 调度方法<br>每次选择优先级最高队列的队首进程运行；<br>若被调度进程的时间片到，则放入下一级队列的队尾；<br>最后一级队列采用时间片轮转；<br>当有一个优先级更高的进程就绪时，可以抢占CPU，被抢占进程回到原来队列的末尾。</p><p>该算法综合了前面几种算法的优点。<br>  既考虑了先来先服务，又照顾了长进程；<br>  既考虑了优先级，又讲求公平。</p><h1 id="10-进程死锁"><a href="#10-进程死锁" class="headerlink" title="10 进程死锁"></a>10 进程死锁</h1><h2 id="10-1-基本概念"><a href="#10-1-基本概念" class="headerlink" title="10.1 基本概念"></a>10.1 基本概念</h2><p>第一个概念死锁</p><p><strong>死锁</strong></p><p>什么是死锁呢？</p><p>一个进程集合中的每个进程都在等待只能由该集合中的其它进程才能引发的事件，这种状态称作死锁。<strong>一组竞争系统资源的进程由于相互等待而出现“永久”阻塞</strong>。</p><p>例如，2个进程A、B，都需要资源R1、R2</p><p>若A：拥有R1，申请R2</p><p>若B：拥有R2，申请R1</p><p>如何？</p><p>第二个概念资源的基本分类</p><p><strong>资源分类</strong></p><p><strong>可重用资源</strong></p><p>资源不能被删除且在任何时刻只能有一个进程使用</p><p>进程释放资源后，其他进程可重用</p><p>例如：处理器，I&#x2F;O通道等等</p><p>可能出现的死锁</p><p>每个进程占用一部分资源并请求其他资源</p><p><strong>消耗资源</strong></p><p>资源创建和销毁过程</p><p>例如：在I&#x2F;O缓冲区的中断、信号和消息等</p><p> 可能出现的死锁</p><p>进程间相互等待接收对方的消息</p><h2 id="10-2-什么情况产生死锁"><a href="#10-2-什么情况产生死锁" class="headerlink" title="10.2 什么情况产生死锁"></a>10.2 什么情况产生死锁</h2><p>四个必要条件</p><p>1）互斥条件<br>   每个资源要么被分配给了1个进程，要么空闲<br>2）占有及等待（部分分配）条件<br>   已经得到了资源的进程要申请新的资源<br>3）不可剥夺条件<br>   已经分配给一个进程的资源不能被剥夺，只能由占有者显式释放<br>4）环路等待条件<br>   存在由2个或多个进程组成的一条环路，<br>   该环路中的每个进程都在等待相邻进程占有的资源</p><h2 id="10-3-死锁前—检测死锁"><a href="#10-3-死锁前—检测死锁" class="headerlink" title="10.3 死锁前—检测死锁"></a>10.3 死锁前—检测死锁</h2><p>一 由OS处理</p><p>​1 检测死锁并恢复</p><p>​2 分配资源时避免死锁</p><p>​3 假装没看见（鸵鸟策略）：多数OS对待死锁的策略，那死锁了怎么办，开机重启</p><p>二 由应用程序本身预防死锁</p><p>实际中检测死锁恢复是可能的，但是代价太大</p><h3 id="10-3-1-死锁检测"><a href="#10-3-1-死锁检测" class="headerlink" title="10.3.1 死锁检测"></a>10.3.1 死锁检测</h3><p>方法一 资源分配图</p><p>看看有没有环，有环的话有没有无法释放的情况</p><p>方法二 矩阵</p><h3 id="10-3-2-何时检测"><a href="#10-3-2-何时检测" class="headerlink" title="10.3.2 何时检测"></a>10.3.2 何时检测</h3><p>1）每当有资源请求时；</p><p>2）周期性检测；</p><p>3）每当CPU的使用率降到某一阈值时。</p><p>死锁检测会占用大量的CPU时间</p><h2 id="10-4-死锁前—死锁避免"><a href="#10-4-死锁前—死锁避免" class="headerlink" title="10.4 死锁前—死锁避免"></a>10.4 死锁前—死锁避免</h2><p><strong>银行家算法</strong></p><p>一个小城镇的银行家，他向一群客户分别承诺了一定金额的贷款，而他知道不可能所有客户同时都需要最大的贷款额。在这里，我们可将客户比作进程，银行家比作操作系统。银行家算法就是对每一个客户的请求进行检查，检查如果满足它是否会引起不安全状态。如果是，则不满足该请求；否则，便满足。</p><p><strong>使得死锁四个条件有一个不成立</strong></p><p>1 破坏互斥条件   对资源统一管理，如SPOOLing技术</p><p>2 破坏不可剥夺条件 当进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源。</p><p>3 破坏占有及等待条件  原子性地获得所需全部资源。</p><p>4 破坏环路等待条件 把系统中所有资源按类型不同进行线性排队，并编号</p><h2 id="10-5-死锁后—恢复死锁"><a href="#10-5-死锁后—恢复死锁" class="headerlink" title="10.5 死锁后—恢复死锁"></a>10.5 死锁后—恢复死锁</h2><p>如何从死锁中恢复？</p><p>1 剥夺法恢复<br>  将某一资源从一个进程抢占过来给另一个进程使用<br>  不能影响原进程的最终执行结果<br>  取决于资源的特性</p><p>2  回退法恢复<br>  从各进程最近的检查点（check point）逐次重新启动</p><p>3 杀死进程来恢复<br>  最好杀死可重复执行、不会产生副作用的进程</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）进程管理上</title>
      <link href="/2023/10/16/Computer_system/Os/2%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8A/"/>
      <url>/2023/10/16/Computer_system/Os/2%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201558893.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201558893.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="总览图"></p><p><strong>简单概述</strong></p><p>什么是进程？<br>   是程序的1次执行（程序执行的1个实例）<br>   每个进程有自己的地址空间。</p><p>为什么引入进程？<br>   多任务的需要。在内存中同时有多个可执行的进程，如果某一个进程去请求I&#x2F;O了，那么CPU就会空闲，这时候其他进程如果不执行的话，CPU利用率就会很低，所以进程并发执行以提高效率（特别是CPU的利用率）。</p><p>因此，需要对进程进行管理，以避免冲突：<br>   借助于PCB，记录进程的描述和控制信息、上下文状态</p><h1 id="1-进程和程序区别"><a href="#1-进程和程序区别" class="headerlink" title="1 进程和程序区别"></a>1 进程和程序区别</h1><p>进程是程序的1次执行。<br>进程（Process）和程序（Program）是两个不同的概念，它们在计算机科学中有明确的区别：</p><ol><li><strong>程序（Program）</strong>：<ul><li><strong>定义</strong>：程序是一组计算机指令的有序集合，这些指令被编写成一个文件，通常以可执行文件的形式存在。程序是静态的，它只是一段代码的集合，等待被执行。</li><li><strong>特点</strong>：程序包含了计算机程序员编写的源代码，它描述了一系列任务的算法和逻辑，但并没有实际执行。程序不占用计算机的内存空间，也不消耗计算机的CPU时间。</li><li><strong>例子</strong>：一个文本编辑器的程序文件、一个游戏的可执行文件、一个网页浏览器的应用程序等都是程序的例子。</li></ul></li><li><strong>进程（Process）</strong>：<ul><li><strong>定义</strong>：进程是计算机中正在运行的程序的实例。它是程序在内存中加载并执行时的活动状态，包括程序的代码、数据、执行状态、系统资源分配等。</li><li><strong>特点</strong>：进程是动态的，它占用计算机的内存空间，可以执行计算机指令，与其他进程并发运行。每个进程都有自己的独立内存空间，因此它们不会相互干扰。进程可以创建、启动、暂停、终止等。</li><li><strong>例子</strong>：当运行一个文本编辑器、播放音乐、浏览网页或打印文档时，每个活动都对应一个独立的进程。</li></ul></li></ol><p>总结来说，程序是静态的、不执行的计算机指令集合，而进程是程序的运行实例，它占用计算机内存，执行指令，并与其他进程一起协同工作。进程是计算机操作系统中的核心概念，它使多任务处理成为可能.</p><p>可以将程序和进程比喻为烹饪的过程：</p><ol><li><strong>程序（Program）</strong>就像是一本菜谱。菜谱是一份详细的食物制作指南，它包含了食材清单、烹饪步骤和所需的厨具。但菜谱本身并不能做出美味的食物，它只是一份指导，等待着被厨师（计算机）读取和执行。就像您需要拿出菜谱并按照其中的步骤去做一道菜一样，计算机需要将程序加载到内存中并执行其中的指令。</li><li><strong>进程（Process）</strong>就像是正在烹饪中的一道菜。当您选择一道菜谱并开始烹饪时，您实际上在制作一道具体的菜肴。这个菜肴有自己的成分、调味料和烹饪状态。它在火上烹煮、被切割、被摆盘等等。这个菜肴是实际被制作和提供给食客的，就像进程是正在计算机内存中运行和执行的程序实例。</li></ol><p>所以，程序就像是一份指导，而进程是实际的动态执行。程序是静态的，而进程是具体的、可见的操作。</p><h1 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2 进程状态"></a>2 进程状态</h1><h2 id="2-1-进程的5种基本状态"><a href="#2-1-进程的5种基本状态" class="headerlink" title="2.1 进程的5种基本状态"></a>2.1 进程的5种基本状态</h2><p>（1）新建（new）：进程正在被创建。<br>（2）就绪（ready）：进程可运行，正等待获得处理机。<br>（3）运行（running）：进程的指令正在被执行。<br>（4）阻塞（blocked）或等待：进程因等待某事件（如请求I&#x2F;O）而暂停执行。<br>（5）完成（done）：进程结束。</p><h2 id="2-2-进程状态之间转换"><a href="#2-2-进程状态之间转换" class="headerlink" title="2.2 进程状态之间转换"></a>2.2 进程状态之间转换</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230916111349155.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230916111349155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="状态转换图"></p><h2 id="2-3-七状态模型"><a href="#2-3-七状态模型" class="headerlink" title="2.3 七状态模型"></a>2.3 七状态模型</h2><p>在五状态的模型基础上，引入挂起（即 进程此时在外存等待）</p><p>就绪(Ready)：进程在内存且可立即进入运行状态<br>阻塞(Blocked)：进程在内存并等待某事件的出现<br>阻塞挂起(Blocked, suspend)：进程在外存并等待某事件的出现<br>就绪挂起(Ready, suspend)：进程在外存，但只要进入内存，即可运行<br> 运行<br> 新建<br> 完成</p><p>注意 挂起都在外存</p><p>挂起：把进程从内存转到外存  </p><p>激活：把进程从外存转到内存</p><p>补充：</p><p>时间片是操作系统给程序分配的时间，保证一个进程不会一直占用CPU资源不释放造成混乱</p><h1 id="3-进程描述"><a href="#3-进程描述" class="headerlink" title="3 进程描述"></a>3 进程描述</h1><h2 id="3-1-进程控制块-PCB"><a href="#3-1-进程控制块-PCB" class="headerlink" title="3.1 进程控制块 PCB"></a>3.1 进程控制块 PCB</h2><p><strong>作用</strong></p><p>​1 是OS管理和控制进程的数据结构。</p><p>​2 PCB记录着进程的描述信息。</p><p>​ 每个进程对应1个PCB。</p><p><strong>信息内容</strong></p><p>（1）进程本身的标识信息</p><p>​进程标识符pid(process ID)：整数，由OS分配，唯一</p><p>​用户标识符uid(user ID)：创建该进程的用户</p><p>​对应程序的地址：内存、外存</p><p>（2）CPU现场 - 为进程正确切换所需</p><p>​所有寄存器的值  或称进程上下文(context)</p><p>​因为要切换走进程！所以要保护当前进程的上下内容，使得切换回来的时候可以继续正常执行</p><p>（3）进程调度信息</p><p>​进程的状态</p><p>​优先级</p><p>​使进程阻塞的条件</p><p>​占用CPU 、等待CPU的时间（用于动态调整优先级）</p><p>（4）进程占用资源的信息</p><p>​进程间同步和通信机制，如信号量、消息队列指针</p><p>​打开文件的信息，如文件描述符表</p><p>CPU现场 - 为进程正确切换所需</p><p> 所有寄存器的值</p><p> 或称进程上下文(context)</p><p>Linux的进程控制块:task_struct</p><p>​进程创建时，由OS创建PCB;进程终止时，由OS撤销PCB；进程运行时，以PCB作为调度依据。</p><h2 id="3-2-进程块组织方式"><a href="#3-2-进程块组织方式" class="headerlink" title="3.2 进程块组织方式"></a>3.2 进程块组织方式</h2><p>一般来说，系统把所有PCB组织在一起，并把它们放在内存的固定区域，构成<strong>PCB</strong>表。</p><p>PCB表的大小决定了系统中最多可同时存在的进程个数。</p><p>同一状态进程的PCB组成一个链表，不同状态对应多个不同的链表，如就绪链表、阻塞链表 </p><h1 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4 进程控制"></a>4 进程控制</h1><p>进程控制就是要对我们上述讲到的进程状态之间做转换</p><p>基本概念</p><p><strong>原语</strong></p><p>​创建、撤销进程以及完成进程各状态之间的转换，由具有特定功能的原语完成</p><p>​原语 由若干指令构成的具有特定功能的函数</p><p>​具有原子性，其操作具有不可分割性</p><p>如：</p><p>​进程创建原语</p><p>​进程撤销原语</p><p>​阻塞原语</p><p>​唤醒原语</p><p>​挂起原语</p><p>​激活（解挂）原语</p><p>​改变进程优先级</p><h1 id="5-进程同步-互斥"><a href="#5-进程同步-互斥" class="headerlink" title="5 进程同步 互斥"></a>5 进程同步 互斥</h1><p>在执行时间上互相重叠（或交替），一个进程的执行尚未结束，另一个进程的执行已经开始的执行方式。</p><p>这样会有一个问题</p><p>​因为资源共享的问题，结果会产生不确定性</p><p>举一个例题</p><p>为此，引入同步（synchronization）和互斥（mutual exclusion）。</p><p>临界资源  一次只允许一个进程独占访问（使用）资源 ，越小越好</p><p>临界区   进程中访问临界资源的的程序段</p><h2 id="5-1-区分进程互斥和同步"><a href="#5-1-区分进程互斥和同步" class="headerlink" title="5.1 区分进程互斥和同步"></a>5.1 区分进程互斥和同步</h2><p>互斥是指执行某个进程的时候访问某一临界资源的时候，另一个进程不能执行访问这一临界资源。</p><p>经典只有互斥问题：打印机打印</p><p>同步是指完成某一进程执行是有条件的，必须等另一个进程的某一资源结束才可以</p><p>经典只有同步的问题：售票员售票</p><p>既有互斥又有同步问题：消费者问题</p><h2 id="5-2-核心方案"><a href="#5-2-核心方案" class="headerlink" title="5.2 核心方案"></a>5.2 核心方案</h2><p>信号量</p><p>利用信号量P-V操作可以实现进程的互斥访问</p><p>利用信号量P-V 操作可以实现进程的同步访问</p><h2 id="5-3-其他方案"><a href="#5-3-其他方案" class="headerlink" title="5.3 其他方案"></a>5.3 其他方案</h2><p>实现互斥方案</p><p>一个好的互斥方案应满足以下条件：</p><p>（1）任何两个进程不能同时处于临界区。</p><p>（2）临界区外的进程不应阻止其他进程进入临界区。</p><p>（3）不应使进程在临界区外无休止地等待。就是说，临界区代码执行时间要短。</p><p>（4）不应对CPU的个数和进程之间的相对运行速度作任何假设。</p><h3 id="方案1-设置锁变量"><a href="#方案1-设置锁变量" class="headerlink" title="方案1 设置锁变量"></a>方案1 设置锁变量</h3><p>即设置一个共享变量lock</p><p>当lock&#x3D;0的时候，临界区内无进程，初始值</p><p>当lock&#x3D;1的时候，临界区内有进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(lock);</span><br><span class="line">lock=<span class="number">1</span>;</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">lock=<span class="number">0</span>;</span><br><span class="line">&lt;非临界区&gt;</span><br></pre></td></tr></table></figure><p>可能的问题</p><p>1 会导致两个进程同时进入临界资源</p><p>​比如进程1走到lock&#x3D;1的时候，还没来得及上锁（修改lock的值为1）就被切换走了，这时候其他进程 就可以避免while也进入临界区</p><p>2  可能会存在盲等待   走到lock&#x3D;0的时候，还没来得及解锁就被切换走了，这时候其他进程都进不来！</p><p>所以这种方案是错误的，不能达到效果</p><h3 id="方案2-严格轮转法"><a href="#方案2-严格轮转法" class="headerlink" title="方案2 严格轮转法"></a>方案2 严格轮转法</h3><p>设置共享变量turn，以指示进入临界区的进程号</p><p>以两个进程为例</p><p>turn&#x3D;0的时候允许进程0进入临界区，初始值</p><p>turn&#x3D;1的时候允许进程1进入临界区</p><p>进程0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  (turn != <span class="number">0</span>);</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">&lt;非临界区&gt; </span><br></pre></td></tr></table></figure><p>进程1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  (turn != <span class="number">1</span>);</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">&lt;非临界区&gt; </span><br></pre></td></tr></table></figure><p>本质互为锁</p><p>可能的问题</p><p>进程可能会被临界区之外的进程阻塞</p><h3 id="方案3-Peterson解决方案"><a href="#方案3-Peterson解决方案" class="headerlink" title="方案3 Peterson解决方案"></a>方案3 Peterson解决方案</h3><p>设置一个共享变量process，代表此时进入临界区的进程号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enter_region</span>(process); <span class="comment">//process是 进入/离开临界区的进程号</span></span><br><span class="line">&lt;临界区&gt;</span><br><span class="line"><span class="built_in">leave_region</span>(process);</span><br><span class="line">&lt;非临界区&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个进程想进入临界区时，先调用enter_region函数，判断是否能安全进入，不能的话等待；当进程从临界区退出后，需调用leave_region函数，允许其它进程进入临界区。<br>两个函数的参数均为进程号</p><p>以两个进程为例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  FALSE  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TRUE   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   N        2 <span class="comment">// 进程的个数</span></span></span><br><span class="line"><span class="type">int</span>  turn;   <span class="comment">// 轮到谁？</span></span><br><span class="line"><span class="type">int</span>  interested[N];   <span class="comment">// 兴趣数组，表明第i个进程是否在临界区，所有元素初始值均为FALSE</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">enter_region</span> <span class="params">(<span class="type">int</span>  process)</span>  <span class="comment">// process为进程号 0 或 1&#123;        </span></span></span><br><span class="line"><span class="function">    <span class="type">int</span>  other</span>;  <span class="comment">// 另外一个进程的进程号        </span></span><br><span class="line">other  =  <span class="number">1</span>  -  process;        </span><br><span class="line">interested[process]  =  TRUE; <span class="comment">// 表明本进程进入临界区       </span></span><br><span class="line">turn  =  process;          <span class="comment">// 设置标志位       </span></span><br><span class="line"><span class="keyword">while</span> ( turn == process &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">leave_region</span> <span class="params">(<span class="type">int</span>  process)</span></span>&#123;      </span><br><span class="line">    interested[process]  =  FALSE; <span class="comment">// 本进程将离开临界区&#125;</span></span><br></pre></td></tr></table></figure><h3 id="方案4-关中断"><a href="#方案4-关中断" class="headerlink" title="方案4 关中断"></a>方案4 关中断</h3><p>由于进程在切换进程的时候 必须进行中断处理，既然如此的话</p><p>我们可以在一个程序进入临界区域之前，将中断功能给关闭，简称关中断！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关中断；</span><br><span class="line">&lt;临界区&gt;;</span><br><span class="line">开中断;</span><br><span class="line">&lt;非临界区&gt;;</span><br></pre></td></tr></table></figure><p>缺点</p><p>1 对多处理机系统无效，因为每个处理机有自己的中断开关</p><p>2 关中断权利交给用户不合适</p><h3 id="方案5-机器指令实现的互斥"><a href="#方案5-机器指令实现的互斥" class="headerlink" title="方案5 机器指令实现的互斥"></a>方案5 机器指令实现的互斥</h3><p>即保证某些内容他是直接互斥的</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）操作系统概述</title>
      <link href="/2023/10/15/Computer_system/Os/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/15/Computer_system/Os/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201236315.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201236315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="概述总览图"></p><h1 id="1-程序如何执行"><a href="#1-程序如何执行" class="headerlink" title="1 程序如何执行"></a>1 程序如何执行</h1><p>我们都对运行程序很熟悉，无论是QQ，微信都是一个个在运行的程序</p><p>我们也都知道有这样一个职业叫做——程序员，就是编写这些程序的代码的。</p><p>那么代码从编写好后到最终执行的过程是怎样的呢？实际有三步</p><p>​预处理 编译 链接</p><p>我们感觉好像很简单，但实际上程序运行需要各种资源，会有一些异常，这些处理我们往往不关心，而这些实际上是系统应用程序——操作系统来完成的</p><p>换句话说<strong>程序</strong>执行的整个生命周期都<strong>受操作系统控制</strong></p><p>比如建立程序的内存映像， CPU的分配 内存分配、释放 文件访问，输入输出（I&#x2F;O） 中断（异常）处理</p><h1 id="2-操作系统初探"><a href="#2-操作系统初探" class="headerlink" title="2 操作系统初探"></a>2 操作系统初探</h1><h2 id="2-1-操作系统功能"><a href="#2-1-操作系统功能" class="headerlink" title="2.1 操作系统功能"></a>2.1 操作系统功能</h2><p><strong>从用户观点看</strong>，操作系统是一个<strong>虚拟机</strong></p><p>​让用户（程序员）在使用计算机时不涉及计算机硬件的细节，使硬件细节和用户（程序员）隔离开来，即建立一种简单的高度抽象。</p><p><strong>从系统观点来看</strong>，操作系统是一个<strong>资源管理器</strong>：管理系统的软硬件资源</p><p>​硬件资源：构成计算机系统所必须配置的所有硬件： CPU、内存、时钟、磁盘。       软件资源：程序和数据（文件）。</p><p>总结来看，操作系统有四大功能</p><p>​ 进程管理，内存管理，文件管理， I&#x2F;O设备管理，以后的系列文章也会微软这个展开</p><h2 id="2-2-操作系统定义"><a href="#2-2-操作系统定义" class="headerlink" title="2.2 操作系统定义"></a>2.2 操作系统定义</h2><p>基于操作系统的功能</p><p>操作系统可以定义为</p><p>​OS是硬件之上的第1层软件（系统软件），是一组程序，用来有效控制和管理计算机系统的各类资源（硬件和软件资源：设备、文件、存储器、CPU、程序（进程））， 以方便用户使用计算机（用户和计算机的接口）</p><h1 id="3-操作系统一些概念"><a href="#3-操作系统一些概念" class="headerlink" title="3.操作系统一些概念"></a>3.操作系统一些概念</h1><h2 id="3-1-作业"><a href="#3-1-作业" class="headerlink" title="3.1 作业"></a>3.1 作业</h2><p>从输入开始到输出结束，用户要求计算机所做的一次业务处理的全部工作（一次业务处理往往需要包括多个程序配合）所以操作系统中的作业（Job）通常又可以理解为是一组相关任务或程序的集合</p><p>作业由三部分组成：1 程序  2要执行的程序代码  3数据</p><p>作业通常需要访问和处理数据，因此数据是作业的另一个重要组成部分</p><p>作业往往有着自己的控制信息等</p><p>假设你正在使用一台多任务操作系统的个人电脑，你同时打开了以下两个应用程序：</p><ol><li>文字处理器：你在编辑一份重要的文档。</li><li>网页浏览器：你正在浏览互联网上的一些新闻文章。</li></ol><p>在这个情景中，操作系统将视每个应用程序为一个作业，并为其分配资源和执行环境。</p><h2 id="3-2-批处理"><a href="#3-2-批处理" class="headerlink" title="3.2 批处理"></a>3.2 批处理</h2><p>为改进内存和I&#x2F;O设备之间的吞吐量 ，进行批处理操作</p><p>就是3.1讲的是一个作业处理</p><p>而3.2 就是同时处理多个作业，多个作业构成一个队列，依次处理</p><p><strong>缺点</strong>：</p><p>​    用户不能干预自己作业的运行     一旦发现作业错误不能及时改正     延长了软件开发时间     一般只适用于成熟的程序或大型的计算程序</p><h2 id="3-3-单道程序和多道程序"><a href="#3-3-单道程序和多道程序" class="headerlink" title="3.3 单道程序和多道程序"></a>3.3 单道程序和多道程序</h2><ul><li>单道程序：</li></ul><p>​内存中只有一个用户程序</p><p>​因为I&#x2F;O很费时，若当前程序因等待I&#x2F;O而暂停， 则<strong>CPU空闲</strong></p><ul><li>多道程序：  在内存中存放多个用户程序，同时处于可运行状态。    当一个程序等待I&#x2F;O时，另一个程序可以使用CPU</li></ul><p>我们现在的操作系统肯定都是多道程序，核心目的让CPU忙起来，提高效率</p><h2 id="3-4-多道批处理系统"><a href="#3-4-多道批处理系统" class="headerlink" title="3.4 多道批处理系统"></a>3.4 多道批处理系统</h2><p>多道程序+批处理&#x3D;多道批处理系统</p><p>与单道批处理系统相比：  系统吞吐量（单位时间内完成的总工作量）大；  资源利用率高； 周转时间（作业从进入系统到完成所经历的时间）长。</p><h2 id="3-5分时系统"><a href="#3-5分时系统" class="headerlink" title="3.5分时系统"></a>3.5分时系统</h2><p>多个用户（程序）共享一台计算机，按时间片（time slice）轮流使用。</p><p>什么是 时间片：OS将CPU时间划分为若干个片段</p><h2 id="3-6-并发和并行"><a href="#3-6-并发和并行" class="headerlink" title="3.6 并发和并行"></a>3.6 并发和并行</h2><p>并发：两个或多个事件在同一时间间隔内交替发生，不一定是同时执行。</p><p>并行：两个或多个事件在同一时刻发生。</p><p> 多用户：允许多个用户通过各自的终端使用同一台主机，共享主机系统中的各类资源。 多任务：允许多个程序并发执行。</p><p>一个 比喻更好理解</p><ul><li><strong>并发</strong>：想象一个餐厅，只有一个厨师和一个服务员。多个客人进入餐厅，他们点餐后，服务员会为每个客人记录点餐的需求，然后将这些需求交给厨师。厨师会依次准备每份菜肴，然后将它们送到客人的桌子上。虽然只有一个厨师，但由于服务员不断地切换处理不同客人的需求，似乎每个客人都在同一时间段内得到了服务，这就是<strong>并发</strong>。多个任务（客人的点餐需求）在同一个资源（厨师）上交替执行。</li><li><strong>并行</strong>：现在，想象这家餐厅升级了，雇佣了多个厨师，每个厨师都可以独立准备菜肴，而服务员可以同时为多个客人提供服务。在这种情况下，每个厨师和服务员都可以同时处理不同的客户需求，这就是<strong>并行</strong>。多个任务（客人的点餐需求）在同时使用不同的资源（多个厨师和服务员）来提高效率。</li></ul><p>还有比如实时OS，网络OS，分布式OS</p><h1 id="4-OS对运行环境的要求"><a href="#4-OS对运行环境的要求" class="headerlink" title="4. OS对运行环境的要求"></a>4. OS对运行环境的要求</h1><h2 id="4-1-CPU"><a href="#4-1-CPU" class="headerlink" title="4.1 CPU"></a>4.1 CPU</h2><p>CPU是执行程序的核心部件</p><p>CPU 通过状态标识，知道是操作系统程序还是用户程序在执行，从而给到OS特权指令（只能由OS执行的命令），进行一些紧急任务建立存储保护，清内存、关中断等</p><p>CPU<strong>两种工作状态</strong></p><p>​<strong>核心态</strong></p><p>处于核心态的时候 </p><p>全部指令（包括特权指令）可以执行 可使用所有资源 并具有改变处理器状态的能力</p><p>​<strong>用户态</strong></p><p>处于用户态的时候</p><p>只有非特权指令能执行 特权级别不同，可运行的指令集合也不同 特权级别越高，可以运行的指令集合越大 高特权级别对应的可运行指令集合包含低特权级的</p><p>CPU的<strong>程序状态字PSW</strong></p><p>指示程序执行的当前状态，主要包括<br>  CPU的工作状态——指明核心态还是用户态，用来说明当前在CPU上执行的是操作系统还是应用程序，从而决定其是否可以使用特权指令或拥有其他的特殊权力<br>  条件标志——反映指令执行后的结果特征<br>  中断标志——指出是否允许中断</p><p>CPU的<strong>程序计数字PC</strong></p><p>指示下一条要执行的指令</p><h2 id="4-2-内存"><a href="#4-2-内存" class="headerlink" title="4.2 内存"></a>4.2 内存</h2><p>程序必须存放在内存中才能运行。 </p><p>在多任务系统中，操作系统要管理、保护各任务的程序和数据，使它们不至于受到破坏和相互干扰。 操作系统本身也要存放在内存中并运行，不能被破坏。</p><p><strong>内存分块：</strong>块作为分配内存空间的基本单位，如4KB为1块。</p><p>为什么要按块来分配内存空间？旨在简化对内存的分配和管理</p><p><strong>内存保护：</strong> OS正常运行的基本条件</p><p>常用的保护机制</p><p> (1) 界限寄存器 存放某任务在内存的上界和下界地址(或者下界与长度)，越界后产生越界中断</p><p>(2) 存储保护键（ Key） 当一个程序进入内存时，OS为其分配一个唯一的Key。 同时将分配给它的每个存储块都设置成该Key</p><h2 id="4-3-中断"><a href="#4-3-中断" class="headerlink" title="4.3 中断"></a>4.3 中断</h2><p>指CPU在收到外部中断信号后，停止原来工作，转去处理该中断事件，完毕后回到原来断点继续工作。  CPU对系统中发生的“异步（随机）”事件的处理</p><p><strong>中断类型</strong></p><p>1 硬件中断</p><p>​又分为两类 </p><p>​内部异常（硬故障中断 ： 如电源断掉，程序性中断 ：如溢出，越界，非法指令等）</p><p>​外部中断（CPU外部发生的特殊事件，通过“中断请求”向CPU请求处理  如打印机缺纸等）</p><p> 2 异常（Exception）</p><p>3 陷入（Trap）</p><p>4 访管中断（系统调用）</p><p><strong>中断响应过程</strong></p><p>1 关中断   防止其他中断修改影响当下中断</p><p>2 保护断点和程序状态    将断点和程序状态保存到栈或特殊寄存器中</p><p>3 识别中断事件</p><h2 id="4-4-时钟"><a href="#4-4-时钟" class="headerlink" title="4.4 时钟"></a>4.4 时钟</h2><p>进行程序的同步，计数等</p><p>1 硬件时钟：通过时钟寄存器实现。  绝对时钟：记录当前时间 相对时钟（间隔时钟）：分时系统的基础。 </p><p>2 软件时钟：通过时钟队列实现。 </p><h2 id="4-5-重定位"><a href="#4-5-重定位" class="headerlink" title="4.5 重定位"></a>4.5 重定位</h2><p>将程序中的相对地址转换为绝对地址。 </p><p> 原因：运行前不可能知道程序将放在内存的什么位置。 </p><p>静态重定位：程序装入内存时，由装入程序重定位</p><p>动态重定位：CPU每次访问内存时，由动态地址转换机构（硬件）自动进行</p><h1 id="5-现代操作系统基本特征"><a href="#5-现代操作系统基本特征" class="headerlink" title="5.现代操作系统基本特征"></a>5.现代操作系统基本特征</h1><p>（1）并发         计算机系统中同时存在多个运行的程序，需要OS管理和调度</p><p> （2）共享        “同时”访问          互斥共享  </p><p>（3）虚拟         利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务 （4）异步        程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知         只要运行环境相同，OS需要保证程序运行的结果也要相同</p><h1 id="6-操作系统启动过程"><a href="#6-操作系统启动过程" class="headerlink" title="6 操作系统启动过程"></a>6 操作系统启动过程</h1><ol><li><strong>硬件自检（POST）</strong>：<ul><li>当计算机电源打开时，计算机硬件执行自检过程（POST），以确保所有硬件组件正常运行。这包括检查内存、CPU、磁盘驱动器等。</li></ul></li><li><strong>引导设备选择</strong>：<ul><li>计算机 BIOS 或 UEFI 固件负责选择要从中启动的设备。用户可以在 BIOS&#x2F;UEFI 设置中配置启动顺序，以决定首选引导设备，例如硬盘、光盘驱动器、USB 驱动器等。</li></ul></li><li><strong>MBR&#x2F;GPT加载</strong>：<ul><li>根据 BIOS&#x2F;UEFI 设置，计算机将查找引导设备的主引导记录（MBR）或分区表（GPT），以确定启动引导加载程序的位置。</li></ul></li><li><strong>引导加载程序（Boot Loader）</strong>：<ul><li>引导加载程序是启动过程的下一步，它负责加载操作系统内核。在EOS操作系统中，引导加载程序通常是GRUB（GRand Unified Bootloader）或其他引导加载程序。</li></ul></li><li><strong>内核加载</strong>：<ul><li>引导加载程序加载EOS操作系统内核（Linux内核）到计算机的内存中。内核是操作系统的核心，它负责管理硬件、进程、内存和文件系统等。</li></ul></li><li><strong>初始化（init）</strong>：<ul><li>一旦内核加载到内存中，它会执行初始化过程，初始化操作系统的各个组件和服务。在Linux中，init 进程是初始化的第一个进程，它将创建其他系统进程，并启动用户界面或命令行终端。</li></ul></li><li><strong>启动级别&#x2F;运行级别（Runlevels）</strong>：<ul><li>EOS操作系统支持不同的启动级别，每个级别定义了在系统启动时运行的一组服务和任务。用户可以通过更改运行级别来控制系统启动时加载的服务。不同的运行级别可以是单用户模式、多用户模式等。</li></ul></li><li><strong>登录&#x2F;用户界面</strong>：<ul><li>最后一步是用户登录或进入用户界面。用户可以通过输入用户名和密码登录，或者进入图形用户界面（GUI）或命令行界面（CLI），具体取决于系统配置。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系列文章</title>
      <link href="/2023/09/14/categories/index/"/>
      <url>/2023/09/14/categories/index/</url>
      
        <content type="html"><![CDATA[<p>这里有我写过的相关的系列的文章，欢迎系统阅读！<br>如果对你有任何问题，可以给我反馈</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本站说明</title>
      <link href="/2023/09/14/%E8%AF%B4%E6%98%8E/index/"/>
      <url>/2023/09/14/%E8%AF%B4%E6%98%8E/index/</url>
      
        <content type="html"><![CDATA[<p>本站的文章均为原创，本站的图片大部分由AIGC图像模型生成<br>可以在“系列文章”一栏中选择阅读你喜欢的文章，谢谢！<br>未来会持续更新 AI算法，AI模型，AIGC技术等<br>首发于CSDN平台，可以在CSDN上看到更多文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/2023/09/14/me/index/"/>
      <url>/2023/09/14/me/index/</url>
      
        <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><p>博主: Qodicat<br>AI算法应用爱好者<br>与世界大战三百回合不服输的少年~<br>喜欢探索美食，以及一切有趣充满活力的事物！<br>爱好跑步、羽毛球、滑板、游泳、读书、看电影、做美食、剪辑funny视频<br>喜欢可爱的小动物~</p><h3 id="a-bit-技能"><a href="#a-bit-技能" class="headerlink" title="a bit 技能"></a>a bit 技能</h3><p>Stable Diffusion,Midjourney等AIGC应用<br>AI算法，包括传统卷积神经网络，Transformer，扩散模型<br>模型微调，模型调参等<br>前端语言开发，嵌入式开发</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><p>云FPGA平台开发<br>星与安卓APP开发<br>Diana-Coding Vscode插件开发<br>社会实践队前端网页开发</p><h3 id="平台账号"><a href="#平台账号" class="headerlink" title="平台账号"></a>平台账号</h3><div style="display: flex;"><span class='btn center cool-2'><a class="button" href='https://github.com/QodiCat' title='Github'><i class='fa-brands fa-github-alt'></i>Github</a></span><span style="width:5px;"></span><span class='btn center cool-2'><a class="button" href='https://blog.csdn.net/Q52099999?spm=1010.2135.3001.5343' title='CSDN'><i class='fa-brands fa-CSDN'></i>CSDN</a></span></div><h3 id="我喜欢的一些书籍"><a href="#我喜欢的一些书籍" class="headerlink" title="我喜欢的一些书籍"></a>我喜欢的一些书籍</h3><div class="site-card-group"><a class="site-card" href="https://baike.baidu.com/item/%E9%9D%92%E9%93%9C%E8%91%B5%E8%8A%B1/8891559"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-52-17.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-52-17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《青铜葵花》</span><span class="desc">温暖了我一个冬天</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E7%A5%9E%E7%A7%98%E5%B2%9B/3094497?fromtitle=%E5%A4%96%E5%9B%BD%E6%96%87%E5%AD%A6%E5%90%8D%E8%91%97%EF%BC%9A%E7%A5%9E%E7%A7%98%E5%B2%9B&fromid=5685499"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/0151085c87ed81a801214168838477.jpg@1280w_1l_2o_100sh.jpg" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/0151085c87ed81a801214168838477.jpg@1280w_1l_2o_100sh.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《神秘岛》</span><span class="desc">凡尔纳yyds</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E8%8B%A6%E5%84%BF%E6%B5%81%E6%B5%AA%E8%AE%B0/80000"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-51-04.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-51-04.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《苦儿流浪记》</span><span class="desc">小时候读的印象最深的一本书</span></div></a><a class="site-card" href="https://zhuanlan.zhihu.com/p/150729443"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-53-54.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-53-54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《撒哈拉的故事》</span><span class="desc">只能说泰裤辣</span></div></a></div><h3 id="我喜欢的一些电影"><a href="#我喜欢的一些电影" class="headerlink" title="我喜欢的一些电影"></a>我喜欢的一些电影</h3><div class="site-card-group"><a class="site-card" href="https://baike.baidu.com/item/%E4%B8%89%E5%82%BB%E5%A4%A7%E9%97%B9%E5%AE%9D%E8%8E%B1%E5%9D%9E/27198"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-42-52.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-42-52.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">三傻大脑宝莱坞</span><span class="desc">打破刻板印象</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%BB%E5%8A%A8%E5%91%98/27212"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-43-44.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-43-44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">机器人总动员</span><span class="desc">暖心</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E9%A9%AF%E9%BE%99%E9%AB%98%E6%89%8B/10650780?fromModule=disambiguation"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-45-11.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-45-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">驯龙高手</span><span class="desc">可爱的宠物？</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E/5358"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-46-50.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-46-50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">让子弹飞</span><span class="desc">背后暗藏玄机</span></div></a></div><!-- ### 其他<div class="link-group"><div class="tagLink"><a class="link-card" title="项目一" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目一</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目二" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目二</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目三" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目三</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目四" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目四</p><p class="url">http://www.baidu.com</p></div></a></div></div> --><!-- ### 我的游戏<div class="gallery ">              <p><img src="https://pic2.zhimg.com/v2-abb2c12e9fbe8dda1993f7cd5d149159_b.jpg" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/v2-abb2c12e9fbe8dda1993f7cd5d149159_b.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="王者荣耀"><br><img src="https://pic2.zhimg.com/80/v2-980e050a09c4157e45bb8fdd419f9847_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-980e050a09c4157e45bb8fdd419f9847_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="和平精英"></p>            </div> --><h3 id="我的相册"><a href="#我的相册" class="headerlink" title="我的相册"></a>我的相册</h3><p>不定时掉落一些回忆</p><div class="tag-plugin post-swiper-container" width="fill"><div class="swiper-wrapper"><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">苏州~金鸡湖畔</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/479da3fd2ffb596b95aa2f411e94ca2.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">微软~Promt大会</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/81723041eb7fc632101661526fed932.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">讯飞星火~开发者会议</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/8d33b15cd9c08a8de1d30a96fe8d6b4.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">探索的好吃的！</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20231203-223736.jpg"></a></div></div><div class="swiper-pagination"></div><div class="swiper-button-prev blur"></div><div class="swiper-button-next blur"></div></div><h3 id="未来进行时"><a href="#未来进行时" class="headerlink" title="未来进行时"></a>未来进行时</h3><p>大学生活正在向前，进度条已经百分之60啦，冲冲冲！！！</p><div style="display: grid;  grid-template-columns: 50% 50%;  grid-template-rows: 30px 30px;  grid-column-gap: 20px"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-success"  style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"><p>完成时</p></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（八）ControlNet</title>
      <link href="/2023/07/24/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/8%20ControlNet/"/>
      <url>/2023/07/24/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/8%20ControlNet/</url>
      
        <content type="html"><![CDATA[<p>2023年的2月13日，一款名叫ControlNet的插件横空出世，AI绘画变得更加可控</p><p>ControlNet直译过来很简单，就叫做控制网，开发者是一名华裔，毕业于苏州大学，目前在斯坦福做读博士一年级，大佬大佬！</p><p>在controlNet之前，基于扩散模型的绘画是极为难控制的，平时自嗨画画其实没有一点问题，随机就随机一点，但是对于一些特定要求的岗位的同学来说，这种抽卡式缺乏稳定性的模型很难真正提高效率。</p><h1 id="1-ControlNet的作用结构"><a href="#1-ControlNet的作用结构" class="headerlink" title="1 ControlNet的作用结构"></a>1 ControlNet的作用结构</h1><p>​根据一些额外信息控制扩散生成走向，业内人士称为微调，通俗点说就是大模型你不是随机吗，那我给你一些指引信息，让你乖乖听话朝着我期望的方向走</p><p>​这时候有好奇的小伙伴就要问到了，那他和图生图有什么区别吗？我直接输入图片不也可以达到同样的效果吗？其实从某种意义上来说是的，但我举如下一个例子你就明白了</p><p>​比如我现在要生成一个有着特定姿势的图片，我固然可以通过一张自己期待的姿势的图片输入，模型可能会了解到这个姿势，但与此同时，这种图片除了姿势的其他信息如画面颜色，风格，人物特征也会被网络捕获到，因而就可能会产生意外的化学反应，但是用ControlNet可以提取人体关键点（如下图），这样的话模型只会了解到纯粹的需要生成的姿势而不会混杂其他信息，可控性就会增强了</p><h1 id="2-ControlNet的安装和使用"><a href="#2-ControlNet的安装和使用" class="headerlink" title="2 ControlNet的安装和使用"></a>2 ControlNet的安装和使用</h1><p>ControlNet本质是一个插件，所以类似于之前插件的安装（看之前的这篇插件安装的文章）</p><p>不同于一些插件，ControlNet还需要搭配不同的模型来使用，来实现特定的功能</p><p>最推荐的安装方式，是将ControlNet的扩展文件夹放在根目录下的extensions文件夹内，可以省下很多麻烦</p><p>然后在扩展选单里重新加载WebUI 界面，就可以在文生图和图生图里面看到了</p><p>下载一个ControlNet模型（一般是pth和yaml文件）之后移动到ControlNet的扩展文件夹中</p><h1 id="3-基本使用方式"><a href="#3-基本使用方式" class="headerlink" title="3 基本使用方式"></a>3 基本使用方式</h1><p>点开ControlNet控制网。输入一张图片，我们在这里期望输出的图片模仿我们输入图片的姿势</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913193208411.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913193208411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913193208411"></p><p>我们从网上找一张<img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/Snipaste_2023-09-13_19-40-39.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/Snipaste_2023-09-13_19-40-39.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Snipaste_2023-09-13_19-40-39" style="zoom:50%;" />图片上传</p><p>选择预处理器（OpenPose就是提取姿势的），并选择相应的模型</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913194602605.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913194602605.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913194602605"></p><p>其他参数先维持不变</p><p>加入我们期望的场景提示词，如在森林里</p><blockquote><p>1 cute girl, forest, smile,<br>SFW, (masterpiece:1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2)</p></blockquote><p>生成<img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00228-2167140323-1%20cute%20girl,%20forest,%20smile,%20_SFW,%20(masterpiece_1.2),%20best%20quality,%20masterpiece,%20highres,%20original,%20extremely%20detailed%20wallpaper,.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00228-2167140323-1%20cute%20girl,%20forest,%20smile,%20_SFW,%20(masterpiece_1.2),%20best%20quality,%20masterpiece,%20highres,%20original,%20extremely%20detailed%20wallpaper,.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00228-2167140323-1 cute girl, forest, smile, _SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper,"></p><p>更改一下提示词</p><blockquote><p>1 cute girl, city, smile,<br>SFW, (masterpiece:1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2)</p></blockquote><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00236-1319366320-1%20cute%20girl,%20city,%20smile,%20white%20coat_SFW,%20(masterpiece_1.2),%20best%20quality,%20masterpiece,%20highres,%20original,%20extremely%20detailed%20wa.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00236-1319366320-1%20cute%20girl,%20city,%20smile,%20white%20coat_SFW,%20(masterpiece_1.2),%20best%20quality,%20masterpiece,%20highres,%20original,%20extremely%20detailed%20wa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00236-1319366320-1 cute girl, city, smile, white coat_SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wa"></p><p>可以看出姿势完全不变</p><p>同时它还会附加给我们一张骨骼图</p><p><img src="http://127.0.0.1:6006/file=/tmp/tmpk7lwq82o.png" class="lazyload placeholder" data-srcset="http://127.0.0.1:6006/file=/tmp/tmpk7lwq82o.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="3-1-参数详解"><a href="#3-1-参数详解" class="headerlink" title="3.1 参数详解"></a>3.1 参数详解</h2><p><strong>Control Weight</strong></p><p>决定这个控制效应在图片中呈现出来的强度，维持默认1不变</p><p><strong>Starting Control step</strong> </p><p><strong>ending Control step</strong> </p><p>什么时候加入ControlNet影响，默认的0到1表示全程生效，缩短影响，可以赋予图像更多的自由度</p><p><strong>ControlMode</strong></p><p>提示词影响和ControlNet之间倾向于哪一个，一般维持默认Balanced即可，二者兼顾</p><p>核心就是控制强弱</p><p><strong>缩放模式</strong></p><p>会在导入图片和你生成图片分辨率不匹配的时候起作用</p><h2 id="3-2-代表性ControlNet模型应用"><a href="#3-2-代表性ControlNet模型应用" class="headerlink" title="3.2 代表性ControlNet模型应用"></a>3.2 代表性ControlNet模型应用</h2><h3 id="3-2-1-Open-Pose姿态"><a href="#3-2-1-Open-Pose姿态" class="headerlink" title="3.2.1 Open Pose姿态"></a>3.2.1 Open Pose姿态</h3><p>上面讲到的只是OpenPose的基本的身体整体骨骼的刻画</p><p>选择不同的预处理器可以获得对手部，脸部更精确的刻画</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913200558559.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913200558559.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913200558559"></p><p>比如我们使用openpose_face,可以看到获得了更精细的脸部特征骨骼图</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/tmpbpgj9ukv%20(1).png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/tmpbpgj9ukv%20(1).png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="tmpbpgj9ukv (1)"></p><h3 id="3-2-2-Depth-深度"><a href="#3-2-2-Depth-深度" class="headerlink" title="3.2.2 Depth 深度"></a>3.2.2 Depth 深度</h3><p>适合富有空间感的多层次场景</p><h3 id="3-2-3-canny-边缘检测"><a href="#3-2-3-canny-边缘检测" class="headerlink" title="3.2.3 canny 边缘检测"></a>3.2.3 canny 边缘检测</h3><p>通过边缘来进行绘画输出，超级强大！！！</p><p>比如我们这里用Canny检测器，可以生成几乎一模一样的</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913201834850.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913201834850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913201834850"></p><p>可以实现线稿上色</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913202412411.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230913202412411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913202412411"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（七）扩展插件</title>
      <link href="/2023/07/22/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/7%20%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/07/22/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/7%20%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Stable diffusion的开源生态为各种各样的辅助插件的开发提供了极大的便利，而这些辅助插件又可以为我们AI作画提供极大的便捷</p><h1 id="1-插件界面介绍"><a href="#1-插件界面介绍" class="headerlink" title="1 插件界面介绍"></a>1 插件界面介绍</h1><p>Extensions 在扩展一栏</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905174839326.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905174839326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905174839326"></p><p>三个installed  (已安装) Available （可用的）install from URL 从URL安装</p><p>如果是自己安装的sd，很可能刚开始的时候installed里面只有一些必要的插件，但是如果是一些大佬的整合包，则已经自带了一些插件</p><h1 id="2-插件安装方式"><a href="#2-插件安装方式" class="headerlink" title="2 插件安装方式"></a>2 插件安装方式</h1><p>1 Available（可用的插件）这里作者会把一些常用的插件记录在一个地址中，点击Load from，则可以加载出一系列详细的扩展应用清单</p><p>2 链接安装，复制代码仓库的地址，再点击安装也能实现一键安装</p><p>3 但上面两种方式都是借助git，因而可能会不稳定，所以还有最后一种方式，直接下扩展插件的代码包，然后送到Stable-diffusion根目录下的extensions文件夹里，然后点击应用并重启用户界面即可</p><h1 id="3-新手插件"><a href="#3-新手插件" class="headerlink" title="3 新手插件"></a>3 新手插件</h1><h2 id="3-1-中文本地化语言包"><a href="#3-1-中文本地化语言包" class="headerlink" title="3.1 中文本地化语言包"></a>3.1 中文本地化语言包</h2><p>​搜索栏里搜索 zh</p><h2 id="3-2-图库浏览器-image-browser"><a href="#3-2-图库浏览器-image-browser" class="headerlink" title="3.2 图库浏览器  image browser"></a>3.2 图库浏览器  image browser</h2><p>​有很多功能如收藏夹，筛选，查看图片信息等等</p><p>​    链接<a href="https://github.com/yfszzx/stable-diffusion-webui-images-browser">https://github.com/yfszzx/stable-diffusion-webui-images-browser</a></p><h2 id="3-3-提示词自动补全-tag-autocompletion"><a href="#3-3-提示词自动补全-tag-autocompletion" class="headerlink" title="3.3 提示词自动补全  tag autocompletion"></a>3.3 提示词自动补全  tag autocompletion</h2><p>​链接<a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git"> https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git</a></p><p>  （1）他可以告诉我们AI可以更好理解的一些提示词</p><p>比如我们这里，输入one girl 这时候他下边自动提示1girl的写法，点击换用1girl会更好</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905175245286.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905175245286.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905175245286"></p><p>（2）可以快速补全各类模型名称</p><p>我们知道一些embeddings，lora模型需要特定提示词才能激活，但是那些提示词可能又臭又长记不住，怎么办，提示词插件来咯</p><p>输入：</p><ul><li><code>&lt;e:</code> 会展示 embeddings 名字</li><li><code>&lt;l:</code> 或者<code>&lt;lora:</code> 会展现 Lora 名字</li><li><code>&lt;h:</code> 或者<code>&lt;hypernet:</code> 会展现可选的 Hypernetworks</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905175526580.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905175526580.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905175526580"></p><h2 id="3-4-Tagger-提示词反推插件"><a href="#3-4-Tagger-提示词反推插件" class="headerlink" title="3.4 Tagger 提示词反推插件"></a>3.4 Tagger 提示词反推插件</h2><p>链接 <a href="https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git">https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git</a></p><p>上传图片，选择反推算法，一般维持默认即可，点击开始反推</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905180334053-1693910444141.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230905180334053-1693910444141.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905180334053"></p><p>使用完后，点击卸载显存中所有反推模型</p><h2 id="3-5-Prompt-all-in-one"><a href="#3-5-Prompt-all-in-one" class="headerlink" title="3.5 Prompt-all-in-one"></a>3.5 Prompt-all-in-one</h2><p> Prompts 神器，它提供了自动翻译、历史记录和收藏等功能，支持多种语言，满足不同用户的需求。对英文不熟悉的用户，使用它，再也不用在翻译软件和SD之间反复横跳了。</p><h1 id="4-进阶扩展"><a href="#4-进阶扩展" class="headerlink" title="4 进阶扩展"></a>4 进阶扩展</h1><h2 id="4-1提升画质"><a href="#4-1提升画质" class="headerlink" title="4.1提升画质"></a>4.1提升画质</h2><h3 id="Ultimate-Upscale-无损放大脚本"><a href="#Ultimate-Upscale-无损放大脚本" class="headerlink" title="Ultimate Upscale 无损放大脚本"></a>Ultimate Upscale 无损放大脚本</h3><p>​类似于SD 自带的放大，把图片拆成不同的块去放大</p><h3 id="local-latent-Couple-局部隐空间"><a href="#local-latent-Couple-局部隐空间" class="headerlink" title="local latent Couple  局部隐空间"></a>local latent Couple  局部隐空间</h3><p>​可以进行一些细节局部修饰，重新绘制</p><h2 id="4-2-提示词"><a href="#4-2-提示词" class="headerlink" title="4.2 提示词"></a>4.2 提示词</h2><h3 id="cutoff-解决提示词之间的相互干预"><a href="#cutoff-解决提示词之间的相互干预" class="headerlink" title="cutoff 解决提示词之间的相互干预"></a>cutoff 解决提示词之间的相互干预</h3><p>​比如我们想让女生穿一个红色裙子，但是忽然发现红色到了帽子上等等其他地方</p><h2 id="4-3-视频制作"><a href="#4-3-视频制作" class="headerlink" title="4.3 视频制作"></a>4.3 视频制作</h2><h3 id="infinite-zoom-无限放大扩展"><a href="#infinite-zoom-无限放大扩展" class="headerlink" title="infinite zoom 无限放大扩展"></a>infinite zoom 无限放大扩展</h3><p>​可以将图片无限延伸成为视频</p><h3 id="Deforum"><a href="#Deforum" class="headerlink" title="Deforum"></a>Deforum</h3><p>最近大火的可以将图片转出视频的插件，</p><h2 id="4-4-精准绘图"><a href="#4-4-精准绘图" class="headerlink" title="4.4 精准绘图"></a>4.4 精准绘图</h2><p> 骨架等识别</p><p> 3d-open-pose-editor插件</p><p> Openpose-editor（骨架编辑）</p><p>用来编辑人体骨架，可以从已有照片中自动检测生成。结合controlnet，可以生成指定姿势的人物。可以大大提高出图的可控性。</p><h2 id="4-5-抠图神器"><a href="#4-5-抠图神器" class="headerlink" title="4.5 抠图神器"></a>4.5 抠图神器</h2><p>Segment-anything（抠图神器）</p><h1 id="5-自身内置"><a href="#5-自身内置" class="headerlink" title="5 自身内置"></a>5 自身内置</h1><p><strong>X&#x2F;Y plot &amp; Prompt matrix</strong></p><p>prompt matrix和x&#x2F;y plot多用于演示,都是生成一个有好几张图组成的多格图、当你想要对比一个或多个词(艺术风格、人物细节描述等等)对最后图片的影响(prompt matrix的使用场景)亦或是一个或多个参数的不同值下(不同扩散次数、不同cfg值等等)生成的不同图片对比结果(x&#x2F;y plot的使用场景)</p><p><a href="https://zhuanlan.zhihu.com/p/637138476">【基础篇 第五课】Stable Diffusion 出图必备脚本神器 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（五）高清作图、高清修复</title>
      <link href="/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/5%20%E9%AB%98%E6%B8%85%E4%BD%9C%E5%93%81%E4%BA%A7%E5%87%BA/"/>
      <url>/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/5%20%E9%AB%98%E6%B8%85%E4%BD%9C%E5%93%81%E4%BA%A7%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>如何优化出图质量，产出更高清，分辨率更高，更有细节的绘画作品呢？</p><p>之前为了提高绘画质量，我们学习了诸多的提示词，选用了更优的模型</p><p>同时我们了解到，越高的分辨率意味着模型有着更大的发挥空间，细节会更好，但是受限于直接放大图片分辨率产生的多头多脚的问题，同时大的分辨率可能会直接爆显存，那么我们该怎么办呢</p><p>本节我们了解更多的放大算法，使得AI画出的图更加有质感</p><p>涉及方法主要有：</p><p><strong>高分辨率修复</strong></p><p><strong>Upscale脚本</strong></p><p><strong>附加功能中的图片放大算法</strong></p><p>他们各有优缺点</p><p>我们首先生成一张原图</p><p>输入正向提示词</p><blockquote><p>cinematic photo official art,unity 8k wallpaper,ultra detailed,aesthetic,masterpiece,best quality,photorealistic,entangle,mandala,tangle,entangle,1girl,cowboy shot,ecstasy of flower,dynamic angle,the most beautiful form of chaos,elegant,a brutalist designed,vivid colours,romanticism,atmospheric . 35mm photograph, film, bokeh, professional, 4k, highly detailed, skin detail realistic, ultra realistic, long hair, straight hair, eyes detail</p></blockquote><p>输入反向提示词</p><blockquote><p>(worst quality:1.5), (low quality:1.5), (normal quality:1.5), lowres, bad anatomy, bad hands, multiple eyebrow, (cropped), extra limb, missing limbs, deformed hands, long neck, long body, (bad hands), signature, username, artist name, conjoined fingers, deformed fingers, ugly eyes, imperfect eyes, skewed eyes, unnatural face, unnatural body, error, painting by bad-artist<br>layman work, worst quality, ugly, (deformed|distorted|disfigured:1.21), poorly drawn, bad anatomy, wrong anatomy, mutation, mutated, (mutated hands AND fingers:1.21), bad hands, bad fingers, loss of a limb, extra limb, missing limb, floating limbs, amputation, Yaeba, photo, deformed, black and white, realism, disfigured, low contrast, long neck</p></blockquote><p>初始分辨率设置为了640*704</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/%E5%8E%9F%E5%9B%BE.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/%E5%8E%9F%E5%9B%BE.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="原图" style="zoom:50%;" /><p>#1 高清修复</p><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>先绘制一份低分辨率的图像</p><p>再根据它重绘第二幅高分辨率的图像</p><h2 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h2><p>先在低分辨率的情况下反复抽卡尝试，有满意的图之后，固定随机种子，进行高分辨率修复</p><p>（1）查看图片随机种子，填入种子栏</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823110407249.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823110407249.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110407249"></p><p>（2）在文生图界面出图设置栏勾选高清修复</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823110504309.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823110504309.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110504309"></p><p>勾选高清修复后会出现两行新的参数设置</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823110812405.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823110812405.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110812405"></p><p>（3）出图参数设置</p><p><strong>1 放大算法</strong>  将低分辨率打回重画的方法，这里我们一般对于二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>2 高清修复采用次数</strong>   维持0不变即可，意味着和原图采样次数一样是20 </p><p><strong>3 重绘幅度</strong>  等图于图生图里的重绘幅度，和原图有多像，一般维持在0.5以下</p><p><strong>4  尺寸设置</strong> 将图片由原始的分辨率放大到多少，</p><p>​放大倍率就是放大几倍</p><p>点击 出图如下</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/%E9%AB%98%E6%B8%85%E4%BF%AE%E5%A4%8D.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/%E9%AB%98%E6%B8%85%E4%BF%AE%E5%A4%8D.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="高清修复" style="zoom:33%;" /><p>比较一下 细节</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823111953209.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823111953209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823111953209" style="zoom:67%;" /><h2 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h2><p>优点</p><p>​（1）不会改变画面构图，由随机种子固定即可</p><p>​（2）操作简单</p><p>​（3）稳定克服多人，多头情况</p><p>缺点</p><p>​（1）仍然需要较大的显存，而且能画多大依然受到显存的限制</p><p>​（2）计算速度相对较慢，，耗费较长时间</p><h1 id="2-UpScale-放大脚本"><a href="#2-UpScale-放大脚本" class="headerlink" title="2 UpScale 放大脚本"></a>2 UpScale 放大脚本</h1><p>第一种方法依然受到显存限制，所以但这种方法就不受影响啦</p><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>​将图片打成不同块，每一块分别绘制</p><h2 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h2><p>这是属于图生图的功能</p><p>​这里有一个小技巧，点击图片预览下方的图生图，可以把刚刚文生图生成的图片移动到图生图，同时各种参数设置，提示词，模型都会复制一份</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823211634513.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823211634513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823211634513"></p><p>​（1）点击脚本一栏，选择使用SD放大</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823102859699.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823102859699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823102859699"></p><p>（2）参数设置</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823212157442.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823212157442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212157442"></p><p><strong>1 放大算法</strong> 我们选择和1高清修复一样的即可，二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>2 图块重叠的像素</strong>，原理部分我们讲到，UpScale 是通过打成不同的块进行的，因而块与块之间要缝合需要一定的像素过渡，一般维持默认64即可</p><p><strong>3 缩放系数</strong> 将图片由原始的分辨率放大到多少倍</p><p>点击生成</p><p>比较一下细节</p><p><strong><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823212328217.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823212328217.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212328217" style="zoom: 50%;" /></strong></p><h2 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h2><p>优点</p><p>​（1）可以突破内存限制，获得更大的分辨率，速度较快</p><p>​（2）画面精度更高</p><p>缺点</p><p>​（1）分割过程较为不可控</p><p>​（2）操作比较繁琐</p><h1 id="3-附加功能放大"><a href="#3-附加功能放大" class="headerlink" title="3 附加功能放大"></a>3 附加功能放大</h1><p>用于图片后期处理</p><p>用于两种算法放大</p><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>附加功能的放大，相当于重绘幅度为0的Upscale</p><h2 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h2><p>这里也有一个小技巧，点击图片预览下方的添加到附加功能，可以把刚刚文生图生成的图片移动到附加功能一栏中，同时各种参数设置，提示词，模型都会复制一份</p><p>（1）参数设置</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823212634383.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823212634383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212634383"></p><p><strong>1 缩放比例</strong>  将图片由原始的分辨率放大到多少倍</p><p><strong>2 Upscale1</strong> ，放大算法 同上面讲到的，一般对于二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>3 其他设置</strong>  Upscale2  可见度什么的维持默认即可</p><p>点击生成</p><p>比较一下细节</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823213027789.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230823213027789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823213027789"></p><h2 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h2><p> 优点</p><p>​（1）简单，方便，计算快</p><p>​（2）完全不改变图片内容</p><p>缺点</p><p>​（1）细节上不如前两种方法</p><p><a href="https://zhuanlan.zhihu.com/p/623014034">AI绘画教程：如何在stable diffusion中生成高清大图？ - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（六）局部重绘</title>
      <link href="/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/6%20%E5%B1%80%E9%83%A8%E9%87%8D%E7%BB%98/"/>
      <url>/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/6%20%E5%B1%80%E9%83%A8%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<p>之前我们熟悉了AI绘画的各类模型，提示词写法，图像放大等技巧。但我们目前所有的操作都是针对整张图片的。</p><p>但是我们有些时候会遇到这样一种情况，就是我们生成的图片整体满意，但是一些细节，如手部绘画不满意，这时候该怎么办呢？打回炉子重新画一遍吗？</p><p>这样可能会面临的一个问题是</p><p>（1）如果本身AI绘画的分辨率比较高，那么意味着再画一次需要很长时间</p><p>（2）更重要的是，增加我们想要的提示词，对提示词做改变后，画面内容可能发现较大的变化</p><p>因而，用我们今天的局部重绘功能就可以很好解决这个问题啦</p><p>当然局部重绘还有更多的发挥空间</p><p>​如删除画面中自己不想要的物品，人物，增添自己想要的人物等等……</p><p>局部重绘是图生图的下属功能</p><h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h1><p>首先在文生图生成一张图片</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00160-1889848896-A%20beautiful%20girl%20blows%20a%20bubble,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemat.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00160-1889848896-A%20beautiful%20girl%20blows%20a%20bubble,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemat.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00160-1889848896-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat"></p><p>点击图库浏览器里或浏览图下方的局部重绘按钮，就可以跳转到图生图的局部重绘功能</p><h2 id="1-1-步骤1-补充提示词"><a href="#1-1-步骤1-补充提示词" class="headerlink" title="1.1 步骤1 补充提示词"></a>1.1 步骤1 补充提示词</h2><p>局部重绘也依然需要提示词</p><p>比如我们想在这个的基础上让这个女生戴一个帽子，那么我们就要在正向提示词里加上(a hat:1.4) 同时这里一定要给一定的权重加强1.4   否则就不能正常的展示效果<img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902114649762.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902114649762.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902114649762"></p><h2 id="1-2-步骤2-绘制蒙版"><a href="#1-2-步骤2-绘制蒙版" class="headerlink" title="1.2 步骤2 绘制蒙版"></a>1.2 步骤2 绘制蒙版</h2><p>蒙版是什么呢？就是要通过蒙版选定区域告诉模型我们要对哪些区域做处理</p><p>用黑色的画笔在图像上画黑色的蒙版</p><p>右上角画笔一样的按钮<strong>可以调整画笔粗细</strong></p><p>圆圈表示 重新画蒙版</p><p>叉号表示关闭当前图像</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230825163450914.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230825163450914.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230825163450914"></p><p>在这里我们要给女生重新加一个帽子，</p><p>需要让模型重新绘制头部上方，因而我们用模板把头部上方画一画即可</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902114938059.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902114938059.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902114938059"></p><h2 id="1-3-步骤3-参数设置"><a href="#1-3-步骤3-参数设置" class="headerlink" title="1.3 步骤3 参数设置"></a>1.3 步骤3 参数设置</h2><p><strong>重绘幅度</strong>在0.7到0.8之间</p><p><strong>蒙版模糊</strong></p><p>局部重绘使用的就是蒙版来确定绘图的区域，如果只改变蒙版内或者蒙版外的内容，那么边缘处就会突变，很不协调，所以蒙版模糊可以理解成PS中的羽化，用来控制蒙版过渡效果，越大过渡越平滑。</p><p>设置10以下的模糊可以让重绘区域拼接进去更加丝滑</p><p><strong>蒙版模式</strong>  </p><p>选重绘蒙版内容，则会重新绘制黑色蒙版画住的</p><p>选重绘非蒙版内容，就是会重新绘制黑色区域画住以外区域的</p><p><strong>蒙版蒙住的内容</strong> 可以理解为把蒙版交给模型时候的内容</p><p>选原图的话采用原图作为重绘底图，通常选这个就好，AI模型发挥空间较小，会比较遵循原图</p><p>选填充，用蒙版边缘像素填充作为重绘底图，则会让AI模型有较大的发挥空间  ，可以综合对比几种方式</p><p><strong>重绘区域</strong></p><p>选仅蒙版 涉及区域小，绘制速度更快，但由于没有读取全貌，有些时候出图会比较奇怪</p><p>选全图，整张输入</p><p>一般情况建议重绘全图</p><p><strong>边缘预留像素</strong>    充当缓冲带作用，可以让新生成的内容与原图更好的融合在一起（一般25-35就行）</p><p>其他设置基于与文生图内操作一致，选择采样方式、迭代步数等，这里建议在使用局部重绘时，要选择与原图一致的设置，从而可以确保重绘效果。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902115002095.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902115002095.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902115002095"></p><p>点击生<img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00154-1538941015-A%20beautiful%20girl%20blows%20a%20bubble,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemat.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00154-1538941015-A%20beautiful%20girl%20blows%20a%20bubble,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemat.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00154-1538941015-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat">成</p><h1 id="2-局部重绘其他应用"><a href="#2-局部重绘其他应用" class="headerlink" title="2.局部重绘其他应用"></a>2.局部重绘其他应用</h1><h2 id="2-1-手绘蒙版"><a href="#2-1-手绘蒙版" class="headerlink" title="2.1 手绘蒙版"></a>2.1 手绘蒙版</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902123316514.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902123316514.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902123316514"></p><p>和第1节讲到的局部重绘类似，不同的是，会融入颜色信息</p><p>可以通过颜色选择器可以选取颜色</p><p>我们这里选取红色，给女生画一个红色的帽子</p><p>这里和第1节的提示词，参数设置都一样，就是选取了红色绘制蒙版而已</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902123616396.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902123616396.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902123616396"></p><p>点击生成</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00155-2457917830-A%20beautiful%20girl%20blows%20a%20bubble,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemat.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00155-2457917830-A%20beautiful%20girl%20blows%20a%20bubble,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemat.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00155-2457917830-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat"></p><h2 id="2-2-删除某些东西"><a href="#2-2-删除某些东西" class="headerlink" title="2.2 删除某些东西"></a>2.2 删除某些东西</h2><p>只需要将我们想要删除的东西用蒙版画好</p><p>然后在负面提示词里增加删除的东西</p><p>比如我们想让这个女生摘掉眼镜</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00179-17401323-A%20beautiful%20girl,%20Wear%20glasses,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemati.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00179-17401323-A%20beautiful%20girl,%20Wear%20glasses,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinemati.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00179-17401323-A beautiful girl, Wear glasses, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemati"></p><p>负面提示词里加 戴眼镜</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902153701635.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902153701635.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902153701635"></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902153720702.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230902153720702.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902153720702"></p><p>点击生成</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00158-1817286803-A%20beautiful%20girl,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinematic%20sensual,%20Sha.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00158-1817286803-A%20beautiful%20girl,%20(Studio%20ghibli%20style,%20Art%20by%20Hayao%20Miyazaki_1.2),%20Anime%20Style,%20Manga%20Style,%20Hand%20drawn,%20cinematic%20sensual,%20Sha.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00158-1817286803-A beautiful girl, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinematic sensual, Sha"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（四）图生图</title>
      <link href="/2023/07/20/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/4%20%E5%9B%BE%E7%94%9F%E5%9B%BE/"/>
      <url>/2023/07/20/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/4%20%E5%9B%BE%E7%94%9F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>前段时间有一个风靡全网的真人转漫画风格，受到了大家的喜欢</p><p>而在SD里，就可以通过图生图来实现类似的效果</p><p>当然图生图还有更好玩的应用，我们一点一点来探索</p><p>首先我们来简单进行一下图生图的这一个实践—真人转动漫</p><h2 id="1-图生图基本界面"><a href="#1-图生图基本界面" class="headerlink" title="1. 图生图基本界面"></a>1. 图生图基本界面</h2><p>和文生图基本界面差不多，多了一个上传图像区</p><h2 id="2-图生图步骤"><a href="#2-图生图步骤" class="headerlink" title=" 2.图生图步骤"></a><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230817104804853.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230817104804853.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230817104804853"> 2.图生图步骤</h2><h3 id="2-1-导入图片"><a href="#2-1-导入图片" class="headerlink" title="2.1 导入图片"></a>2.1 导入图片</h3><p>准备一张真人图像</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/Snipaste_2023-08-18_22-20-40.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/Snipaste_2023-08-18_22-20-40.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Snipaste_2023-08-18_22-20-40"></p><p>导入有两种方式</p><p>（1）点击上传图像区，打开资源管理器选取</p><p>（2）直接将图片拖拽到上传图像区</p><h3 id="2-2-写提示词"><a href="#2-2-写提示词" class="headerlink" title="2.2 写提示词"></a>2.2 写提示词</h3><p>提示词很重要，也需要提示词的准确</p><p>用自然语言描述一下我们的画面内容，一开始我们可以偷个懒，就写一个</p><blockquote><p>1man即可</p></blockquote><p>再把我们的固定模板加上</p><blockquote><p>正面提示词后添加：<br>SFW, (masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</p></blockquote><blockquote><p>负面提示词后添加：<br>NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</p></blockquote><h3 id="2-3参数设置"><a href="#2-3参数设置" class="headerlink" title="2.3参数设置"></a>2.3参数设置</h3><p> 图生图参数设置和文生图差不多</p><p>有一个比较独特的就是下面的重绘幅度</p><p><strong>重绘幅度</strong>  ，通俗理解就是他跟原图有多像</p><p>一般我们为了实现这种图生图效果，会降低一些重绘幅度，维持在6-8之间即可，太低或太高都不太好</p><p><strong>图像设置宽高</strong>，一般和我们输入图像大小保持一致</p><p>​如果输入图像太大，显存吃不消，那么我们至少保证比例一致，比如原图是3000*3000像素，那么我们就等比例缩放到1024 *1024</p><p>采样方法选择DPM++2Mkarras</p><p>其他选择和图生图一样，可以维持默认不变</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230818224818756.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230818224818756.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818224818756"></p><p>点击生成就可以生成</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/123.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="123"></p><p>但是发现差别还是蛮大的，原因是我们内容提示词对人物描述不够</p><p>我们把1man 换成 1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,short hair,Blue jeans</p><p>多了更多的服饰，面部细节等的描述，再点击生成</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00062-262499971-1man,Stay%20in%20sunglasses,%20short%20beard,put%20%20hands%20in%20pants%20pockets,,sit%20by%20the%20window,outdoors,%20%20looking%20at%20viewer,shirt,suits,sho.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00062-262499971-1man,Stay%20in%20sunglasses,%20short%20beard,put%20%20hands%20in%20pants%20pockets,,sit%20by%20the%20window,outdoors,%20%20looking%20at%20viewer,shirt,suits,sho.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00062-262499971-1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,sho"></p><p>整体会好多了</p><h2 id="3-巧用随机种子"><a href="#3-巧用随机种子" class="headerlink" title="3. 巧用随机种子"></a>3. 巧用随机种子</h2><p>如果我们对这个人物整体很满意了，但是一些细节还想微调，我们就要用到随机种子了</p><p>在图片生成区下方，可以查看随机种子</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230818230647705.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230818230647705.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818230647705"></p><p>然后把我们的随机种子从-1改为262499971</p><p>这时候我们点击生成，会发现生成的图片几乎和之前的一模一样，不论你点多少次</p><p>然后这时候我们对自己不满意的提示词进行微调，如让男主穿牛仔裤，看向镜头等，再点击生成即可</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00074-262499971-1man,(Blue%20jeans_1.1),(black%20suits_1.1),Stay%20in%20sunglasses,%20short%20beard,put%20%20hands%20in%20pants%20pockets,,sit%20by%20the%20window,outdoors,-1692515162052.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00074-262499971-1man,(Blue%20jeans_1.1),(black%20suits_1.1),Stay%20in%20sunglasses,%20short%20beard,put%20%20hands%20in%20pants%20pockets,,sit%20by%20the%20window,outdoors,-1692515162052.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00074-262499971-1man,(Blue jeans_1.1),(black suits_1.1),Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,"></p><h2 id="4-拓展应用"><a href="#4-拓展应用" class="headerlink" title="4. 拓展应用"></a>4. 拓展应用</h2><p> 动漫转真人，真人转动漫都是比较好玩的</p><p>当然除了这些，我们还可以把一张本来不是真人的物体，用真人的提示词去进行拟人化</p><p>除此之外还可以</p><p>将随机涂鸦的场景转换为好看的动漫风格图片</p><p>其他关于图生图进阶用法，我们会在另外的文章里讲到</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（三）AI绘画模型基础</title>
      <link href="/2023/07/18/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/3%20%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/07/18/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/3%20%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>想要做出好的AI绘画，模型是最重要的，他相当于AI绘画的大脑，决定了AI绘画质量的上限，所以了解AI绘画的各种模型非常重要</p><p>相比于Midjourney，Stable Diffusion<strong>最大的优势就是开源</strong>。</p><p>因而<strong>SD则每时每刻都有人在世界各地训练自己的模型并免费公开共享给全世界的使用者</strong>。当然我们也可以训练自己的专属模型</p><p>提示词+模型+参数设置</p><p>全能型赛博画手</p><p>首先我们来了解一下模型的基本分类</p><h2 id="1-模型基本分类"><a href="#1-模型基本分类" class="headerlink" title="1.模型基本分类"></a>1.模型基本分类</h2><p>具体模型类型有checkpoint、Textual lnversion、Hypernetwork、Aesthetic Gradient、LoRA、LyCORIS、Controlnet、Poses、wildcards等等</p><p>常用的有checkpoint</p><p>哇塞，这么多，那么这些究竟都是什么意思呢？</p><h3 id="1-1-CheckPoint-大模型-底模型-主模型"><a href="#1-1-CheckPoint-大模型-底模型-主模型" class="headerlink" title="1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型"></a>1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型</h3><p>检查点，常玩游戏的朋友肯定不陌生，一般会在一些节点存档</p><p>一个大的模型训练起来是非常费力的，如果每次迭代我们都从头训练那可真实个灾难，因而训练到一定程度我们就给模型存档，生成一个关键点Checkpoint模型，</p><p><strong>常见文件后缀</strong>:后缀ckpt、safetensors（如果都有提供的话建议下载safetensors，下同）</p><p><strong>存放路径</strong>: 根目录\models\Stable-diffusion</p><p><strong>占用存储：</strong> 模型较大，占用3-7GB</p><p>我们这里的根目录都是指我们<strong>webui的最外层的那个文件夹，比如我这里的是stable-diffusion-webui</strong></p><p><strong>使用方法</strong>  将模型移动到根目录\models\Stable-diffusion后，在webui界面点击刷新按钮，再点下拉就可以看到了</p><p><img src="/img%5CStable_diffusion%5Cimage-20230819103854526.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819103854526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819103854526"></p><p>模型推荐</p><p>二次元模型</p><p>​ menia mix  生成动漫</p><p>​AbyssOrangeMix 深源橘</p><p>​counter-feit v2.5  动漫模型</p><p>​dream Shper v5  模型   肖像画 梦幻的插画风格</p><p>真实系模型</p><p>​realistic vision v2.0 现实模型</p><p>​Delibe-rate   比较全能的一个模型</p><p>在本章第二节可以看到如何利用其他网站来筛选自己需要的模型</p><h3 id="1-2-VAE美化模型-变分自编码器"><a href="#1-2-VAE美化模型-变分自编码器" class="headerlink" title="1.2 VAE美化模型&#x2F;变分自编码器"></a>1.2 VAE美化模型&#x2F;变分自编码器</h3><p>从使用来看，我们可以把他粗略的理解为“调色滤镜”  有些时候不加载VAE的情况下，出图就会发灰发白</p><p>有很多比较新的大模型是会将VAE整合到内部的，比如Chilloutmix。如果再加VAE则可能画面效果不会更好，甚至适得其反</p><p>而有的大模型则会有自己适配的VAE，如深渊橘，这里看模型网站上作者的推荐就好</p><p>也有一些适用于大多数模型的VAE</p><p>二次元风格：kf-f8-anime</p><p>写实风格:840000</p><p><strong>常见文件后缀</strong>:后缀ckpt、pt</p><p><strong>存放路径</strong>: 根目录&#x2F;models&#x2F;VAE</p><p><strong>占用存储：</strong> 模型较小，占用0-1个GB</p><p><strong>使用方法</strong>  将模型移动到根目录\models\VAE后，在VAE选项点击刷新按钮，再点下拉就可以看到了</p><h3 id="1-3-HyperNetwork-超网络"><a href="#1-3-HyperNetwork-超网络" class="headerlink" title="1.3 HyperNetwork 超网络"></a>1.3 HyperNetwork 超网络</h3><p>hypernetworks是一个附加到stable diffusion model上的小型网络，用于微调，和embedings类似，不过现在用的也不是很多了，因为它的功能基本可以被smbeddings替代了</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;models&#x2F;hypernetworks</p><p><strong>占用存储：</strong> 模型较小，占用几百MB</p><p><strong>使用方法</strong>  注意HyperNetwork，embeddings这种微调网络和大模型使用方法不同</p><p>（1）将模型放到  根目录&#x2F;models&#x2F;hypernetworks</p><p>（2）首先点击生成按钮下的从左往右数的第三个，然后点击超网络，再点击需要用到的超网络模型，就会在提示词中添加相应的尖括号内容，如本例中的<hypernet></p><p><img src="/img%5CStable_diffusion%5Cimage-20230820103415473.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820103415473.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820103415473"></p><h3 id="1-4-embeddings（-Textual-Inversion）-嵌入式向量"><a href="#1-4-embeddings（-Textual-Inversion）-嵌入式向量" class="headerlink" title="1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量"></a>1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量</h3><p>（1）优化画风,</p><p>（2）通过仅使用的几张图像，向模型教授新的概念，比如AI不知道奥特曼，通过embeddigns就可以让AI知道奥特曼长什么样子</p><p>（3）减少提示词的输入，比如EasyNegative这个Embeddings，里面包含了大量的负面词，可以减少你每次打一堆负面词的痛苦，解决AI绘画痛点，如画手等等</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p>模型的切换通过文件名称来触发</p><p><strong>占用存储：</strong> 模型很小，占用几十kB到几百kB</p><p><strong>使用方法:</strong></p><p>（1）将模型放到  根目录&#x2F;embeddings目录下</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击嵌式入，再点击需要用到的嵌入式模型，就会在提示词中添加相应的尖括号内容</p><h3 id="1-5-loRa-低秩适应模型"><a href="#1-5-loRa-低秩适应模型" class="headerlink" title="1.5 loRa 低秩适应模型"></a>1.5 loRa 低秩适应模型</h3><p>进行人物模型的微调，</p><p>让AI学习到一些新的人物概念</p><p><strong>常见文件后缀</strong>: 后缀safesensors</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p><strong>占用存储：</strong> 模型较小，10-200 MB。必须与checkpoint模型一起使用。</p><p><strong>使用方法:</strong> </p><p>（1）将模型放到  根目录&#x2F;models&#x2F;Lora</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击Lora，再点击需要用到的Lora模型，就会在提示词中添加相应的尖括号内容</p><p>除了这些以外还有DreamBooth模型，LyCORIS模型等等，这些模型在模型的进阶用法给大家介绍</p><h2 id="2-下载途径和渠道"><a href="#2-下载途径和渠道" class="headerlink" title="2. 下载途径和渠道"></a>2. 下载途径和渠道</h2><p>SD官方会发布模型</p><p>但是官方这个模型出图风格比较单一，因而我们现在下载使用的大多是私人训练的</p><p>主流下载网站</p><h3 id="2-1-C站"><a href="#2-1-C站" class="headerlink" title="2.1 C站"></a>2.1 C站</h3><p>需要科学上网  C站是最主流的一个AI绘画模型网站了，对于模型都是图像化展示，非常便捷</p><p><img src="/img%5CStable_diffusion%5Cimage-20230819105707494.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819105707494.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105707494"></p><h4 id="2-1-1-如何筛选到自己需要的模型"><a href="#2-1-1-如何筛选到自己需要的模型" class="headerlink" title="2.1.1 如何筛选到自己需要的模型"></a><strong>2.1.1 如何筛选到自己需要的模型</strong></h4><p><strong>1 通过模型生成内容区分查找  模型栏目上边有一排可以选择的</strong></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819111507513.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819111507513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111507513"></p><p><strong>2 利用我们第一节讲到的模型类型区分</strong></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819111606100.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819111606100.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111606100"></p><h4 id="2-1-2-使用技巧"><a href="#2-1-2-使用技巧" class="headerlink" title="2.1.2 使用技巧"></a>2.1.2 使用技巧</h4><p>注意模型的各种信息，包括作者推荐的VAE，分辨率设置，采样方式等等</p><p>如我们点击进入ReV Animated这个模型的下载界面，在模型的介绍界面里有show More</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105040732.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105040732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105040732"></p><p>然后就可以看到作者推荐的VAE啦，提示词prompting啦之类的</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105202493.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105202493.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105202493"></p><p>初学可以使用别人推荐的一些大模型</p><p>[stable diffusion 常用大模型解释和推荐（持续更新ing） - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/631941039#:~:text=stable">https://zhuanlan.zhihu.com/p/631941039#:~:text=stable</a> diffusion 常用大模型解释和推荐（持续更新ing） 1 基础模型（不推荐） SD系列 比如sd-v1-4、sd-v1-5、sd-v2（简写成SD1.5、SD2.0）之类的大模型，这些都是Stable-Diffusion自带的大模型，分别是1.4、1.5和2.0版本。 目前的话1.5版本更好用一些，但是,亚洲美女模型 。 … 4 2.5D%2F数绘风格 PerfectWorld 欧美版的Chilloutmix，主要绘制欧美风格的美女，不过偏2.5D，介于动漫和写实之间。 )</p><h4 id="2-1-3-学习他人作品"><a href="#2-1-3-学习他人作品" class="headerlink" title="2.1.3 学习他人作品"></a>2.1.3 学习他人作品</h4><p>C站除了优秀的模型以外，还会有很多优秀的作品，我们可以学习他们的模型搭配，提示词等等</p><p>点击C站的Images</p><p><img src="/img%5CStable_diffusion%5Cmage-20230820105459668.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cmage-20230820105459668.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105459668"></p><p>点进去以后就可以看到详细的图片生成信息,模型搭配，提示词，采样方式，种子等等</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105538667.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105538667.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105538667"></p><h3 id="2-2-HuggingFace"><a href="#2-2-HuggingFace" class="headerlink" title="2.2 HuggingFace"></a>2.2 HuggingFace</h3><p>不需要科学上网，网速较快</p><p><a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819105627701.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819105627701.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105627701">想要做出好的AI绘画，模型是最重要的，他相当于AI绘画的大脑，决定了AI绘画质量的上限，所以了解AI绘画的各种模型非常重要</p><p>相比于Midjourney，Stable Diffusion<strong>最大的优势就是开源</strong>。</p><p>因而<strong>SD则每时每刻都有人在世界各地训练自己的模型并免费公开共享给全世界的使用者</strong>。当然我们也可以训练自己的专属模型</p><p>提示词+模型+参数设置</p><p>全能型赛博画手</p><p>首先我们来了解一下模型的基本分类</p><h2 id="1-模型基本分类-1"><a href="#1-模型基本分类-1" class="headerlink" title="1.模型基本分类"></a>1.模型基本分类</h2><p>具体模型类型有checkpoint、Textual lnversion、Hypernetwork、Aesthetic Gradient、LoRA、LyCORIS、Controlnet、Poses、wildcards等等</p><p>常用的有checkpoint</p><p>哇塞，这么多，那么这些究竟都是什么意思呢？</p><h3 id="1-1-CheckPoint-大模型-底模型-主模型-1"><a href="#1-1-CheckPoint-大模型-底模型-主模型-1" class="headerlink" title="1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型"></a>1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型</h3><p>检查点，常玩游戏的朋友肯定不陌生，一般会在一些节点存档</p><p>一个大的模型训练起来是非常费力的，如果每次迭代我们都从头训练那可真实个灾难，因而训练到一定程度我们就给模型存档，生成一个关键点Checkpoint模型，</p><p><strong>常见文件后缀</strong>:后缀ckpt、safetensors（如果都有提供的话建议下载safetensors，下同）</p><p><strong>存放路径</strong>: 根目录\models\Stable-diffusion</p><p><strong>占用存储：</strong> 模型较大，占用3-7GB</p><p>我们这里的根目录都是指我们<strong>webui的最外层的那个文件夹，比如我这里的是stable-diffusion-webui</strong></p><p><strong>使用方法</strong>  将模型移动到根目录\models\Stable-diffusion后，在webui界面点击刷新按钮，再点下拉就可以看到了</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819103854526.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819103854526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819103854526"></p><p>模型推荐</p><p>二次元模型</p><p>​ menia mix  生成动漫</p><p>​AbyssOrangeMix 深源橘</p><p>​counter-feit v2.5  动漫模型</p><p>​dream Shper v5  模型   肖像画 梦幻的插画风格</p><p>真实系模型</p><p>​realistic vision v2.0 现实模型</p><p>​Delibe-rate   比较全能的一个模型</p><p>在本章第二节可以看到如何利用其他网站来筛选自己需要的模型</p><h3 id="1-2-VAE美化模型-变分自编码器-1"><a href="#1-2-VAE美化模型-变分自编码器-1" class="headerlink" title="1.2 VAE美化模型&#x2F;变分自编码器"></a>1.2 VAE美化模型&#x2F;变分自编码器</h3><p>从使用来看，我们可以把他粗略的理解为“调色滤镜”  有些时候不加载VAE的情况下，出图就会发灰发白</p><p>有很多比较新的大模型是会将VAE整合到内部的，比如Chilloutmix。如果再加VAE则可能画面效果不会更好，甚至适得其反</p><p>而有的大模型则会有自己适配的VAE，如深渊橘，这里看模型网站上作者的推荐就好</p><p>也有一些适用于大多数模型的VAE</p><p>二次元风格：kf-f8-anime</p><p>写实风格:840000</p><p><strong>常见文件后缀</strong>:后缀ckpt、pt</p><p><strong>存放路径</strong>: 根目录&#x2F;models&#x2F;VAE</p><p><strong>占用存储：</strong> 模型较小，占用0-1个GB</p><p><strong>使用方法</strong>  将模型移动到根目录\models\VAE后，在VAE选项点击刷新按钮，再点下拉就可以看到了</p><h3 id="1-3-HyperNetwork-超网络-1"><a href="#1-3-HyperNetwork-超网络-1" class="headerlink" title="1.3 HyperNetwork 超网络"></a>1.3 HyperNetwork 超网络</h3><p>hypernetworks是一个附加到stable diffusion model上的小型网络，用于微调，和embedings类似，不过现在用的也不是很多了，因为它的功能基本可以被smbeddings替代了</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;models&#x2F;hypernetworks</p><p><strong>占用存储：</strong> 模型较小，占用几百MB</p><p><strong>使用方法</strong>  注意HyperNetwork，embeddings这种微调网络和大模型使用方法不同</p><p>（1）将模型放到  根目录&#x2F;models&#x2F;hypernetworks</p><p>（2）首先点击生成按钮下的从左往右数的第三个，然后点击超网络，再点击需要用到的超网络模型，就会在提示词中添加相应的尖括号内容，如本例中的<hypernet></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820103415473.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820103415473.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820103415473"></p><h3 id="1-4-embeddings（-Textual-Inversion）-嵌入式向量-1"><a href="#1-4-embeddings（-Textual-Inversion）-嵌入式向量-1" class="headerlink" title="1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量"></a>1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量</h3><p>（1）优化画风,</p><p>（2）通过仅使用的几张图像，向模型教授新的概念，比如AI不知道奥特曼，通过embeddigns就可以让AI知道奥特曼长什么样子</p><p>（3）减少提示词的输入，比如EasyNegative这个Embeddings，里面包含了大量的负面词，可以减少你每次打一堆负面词的痛苦，解决AI绘画痛点，如画手等等</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p>模型的切换通过文件名称来触发</p><p><strong>占用存储：</strong> 模型很小，占用几十kB到几百kB</p><p><strong>使用方法:</strong></p><p>（1）将模型放到  根目录&#x2F;embeddings目录下</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击嵌式入，再点击需要用到的嵌入式模型，就会在提示词中添加相应的尖括号内容</p><h3 id="1-5-loRa-低秩适应模型-1"><a href="#1-5-loRa-低秩适应模型-1" class="headerlink" title="1.5 loRa 低秩适应模型"></a>1.5 loRa 低秩适应模型</h3><p>进行人物模型的微调，</p><p>让AI学习到一些新的人物概念</p><p><strong>常见文件后缀</strong>: 后缀safesensors</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p><strong>占用存储：</strong> 模型较小，10-200 MB。必须与checkpoint模型一起使用。</p><p><strong>使用方法:</strong> </p><p>（1）将模型放到  根目录&#x2F;models&#x2F;Lora</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击Lora，再点击需要用到的Lora模型，就会在提示词中添加相应的尖括号内容</p><p>除了这些以外还有DreamBooth模型，LyCORIS模型等等，这些模型在模型的进阶用法给大家介绍</p><h2 id="2-下载途径和渠道-1"><a href="#2-下载途径和渠道-1" class="headerlink" title="2. 下载途径和渠道"></a>2. 下载途径和渠道</h2><p>SD官方会发布模型</p><p>但是官方这个模型出图风格比较单一，因而我们现在下载使用的大多是私人训练的</p><p>主流下载网站</p><h3 id="2-1-C站-1"><a href="#2-1-C站-1" class="headerlink" title="2.1 C站"></a>2.1 C站</h3><p>需要科学上网  C站是最主流的一个AI绘画模型网站了，对于模型都是图像化展示，非常便捷</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819105707494.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819105707494.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105707494"></p><h4 id="2-1-1-如何筛选到自己需要的模型-1"><a href="#2-1-1-如何筛选到自己需要的模型-1" class="headerlink" title="2.1.1 如何筛选到自己需要的模型"></a><strong>2.1.1 如何筛选到自己需要的模型</strong></h4><p><strong>1 通过模型生成内容区分查找  模型栏目上边有一排可以选择的</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819111507513.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819111507513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111507513"></p><p><strong>2 利用我们第一节讲到的模型类型区分</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819111606100.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819111606100.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111606100"></p><h4 id="2-1-2-使用技巧-1"><a href="#2-1-2-使用技巧-1" class="headerlink" title="2.1.2 使用技巧"></a>2.1.2 使用技巧</h4><p>注意模型的各种信息，包括作者推荐的VAE，分辨率设置，采样方式等等</p><p>如我们点击进入ReV Animated这个模型的下载界面，在模型的介绍界面里有show More</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105040732.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105040732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105040732"></p><p>然后就可以看到作者推荐的VAE啦，提示词prompting啦之类的</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105202493.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105202493.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105202493"></p><p>初学可以使用别人推荐的一些大模型</p><p>[stable diffusion 常用大模型解释和推荐（持续更新ing） - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/631941039#:~:text=stable">https://zhuanlan.zhihu.com/p/631941039#:~:text=stable</a> diffusion 常用大模型解释和推荐（持续更新ing） 1 基础模型（不推荐） SD系列 比如sd-v1-4、sd-v1-5、sd-v2（简写成SD1.5、SD2.0）之类的大模型，这些都是Stable-Diffusion自带的大模型，分别是1.4、1.5和2.0版本。 目前的话1.5版本更好用一些，但是,亚洲美女模型 。 … 4 2.5D%2F数绘风格 PerfectWorld 欧美版的Chilloutmix，主要绘制欧美风格的美女，不过偏2.5D，介于动漫和写实之间。 )</p><h4 id="2-1-3-学习他人作品-1"><a href="#2-1-3-学习他人作品-1" class="headerlink" title="2.1.3 学习他人作品"></a>2.1.3 学习他人作品</h4><p>C站除了优秀的模型以外，还会有很多优秀的作品，我们可以学习他们的模型搭配，提示词等等</p><p>点击C站的Images</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105459668.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105459668.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105459668"></p><p>点进去以后就可以看到详细的图片生成信息,模型搭配，提示词，采样方式，种子等等</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105538667.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230820105538667.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105538667"></p><h3 id="2-2-HuggingFace-1"><a href="#2-2-HuggingFace-1" class="headerlink" title="2.2 HuggingFace"></a>2.2 HuggingFace</h3><p>不需要科学上网，网速较快</p><p><a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819105627701.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230819105627701.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105627701"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（二）AI提示词</title>
      <link href="/2023/07/16/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/2%20%EF%BC%A1%EF%BC%A9%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
      <url>/2023/07/16/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/2%20%EF%BC%A1%EF%BC%A9%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>Prompts提示词是指用户输入的指导模型生成图像的文本信息，他是我们要告诉AI 我要画什么，怎么画最方便的方式</p><p>可以想象我们是呼风唤雨的魔法师，那么Promts就好比我们的咒语</p><p>不过有些时候我们的咒语不那么灵验，因为我们的AI绘画具有随机性，所以需要多多尝试</p><p>我们知道AI绘画可以图生图，但是即便图生图也会依赖好的提示词</p><p>接下来我们就从提示词规则，分类等来快速入门提示词</p><p>首先我们来来了解提示词基本规则</p><h2 id="1-提示词-基本的规则"><a href="#1-提示词-基本的规则" class="headerlink" title="1.提示词 基本的规则"></a>1.提示词 基本的规则</h2><p>（1）英文书写  可以求助翻译软件</p><p>（2）词组作为单位，不需要主谓宾句子结构</p><p>​比如画一个在阳光下骑车的男孩</p><p>​提示词写为  男孩，骑车，阳光下即可</p><p>（3）提示词分隔符英文逗号，</p><p>（4）提示词可以换行，但每一行结尾要打上分隔符,</p><h2 id="2-提示词分类"><a href="#2-提示词分类" class="headerlink" title="2.提示词分类"></a>2.提示词分类</h2><p>提示词不是一下子写好的，是先有雏形，然后再慢慢微调得到的</p><p>提示词也不是混乱不堪的，优秀的提示词分别包含以下内容，我们可以按照顺序依次填写自己需要的</p><h3 id="2-1内容性提示词"><a href="#2-1内容性提示词" class="headerlink" title="2.1内容性提示词"></a>2.1内容性提示词</h3><p>内容性提示词实际上就是告诉AI绘画我们要画什么</p><p><strong>人类以及主体</strong></p><p>​服饰穿搭 pink dress,</p><p>​发型发色  long hair  black hair</p><p>​五官特点 big eyes,small mouth</p><p>​面部表情  laughing</p><p>​肢体动作  stretching arms</p><p><strong>场景特征</strong></p><p>​室内  indoor</p><p>​室外  outdoor</p><p>​大场景 forest，city</p><p>​小细节 bush, a white flower</p><p><strong>环境光照</strong></p><p>​白天   day</p><p>​黑夜   night</p><p>​特定时段  morning</p><p>​光环境  sunlight</p><p>​天空  blue sky</p><h3 id="2-2-画风艺术派提示词"><a href="#2-2-画风艺术派提示词" class="headerlink" title="2.2 画风艺术派提示词"></a>2.2 画风艺术派提示词</h3><p>​插画风illustration </p><p>​二次元   anime ，comic ，game CG</p><p>​写实系   photo realistic，realistic，photograph</p><h3 id="2-3-画幅视角"><a href="#2-3-画幅视角" class="headerlink" title="2.3 画幅视角"></a>2.3 <strong>画幅视角</strong></h3><p>​距离  close-up,distant</p><p>​人物比例   full body,upper body</p><p>​观察视角   from above,view of back</p><p>​镜头类型  wide angle m Sony A7 III</p><h3 id="2-4画质提示词"><a href="#2-4画质提示词" class="headerlink" title="2.4画质提示词"></a>2.4画质提示词</h3><p>通用高画质</p><p>​best quailty</p><p>​ultra-detailed</p><p>​masterpiece</p><p>​hires</p><p>​8k</p><p>特定高分辨率类型</p><p>​extremely detailed CG unity 8k wallpaper （超精细8k Unity 游戏CG）</p><p>​unreal engine rendered（虚幻引擎渲染）</p><h2 id="3-反向提示词"><a href="#3-反向提示词" class="headerlink" title="3 反向提示词"></a>3 反向提示词</h2><h3 id="3-1-内容性反向提示词"><a href="#3-1-内容性反向提示词" class="headerlink" title="3.1 内容性反向提示词"></a>3.1 内容性反向提示词</h3><p>single background 单一背景</p><p> bad hands 不好的手</p><p>missing fingers 缺少手指</p><p>bad anatomy 身体姿态不良</p><p>long neck 长脖子</p><p>mutated hands 突变的手</p><p>poorly drawn hands 画的不好的手</p><p>poorly drawn face 画的不好的脸</p><p>missing arms 缺少手臂</p><p>missing legs 缺少腿</p><p> extra arms 缺少胳膊</p><p>extra legs 缺少腿</p><h3 id="3-2-画质性反向提示词"><a href="#3-2-画质性反向提示词" class="headerlink" title="3.2 画质性反向提示词"></a>3.2 画质性反向提示词</h3><p>worst quality, 最差质量</p><p>low quality 低质量</p><p>上述大概了解有哪些，我们后续会对于一些人物有一些特定模板可以直接用</p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4 实例分析"></a>4 实例分析</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230817101306166.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230817101306166.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230817101306166"></p><p>正向提示词</p><blockquote><p>&lt;!–swig￼0–&gt;, &lt;!–swig￼1–&gt;,<br> little girl, grey long hair , blue eyes, shirt, hat, hoodie, shoes , headphones, smirk, cute face, head tilt,<br>outdoor, forest,bush,  sunlight,<br>illustration,<br>full body</p></blockquote><p>反向提示词</p><blockquote><p>signature, watermark, username, blurry, missing arms, long neck, humpbacked, bad feet, {bad anatomy},single background, {bad hands},missing fingers,<br>{lowres}, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, artifacts, nsfw,</p></blockquote><p>一般而言，优质出图有一定的固定模板</p><h2 id="5-权重"><a href="#5-权重" class="headerlink" title="5 权重"></a>5 权重</h2><p>观察别人的提示词咒语，会发现有很多的括号</p><h3 id="5-1-方法一"><a href="#5-1-方法一" class="headerlink" title="5.1 方法一"></a>5.1 方法一</h3><p><strong>括号加数字</strong></p><p>​示例：</p><p>​{a white flower :1.5} 调节白花权重为原来1.5倍</p><p>​{white flower:  0.8} 调节白花权重为 0.8倍</p><h3 id="5-2-方法二"><a href="#5-2-方法二" class="headerlink" title="5.2 方法二"></a>5.2 方法二</h3><p><strong>套括号</strong></p><p> 适合于微调</p><p>提示词套圆括号（）</p><p>​每一层圆括号，权重×1.1</p><p>​比如两层圆括号，提示词权重1.1 *1.1&#x3D;1.331</p><p>提示词套大括号{}</p><p>​每一层大括号，权重×1.05</p><p>提示词套方括号[]</p><p>​每一层大括号，权重×0.9</p><p>经验：权重不能太高，最好小于1.5，否则会导致扭曲</p><p>提示词权重分配 进阶语法</p><p>​如混合，迁移，迭代</p><p>后面会给大家介绍</p><h2 id="6-参数"><a href="#6-参数" class="headerlink" title="6.参数"></a>6.参数</h2><p>如果把提示词比作咒语，那么参数是魔杖或者魔导书</p><p><strong>采样方法</strong></p><p>​采样方法具体是什么涉及到模型原理，不必深究，我们这里只需要知道什么时候用什么样的采样方法即可，一般遵循如下原则</p><p>​（1）在显卡给力，时间充裕的条件下，可以自己尝试比较不同的采样方法</p><p>​（2）一般在C站下载模型的同时，模型作者会给出他觉得比较好的采样方式，这是作者已经经过大量实验的结论，可以帮助你节约时间</p><p>​（3）没有作者相关建议的时候</p><p>​对于二次元图  DPM++ 2M或DPM++ 2M Karras  UniPC</p><p>​对于真实系图 Euler a、DPM++ SDE、DPM++ SDE Karras</p><p>​同时，一般而言带++的都相对来说不戳</p><p><strong>迭代采样步数</strong></p><p>理论上采样步数越多画面越清晰，但超过２０步之后，后面的提升不大，增加步数意味着出图时间增长，一般维持在２０到４０之间即可</p><p>以下是不同情况下使用哪个步骤编号的一般指南：</p><p>​（1）如果正在测试新的提示，并希望获得快速结果来调整您的输入，请使用10-15个步骤</p><p>​（2）当您找到您喜欢的提示时，请将步骤增加到25</p><p>​（3）如果是有毛皮的动物或有纹理的主题，生成的图像缺少一些细节，尝试将其提高到40</p><p><strong>面部修复</strong>：修复人物的面部，但是非写实风格的人物开启面部修复可能导致面部崩坏。<br><strong>平铺&#x2F;分块</strong>：生成一张可以平铺的图像<br><strong>高分辨率重绘</strong>：使用两个步骤的过程进行生成，以较小的分辨率创建图像，然后在不改变构图的情况下改进其中的细节，选中后会有新的参数，之后专门出一篇介绍</p><p><strong>宽度高度</strong> 出图分辨率设置  最佳的范围应在512至768像素之间</p><p>设置的出图分辨率太低，会导致图像不清晰</p><p>设置的出图的分辨率过高，一方面显存支撑不了，另外一方面可能会导致图像生成多人情况，</p><p><strong>生成批次</strong>：每次生成图像的组数。<br><strong>每批数量</strong>：每组多少个图像。图像总数是这个值乘以批次数。除 4090 等高级显卡以外通常保持为 1</p><p><strong>提示词相关性CFG</strong>：较高的数值将提高生成结果与提示的匹配度。<br>OpenArt上使用的默认CFG是7，这在创造力和生成你想要的东西之间提供了最佳平衡。通常不建议低于5。<br>CFG量表可以分为不同的范围，每个范围都适合不同的提示类型和目标<br>CFG 2 – 6：有创意，但可能太扭曲，没有遵循提示。对于简短的提示来说，可以很有趣和有用<br>CFG 7-10：推荐用于大多数提示。创造力和引导一代之间的良好平衡<br>CFG 10-15：当您确定您的提示是详细且非常清晰的，您希望图像是什么样子时<br>CFG 16-20：除非提示非常详细，否则通常不推荐。可能影响一致性和质量<br>CFG &gt;20：几乎无法使用</p><p><strong>随机种子（Seed）</strong>:生成每张图片时的随机种子，这个种子是用来作为确定扩散初始状态的基础。不懂的话，用随机的即可。</p><h2 id="7-学习and-技巧"><a href="#7-学习and-技巧" class="headerlink" title="7. 学习and 技巧"></a>7. 学习and 技巧</h2><p>当然知道上面的知识还远远不够，需要多多学习他人写提示词的方式</p><p>写提示词</p><p>翻译大法，插件</p><p>利用AI工具  AI绘画提示词生成器，AI词语加速器</p><p>选择性  抄作业    openart.ai     arthub.ai</p><h3 id="7-1-辅助写提示词的网站"><a href="#7-1-辅助写提示词的网站" class="headerlink" title="7.1 辅助写提示词的网站"></a>7.1 辅助写提示词的网站</h3><p>（1）AI绘画提示词生成器</p><p><a href="http://www.atoolbox.net/Tool.php?Id=1101">AI绘画提示词生成器 - 一个工具箱 - 好用的在线工具都在这里！ (atoolbox.net)</a></p><p>（2）AI 词汇加速器</p><p><a href="https://ai.dawnmark.cn/">AI词汇加速器 AcceleratorI Prompt (dawnmark.cn)</a>权重设置</p><p>使用这些工具像是经历一个更方便的过程，但思路不要被他索限制</p><p>（3）词图</p><p><a href="https://www.prompttool.com/NovelAI">词图PromptTool - AI绘画</a></p><p>（4）AI创造者</p><p><a href="https://ai-creator.net/arts">AI creator - AI Creator|AI Art gallery | 创作者AI (ai-creator.net)</a></p><h3 id="7-2-学习他人优秀作品"><a href="#7-2-学习他人优秀作品" class="headerlink" title="7.2 学习他人优秀作品"></a>7.2 学习他人优秀作品</h3><p>有很多网站会放出优秀作品，其中的作者也会分享自己的prmpts，可供我们学习</p><p>（1） openart.ai   </p><p>​里面有很多基于sd官方模型和欧美模型的生成的作品</p><p>​<a href="https://openart.ai/home">Home | OpenArt</a></p><p>  （2）arthub.ai</p><p>​里面更多一些二次元和亚洲风的作品</p><p><a href="https://arthub.ai/">Arthub.ai: Discover, Upload and Share AI Generated Art</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（一）AI绘画quickly入门</title>
      <link href="/2023/07/14/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/1%20AI%E7%BB%98%E7%94%BBquickly%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/14/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/1%20AI%E7%BB%98%E7%94%BBquickly%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><p>​在2012年，就有很多的学## 1.基本原理</p><p>​在2012年，就有很多的学者对图像生成展开了研究，但在那时候，因为算法，数据，算力等各方面原因，生成的图像过于“抽象” ，可以称他为灵魂画手，直到最近两年，AI产出的图像内容在质量上和准确度上渐渐地变得更高，同时由于一些辅助装备，如ControlNet等让AI绘画可控性更高，也更受到大家的重视。</p><p>​现在的主流的AI绘画模型，主要运用了扩散Diffusion模型，他很人类绘画相比差异很大，不是起稿，勾线，描边，上色等步骤按部就班完成的，他采取了一个独特的方式</p><p>首先它将图片通过增加噪声的方式进行“扩散”，也就是让他变得更模糊，当内容模糊之后，我们就可以理解为有更大的空间让它自由发挥了，AI也是如此，但是在训练它的过程中，它可以学习到一种重要的能力，就是逐步恢复这种杂乱的噪声为真实图像</p><p>而如果在训练的过程中我们给AI 一些限制条件等，AI就可以按我们限制条件去恢复生成我们想要的图像了</p><h2 id="2-主流方式"><a href="#2-主流方式" class="headerlink" title="2.主流方式"></a>2.主流方式</h2><p><strong>Midjourney，DALL E等方式</strong></p><p>​（1）出图额度需要购买会员（换句话说就是需要付费）直接租价格比较贵，可以去租用共享账号</p><p>​（2）较容易出比较高质量的图</p><p>​（3）模型部署在云端，不需要本地电脑配置较高</p><p><strong>Stable Diffusion</strong></p><p>​（1）是一款免费的软件，可以无限制出图</p><p>​（2）但是有一定的上手门槛，出图质量需要较多的调控才能达到满意的效果，因而我们这系列教程主要围绕stable diffusion</p><p>​（3）部署在本地，比较吃电脑配置，显卡内存（也可以部署在GPU服务器）</p><p>​（4）但是由于开源，依托强大的开源社区，收获非常多的活跃用户，可以进行个性化的训练，个性化程度较高</p><h2 id="3-配置要求"><a href="#3-配置要求" class="headerlink" title="3.配置要求"></a>3.配置要求</h2><h3 id="3-1-显卡方面"><a href="#3-1-显卡方面" class="headerlink" title="3.1 显卡方面"></a>3.1 显卡方面</h3><p><strong>显卡品牌型号</strong> N卡（英伟达的独立显卡）首选，目前也支持A卡，但是速度较N卡慢</p><p>不同品牌型号，意味着显卡的算力不同，进而影响着出图的速度</p><p>查看自己的显卡品牌型号的方法如下链接</p><p><a href="https://zhuanlan.zhihu.com/p/462233007">分享几种查看本机显卡类型的方法~~ - 知乎 (zhihu.com)</a></p><p>查到以后可以对照下表 ，下表是不同型号N卡出一张512*512分辨率的图片，迭代步数为100步的时间 </p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230815210656999.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230815210656999.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815210656999"></p><p>图片来源 B站 Nenly同学</p><p><strong>显卡内存</strong>  最少8GB能玩，16GB及格，上不封顶，越高玩的越爽        内存主要影响着出图分辨率，模型大小等</p><p><strong>硬盘空间</strong>  最少有60GB以上的硬盘空间，因为我们需要下载很多模型，而一个模型往往都有几个GB</p><h2 id="4-基本界面"><a href="#4-基本界面" class="headerlink" title="4.基本界面"></a>4.基本界面</h2><p>下面界面是加了一些插件之后的，如中文插件，图库浏览器，如果你使用的是一些大佬的整合包，那么一般他们都会帮助你安装好，但是如果没有也无所谓，我们会在之后给大家讲解插件的安装</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814164648622.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814164648622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814164648622"></p><h3 id="4-1-模型设置区"><a href="#4-1-模型设置区" class="headerlink" title="4.1 模型设置区"></a>4.1 模型设置区</h3><p>左上角用来更换模型</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814164736337.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814164736337.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814164736337"></p><p>点击下拉箭头查看并且选择模型</p><p>模型需要我们提前下载并且保存到    根目录&#x2F;models&#x2F;Stable-diffusion文件夹下</p><p>当我们保存模型到上述文件夹下后，点击蓝色的刷新按钮，刷新模型，再点击下拉箭头就可以看到我们的模型了</p><h3 id="4-2-菜单栏区域"><a href="#4-2-菜单栏区域" class="headerlink" title="4.2 菜单栏区域"></a>4.2 菜单栏区域</h3><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814165333774.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814165333774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814165333774"></p><p>一些基本功能</p><p>最常用的两个 文生图，图生图</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>文生图</td><td>由prompts提示词生成图片</td></tr><tr><td>图生图</td><td>由已有的图片+提示词生成图片</td></tr><tr><td>图库浏览器（后安装的插件）</td><td>查看生成的图片</td></tr><tr><td>Tag 反推</td><td>由图片反推提示词prompts</td></tr><tr><td>设置</td><td>进行一些设置操作</td></tr><tr><td>扩展</td><td>进行扩展安装管理等操作</td></tr></tbody></table><p>其他我们用到的时候再介绍</p><h3 id="4-3-提示词区"><a href="#4-3-提示词区" class="headerlink" title="4.3 提示词区"></a>4.3 提示词区</h3><p>最关键的一个区域，也就是我们念咒语的地方，这里用英语撰写（可以用翻译软件）</p><p><strong>正向提示词</strong>  希望画面出现的内容，一般我们会有一些固定的提示词，如（杰作masterpiece, 最高质量best quality，高细节）特定模型也会有特定的让画面质量变高的正向提示词</p><p><strong>反向提示词</strong>  不希望画面出现的内容，如（丑陋的，多手指的）</p><p>之后会给大家专门总结，到时候直接复制粘贴即可</p><p>提示词区右边的生成下边有五个小图标，相当于一些快捷键，从左到右依次为</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230815211951592.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230815211951592.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815211951592"></p><table><thead><tr><th>图标</th><th>作用</th></tr></thead><tbody><tr><td>箭头</td><td>复原上次生成图片的提示词（自动记录）</td></tr><tr><td>垃圾桶</td><td>清空当前所有提示词</td></tr><tr><td>红色日出</td><td>打开其他模型选择界面如Embedding，HypernetWork的选择，这些模型后面会单独讲到</td></tr><tr><td>记事薄</td><td>应用选择的风格模板到当前提示词，就是着五个小图标下面那个风格模板选项</td></tr><tr><td>保存按钮</td><td>保存当前的正反向提示词</td></tr></tbody></table><h3 id="4-4-出图设置区"><a href="#4-4-出图设置区" class="headerlink" title="4.4 出图设置区"></a>4.4 出图设置区</h3><p>如图</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814165739102.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230814165739102.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814165739102" style="zoom: 67%;" /><p><strong>从上到下，左到右依次介绍</strong></p><p><strong>采样方法</strong></p><p>​采样方法具体是什么涉及到模型原理，不必深究，我们这里只需要知道什么时候用什么样的采样方法即可，一般遵循如下原则</p><p>​（1）在显卡给力，时间充裕的条件下，可以自己尝试比较不同的采样方法</p><p>​（2）一般在C站下载模型的同时，模型作者会给出他觉得比较好的采样方式，这是作者已经经过大量实验的结论，可以帮助你节约时间</p><p>​（3）没有作者相关建议的时候</p><p>​对于二次元图  DPM++ 2M或DPM++ 2M Karras  UniPC</p><p>​对于真实系图 Euler a、DPM++ SDE、DPM++ SDE Karras</p><p>​同时，一般而言带++的都相对来说不戳</p><p><strong>迭代采样步数</strong></p><p>之前讲原理的时候，模型将噪声一步一步恢复到真实图片，此参数控制这些去噪步骤的数量。通常越高越好，但在一定程度上，我们使用的默认值是25个步骤。以下是不同情况下使用哪个步骤编号的一般指南：</p><p>​（1）如果正在测试新的提示，并希望获得快速结果来调整您的输入，请使用10-15个步骤</p><p>​（2）当您找到您喜欢的提示时，请将步骤增加到25</p><p>​（3）如果是有毛皮的动物或有纹理的主题，生成的图像缺少一些细节，尝试将其提高到40</p><p><strong>面部修复</strong>：修复人物的面部，但是非写实风格的人物开启面部修复可能导致面部崩坏。<br><strong>平铺&#x2F;分块</strong>：生成一张可以平铺的图像<br><strong>高分辨率重绘</strong>：使用两个步骤的过程进行生成，以较小的分辨率创建图像，然后在不改变构图的情况下改进其中的细节，选中后会有新的参数，之后专门出一篇介绍</p><p><strong>宽度高度</strong> 出图分辨率设置  最佳的范围应在512至768像素之间</p><p>设置的出图分辨率太低，会导致图像不清晰</p><p>设置的出图的分辨率过高，一方面显存支撑不了，另外一方面可能会导致图像生成多人情况，</p><p><strong>生成批次</strong>：每次生成图像的组数。<br><strong>每批数量</strong>：每组多少个图像。图像总数是这个值乘以批次数。除 4090 等高级显卡以外通常保持为 1</p><p><strong>提示词相关性CFG</strong>：较高的数值将提高生成结果与提示的匹配度。<br>OpenArt上使用的默认CFG是7，这在创造力和生成你想要的东西之间提供了最佳平衡。通常不建议低于5。<br>CFG量表可以分为不同的范围，每个范围都适合不同的提示类型和目标<br>CFG 2 – 6：有创意，但可能太扭曲，没有遵循提示。对于简短的提示来说，可以很有趣和有用<br>CFG 7-10：推荐用于大多数提示。创造力和引导一代之间的良好平衡<br>CFG 10-15：当您确定您的提示是详细且非常清晰的，您希望图像是什么样子时<br>CFG 16-20：除非提示非常详细，否则通常不推荐。可能影响一致性和质量<br>CFG &gt;20：几乎无法使用</p><p><strong>随机种子（Seed）</strong>:生成每张图片时的随机种子，这个种子是用来作为确定扩散初始状态的基础。不懂的话，用随机的即可。</p><h2 id="5-文生图基本操作流程"><a href="#5-文生图基本操作流程" class="headerlink" title="5.文生图基本操作流程"></a>5.文生图基本操作流程</h2><p>我们可能一下子了解不了这么多，大家可能都看困了，那么我们来亲自来出一张图，体验一下基本的过程，加深印象</p><h3 id="5-1-选用模型，撰写提示词"><a href="#5-1-选用模型，撰写提示词" class="headerlink" title="5.1 选用模型，撰写提示词"></a>5.1 选用模型，撰写提示词</h3><p>在左上角模型选取，选择深渊橘模型</p><p><strong>写提示词</strong></p><p><strong>画面内容</strong> 用自己的语言描述一个画面出来</p><p>如  一个女生在城市里骑着自行车，阳光洒在她的身上，但是提示词不认中文打开翻译软件，翻译即可</p><p>A girl rides a bicycle in the city, and the sunlight  shines on her</p><p>但仅有这个远远不够，不相信？给你看一下这样<strong>图片直出 有多离谱</strong></p><p>点击生成，喀嚓，生成如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00061-202973728-A%20girl%20rides%20a%20bicycle%20in%20the%20city%20and%20the%20sunlight%20%20shines%20on%20her_b7c2db5a94e11e2b3e236598b41eaad053a308d7.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00061-202973728-A%20girl%20rides%20a%20bicycle%20in%20the%20city%20and%20the%20sunlight%20%20shines%20on%20her_b7c2db5a94e11e2b3e236598b41eaad053a308d7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00061-202973728-A girl rides a bicycle in the city and the sunlight  shines on her_b7c2db5a94e11e2b3e236598b41eaad053a308d7"></p><p>惨不忍睹，所以还需要加一些正面对画面质量这些约束的咒语</p><p><strong>在正向提示框加入</strong></p><p>SFW, (masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</p><p><strong>反向提示框加入</strong></p><p>NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</p><h3 id="5-2-进行出图设置"><a href="#5-2-进行出图设置" class="headerlink" title="5.2 进行出图设置"></a>5.2 进行出图设置</h3><p>我们就将采样方式设置为 DPM++ 2M</p><h3 id="5-3-再次出图！"><a href="#5-3-再次出图！" class="headerlink" title="5.3 再次出图！"></a>5.3 再次出图！</h3><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00068-300861399-A%20girl%20rides%20a%20bicycle%20in%20the%20city,%20and%20the%20sunlight%20%20shines%20on%20her_SFW,%20(masterpiece_1,2),%20best%20quality,%20masterpiece,%20highres,.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/00068-300861399-A%20girl%20rides%20a%20bicycle%20in%20the%20city,%20and%20the%20sunlight%20%20shines%20on%20her_SFW,%20(masterpiece_1,2),%20best%20quality,%20masterpiece,%20highres,.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00068-300861399-A girl rides a bicycle in the city, and the sunlight  shines on her_SFW, (masterpiece_1,2), best quality, masterpiece, highres,"></p><p>不能说有多好，但至少比刚才好了一些，当然后续还会介绍更多技巧提升画面质量</p><p>所以我们要意识到一点， stable diffusion 出一张好图是不容易的，这也是为什么显卡这些的重要性，它可以让我们低成本试错</p><h3 id="5-4-保存"><a href="#5-4-保存" class="headerlink" title="5.4 保存"></a>5.4 保存</h3><p>点击图库浏览器，可以查看生成的图片</p><p>想把他导出来</p><p>右键，另存为即可</p><p>或者找到根目录下的outputs文件夹</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
